// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v20220101

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanism struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AddRemoveIncrementalNamedPartition'.
	Kind string `pulumi:"kind"`
	// Maximum number of named partitions of the service.
	MaxPartitionCount int `pulumi:"maxPartitionCount"`
	// Minimum number of named partitions of the service.
	MinPartitionCount int `pulumi:"minPartitionCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AddRemoveIncrementalNamedPartition'.
	Kind string `pulumi:"kind"`
	// Maximum number of named partitions of the service.
	MaxPartitionCount int `pulumi:"maxPartitionCount"`
	// Minimum number of named partitions of the service.
	MinPartitionCount int `pulumi:"minPartitionCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicy struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError bool `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ServiceTypeHealthPolicy `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications int `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]ServiceTypeHealthPolicy `pulumi:"serviceTypeHealthPolicyMap"`
}

// ApplicationHealthPolicyInput is an input type that accepts ApplicationHealthPolicyArgs and ApplicationHealthPolicyOutput values.
// You can construct a concrete instance of `ApplicationHealthPolicyInput` via:
//
//	ApplicationHealthPolicyArgs{...}
type ApplicationHealthPolicyInput interface {
	pulumi.Input

	ToApplicationHealthPolicyOutput() ApplicationHealthPolicyOutput
	ToApplicationHealthPolicyOutputWithContext(context.Context) ApplicationHealthPolicyOutput
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyArgs struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError pulumi.BoolInput `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy ServiceTypeHealthPolicyPtrInput `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications pulumi.IntInput `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap ServiceTypeHealthPolicyMapInput `pulumi:"serviceTypeHealthPolicyMap"`
}

func (ApplicationHealthPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicy)(nil)).Elem()
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyOutput() ApplicationHealthPolicyOutput {
	return i.ToApplicationHealthPolicyOutputWithContext(context.Background())
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyOutputWithContext(ctx context.Context) ApplicationHealthPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyOutput)
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return i.ToApplicationHealthPolicyPtrOutputWithContext(context.Background())
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyOutput).ToApplicationHealthPolicyPtrOutputWithContext(ctx)
}

// ApplicationHealthPolicyPtrInput is an input type that accepts ApplicationHealthPolicyArgs, ApplicationHealthPolicyPtr and ApplicationHealthPolicyPtrOutput values.
// You can construct a concrete instance of `ApplicationHealthPolicyPtrInput` via:
//
//	        ApplicationHealthPolicyArgs{...}
//
//	or:
//
//	        nil
type ApplicationHealthPolicyPtrInput interface {
	pulumi.Input

	ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput
	ToApplicationHealthPolicyPtrOutputWithContext(context.Context) ApplicationHealthPolicyPtrOutput
}

type applicationHealthPolicyPtrType ApplicationHealthPolicyArgs

func ApplicationHealthPolicyPtr(v *ApplicationHealthPolicyArgs) ApplicationHealthPolicyPtrInput {
	return (*applicationHealthPolicyPtrType)(v)
}

func (*applicationHealthPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicy)(nil)).Elem()
}

func (i *applicationHealthPolicyPtrType) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return i.ToApplicationHealthPolicyPtrOutputWithContext(context.Background())
}

func (i *applicationHealthPolicyPtrType) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyPtrOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicy)(nil)).Elem()
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyOutput() ApplicationHealthPolicyOutput {
	return o
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyOutputWithContext(ctx context.Context) ApplicationHealthPolicyOutput {
	return o
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return o.ToApplicationHealthPolicyPtrOutputWithContext(context.Background())
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ApplicationHealthPolicy) *ApplicationHealthPolicy {
		return &v
	}).(ApplicationHealthPolicyPtrOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyOutput) ConsiderWarningAsError() pulumi.BoolOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) bool { return v.ConsiderWarningAsError }).(pulumi.BoolOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) *ServiceTypeHealthPolicy { return v.DefaultServiceTypeHealthPolicy }).(ServiceTypeHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) int { return v.MaxPercentUnhealthyDeployedApplications }).(pulumi.IntOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyMapOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) map[string]ServiceTypeHealthPolicy {
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyMapOutput)
}

type ApplicationHealthPolicyPtrOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicy)(nil)).Elem()
}

func (o ApplicationHealthPolicyPtrOutput) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return o
}

func (o ApplicationHealthPolicyPtrOutput) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return o
}

func (o ApplicationHealthPolicyPtrOutput) Elem() ApplicationHealthPolicyOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) ApplicationHealthPolicy {
		if v != nil {
			return *v
		}
		var ret ApplicationHealthPolicy
		return ret
	}).(ApplicationHealthPolicyOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyPtrOutput) ConsiderWarningAsError() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) *bool {
		if v == nil {
			return nil
		}
		return &v.ConsiderWarningAsError
	}).(pulumi.BoolPtrOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyPtrOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) *ServiceTypeHealthPolicy {
		if v == nil {
			return nil
		}
		return v.DefaultServiceTypeHealthPolicy
	}).(ServiceTypeHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyPtrOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyDeployedApplications
	}).(pulumi.IntPtrOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyPtrOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyMapOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) map[string]ServiceTypeHealthPolicy {
		if v == nil {
			return nil
		}
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyMapOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyResponse struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError bool `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ServiceTypeHealthPolicyResponse `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications int `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]ServiceTypeHealthPolicyResponse `pulumi:"serviceTypeHealthPolicyMap"`
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyResponseOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicyResponse)(nil)).Elem()
}

func (o ApplicationHealthPolicyResponseOutput) ToApplicationHealthPolicyResponseOutput() ApplicationHealthPolicyResponseOutput {
	return o
}

func (o ApplicationHealthPolicyResponseOutput) ToApplicationHealthPolicyResponseOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponseOutput {
	return o
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyResponseOutput) ConsiderWarningAsError() pulumi.BoolOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) bool { return v.ConsiderWarningAsError }).(pulumi.BoolOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyResponseOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) *ServiceTypeHealthPolicyResponse {
		return v.DefaultServiceTypeHealthPolicy
	}).(ServiceTypeHealthPolicyResponsePtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyResponseOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) int { return v.MaxPercentUnhealthyDeployedApplications }).(pulumi.IntOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyResponseOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyResponseMapOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) map[string]ServiceTypeHealthPolicyResponse {
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyResponseMapOutput)
}

type ApplicationHealthPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicyResponse)(nil)).Elem()
}

func (o ApplicationHealthPolicyResponsePtrOutput) ToApplicationHealthPolicyResponsePtrOutput() ApplicationHealthPolicyResponsePtrOutput {
	return o
}

func (o ApplicationHealthPolicyResponsePtrOutput) ToApplicationHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponsePtrOutput {
	return o
}

func (o ApplicationHealthPolicyResponsePtrOutput) Elem() ApplicationHealthPolicyResponseOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) ApplicationHealthPolicyResponse {
		if v != nil {
			return *v
		}
		var ret ApplicationHealthPolicyResponse
		return ret
	}).(ApplicationHealthPolicyResponseOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyResponsePtrOutput) ConsiderWarningAsError() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.ConsiderWarningAsError
	}).(pulumi.BoolPtrOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyResponsePtrOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) *ServiceTypeHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.DefaultServiceTypeHealthPolicy
	}).(ServiceTypeHealthPolicyResponsePtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyResponsePtrOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyDeployedApplications
	}).(pulumi.IntPtrOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyResponsePtrOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyResponseMapOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) map[string]ServiceTypeHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyResponseMapOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicy struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep int `pulumi:"maxUnusedVersionsToKeep"`
}

// ApplicationTypeVersionsCleanupPolicyInput is an input type that accepts ApplicationTypeVersionsCleanupPolicyArgs and ApplicationTypeVersionsCleanupPolicyOutput values.
// You can construct a concrete instance of `ApplicationTypeVersionsCleanupPolicyInput` via:
//
//	ApplicationTypeVersionsCleanupPolicyArgs{...}
type ApplicationTypeVersionsCleanupPolicyInput interface {
	pulumi.Input

	ToApplicationTypeVersionsCleanupPolicyOutput() ApplicationTypeVersionsCleanupPolicyOutput
	ToApplicationTypeVersionsCleanupPolicyOutputWithContext(context.Context) ApplicationTypeVersionsCleanupPolicyOutput
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyArgs struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep pulumi.IntInput `pulumi:"maxUnusedVersionsToKeep"`
}

func (ApplicationTypeVersionsCleanupPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyOutput() ApplicationTypeVersionsCleanupPolicyOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyOutputWithContext(context.Background())
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyOutput)
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Background())
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyOutput).ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx)
}

// ApplicationTypeVersionsCleanupPolicyPtrInput is an input type that accepts ApplicationTypeVersionsCleanupPolicyArgs, ApplicationTypeVersionsCleanupPolicyPtr and ApplicationTypeVersionsCleanupPolicyPtrOutput values.
// You can construct a concrete instance of `ApplicationTypeVersionsCleanupPolicyPtrInput` via:
//
//	        ApplicationTypeVersionsCleanupPolicyArgs{...}
//
//	or:
//
//	        nil
type ApplicationTypeVersionsCleanupPolicyPtrInput interface {
	pulumi.Input

	ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput
	ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput
}

type applicationTypeVersionsCleanupPolicyPtrType ApplicationTypeVersionsCleanupPolicyArgs

func ApplicationTypeVersionsCleanupPolicyPtr(v *ApplicationTypeVersionsCleanupPolicyArgs) ApplicationTypeVersionsCleanupPolicyPtrInput {
	return (*applicationTypeVersionsCleanupPolicyPtrType)(v)
}

func (*applicationTypeVersionsCleanupPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (i *applicationTypeVersionsCleanupPolicyPtrType) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Background())
}

func (i *applicationTypeVersionsCleanupPolicyPtrType) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyPtrOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyOutput() ApplicationTypeVersionsCleanupPolicyOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o.ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Background())
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ApplicationTypeVersionsCleanupPolicy) *ApplicationTypeVersionsCleanupPolicy {
		return &v
	}).(ApplicationTypeVersionsCleanupPolicyPtrOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyOutput) MaxUnusedVersionsToKeep() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationTypeVersionsCleanupPolicy) int { return v.MaxUnusedVersionsToKeep }).(pulumi.IntOutput)
}

type ApplicationTypeVersionsCleanupPolicyPtrOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) Elem() ApplicationTypeVersionsCleanupPolicyOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicy) ApplicationTypeVersionsCleanupPolicy {
		if v != nil {
			return *v
		}
		var ret ApplicationTypeVersionsCleanupPolicy
		return ret
	}).(ApplicationTypeVersionsCleanupPolicyOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) MaxUnusedVersionsToKeep() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxUnusedVersionsToKeep
	}).(pulumi.IntPtrOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyResponse struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep int `pulumi:"maxUnusedVersionsToKeep"`
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyResponseOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicyResponse)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) ToApplicationTypeVersionsCleanupPolicyResponseOutput() ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) ToApplicationTypeVersionsCleanupPolicyResponseOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return o
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) MaxUnusedVersionsToKeep() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationTypeVersionsCleanupPolicyResponse) int { return v.MaxUnusedVersionsToKeep }).(pulumi.IntOutput)
}

type ApplicationTypeVersionsCleanupPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicyResponse)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutput() ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) Elem() ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicyResponse) ApplicationTypeVersionsCleanupPolicyResponse {
		if v != nil {
			return *v
		}
		var ret ApplicationTypeVersionsCleanupPolicyResponse
		return ret
	}).(ApplicationTypeVersionsCleanupPolicyResponseOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) MaxUnusedVersionsToKeep() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxUnusedVersionsToKeep
	}).(pulumi.IntPtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicy struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *ApplicationHealthPolicy `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart *bool `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration *float64 `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication *bool `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy *RollingUpgradeMonitoringPolicy `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode *string `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout *float64 `pulumi:"upgradeReplicaSetCheckTimeout"`
}

// ApplicationUpgradePolicyInput is an input type that accepts ApplicationUpgradePolicyArgs and ApplicationUpgradePolicyOutput values.
// You can construct a concrete instance of `ApplicationUpgradePolicyInput` via:
//
//	ApplicationUpgradePolicyArgs{...}
type ApplicationUpgradePolicyInput interface {
	pulumi.Input

	ToApplicationUpgradePolicyOutput() ApplicationUpgradePolicyOutput
	ToApplicationUpgradePolicyOutputWithContext(context.Context) ApplicationUpgradePolicyOutput
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyArgs struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy ApplicationHealthPolicyPtrInput `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart pulumi.BoolPtrInput `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration pulumi.Float64PtrInput `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication pulumi.BoolPtrInput `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy RollingUpgradeMonitoringPolicyPtrInput `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode pulumi.StringPtrInput `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout pulumi.Float64PtrInput `pulumi:"upgradeReplicaSetCheckTimeout"`
}

func (ApplicationUpgradePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicy)(nil)).Elem()
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyOutput() ApplicationUpgradePolicyOutput {
	return i.ToApplicationUpgradePolicyOutputWithContext(context.Background())
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyOutputWithContext(ctx context.Context) ApplicationUpgradePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyOutput)
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return i.ToApplicationUpgradePolicyPtrOutputWithContext(context.Background())
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyOutput).ToApplicationUpgradePolicyPtrOutputWithContext(ctx)
}

// ApplicationUpgradePolicyPtrInput is an input type that accepts ApplicationUpgradePolicyArgs, ApplicationUpgradePolicyPtr and ApplicationUpgradePolicyPtrOutput values.
// You can construct a concrete instance of `ApplicationUpgradePolicyPtrInput` via:
//
//	        ApplicationUpgradePolicyArgs{...}
//
//	or:
//
//	        nil
type ApplicationUpgradePolicyPtrInput interface {
	pulumi.Input

	ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput
	ToApplicationUpgradePolicyPtrOutputWithContext(context.Context) ApplicationUpgradePolicyPtrOutput
}

type applicationUpgradePolicyPtrType ApplicationUpgradePolicyArgs

func ApplicationUpgradePolicyPtr(v *ApplicationUpgradePolicyArgs) ApplicationUpgradePolicyPtrInput {
	return (*applicationUpgradePolicyPtrType)(v)
}

func (*applicationUpgradePolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicy)(nil)).Elem()
}

func (i *applicationUpgradePolicyPtrType) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return i.ToApplicationUpgradePolicyPtrOutputWithContext(context.Background())
}

func (i *applicationUpgradePolicyPtrType) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyPtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicy)(nil)).Elem()
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyOutput() ApplicationUpgradePolicyOutput {
	return o
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyOutputWithContext(ctx context.Context) ApplicationUpgradePolicyOutput {
	return o
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return o.ToApplicationUpgradePolicyPtrOutputWithContext(context.Background())
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ApplicationUpgradePolicy) *ApplicationUpgradePolicy {
		return &v
	}).(ApplicationUpgradePolicyPtrOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyOutput) ApplicationHealthPolicy() ApplicationHealthPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *ApplicationHealthPolicy { return v.ApplicationHealthPolicy }).(ApplicationHealthPolicyPtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *bool { return v.ForceRestart }).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *float64 { return v.InstanceCloseDelayDuration }).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *bool { return v.RecreateApplication }).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *RollingUpgradeMonitoringPolicy {
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *string { return v.UpgradeMode }).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *float64 { return v.UpgradeReplicaSetCheckTimeout }).(pulumi.Float64PtrOutput)
}

type ApplicationUpgradePolicyPtrOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicy)(nil)).Elem()
}

func (o ApplicationUpgradePolicyPtrOutput) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return o
}

func (o ApplicationUpgradePolicyPtrOutput) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return o
}

func (o ApplicationUpgradePolicyPtrOutput) Elem() ApplicationUpgradePolicyOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) ApplicationUpgradePolicy {
		if v != nil {
			return *v
		}
		var ret ApplicationUpgradePolicy
		return ret
	}).(ApplicationUpgradePolicyOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyPtrOutput) ApplicationHealthPolicy() ApplicationHealthPolicyPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *ApplicationHealthPolicy {
		if v == nil {
			return nil
		}
		return v.ApplicationHealthPolicy
	}).(ApplicationHealthPolicyPtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyPtrOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.ForceRestart
	}).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyPtrOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.InstanceCloseDelayDuration
	}).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyPtrOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.RecreateApplication
	}).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyPtrOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *RollingUpgradeMonitoringPolicy {
		if v == nil {
			return nil
		}
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyPtrOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *string {
		if v == nil {
			return nil
		}
		return v.UpgradeMode
	}).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyPtrOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.UpgradeReplicaSetCheckTimeout
	}).(pulumi.Float64PtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyResponse struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *ApplicationHealthPolicyResponse `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart *bool `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration *float64 `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication *bool `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy *RollingUpgradeMonitoringPolicyResponse `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode *string `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout *float64 `pulumi:"upgradeReplicaSetCheckTimeout"`
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyResponseOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicyResponse)(nil)).Elem()
}

func (o ApplicationUpgradePolicyResponseOutput) ToApplicationUpgradePolicyResponseOutput() ApplicationUpgradePolicyResponseOutput {
	return o
}

func (o ApplicationUpgradePolicyResponseOutput) ToApplicationUpgradePolicyResponseOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponseOutput {
	return o
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyResponseOutput) ApplicationHealthPolicy() ApplicationHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *ApplicationHealthPolicyResponse {
		return v.ApplicationHealthPolicy
	}).(ApplicationHealthPolicyResponsePtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyResponseOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *bool { return v.ForceRestart }).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyResponseOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *float64 { return v.InstanceCloseDelayDuration }).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyResponseOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *bool { return v.RecreateApplication }).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyResponseOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *RollingUpgradeMonitoringPolicyResponse {
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyResponsePtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyResponseOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *string { return v.UpgradeMode }).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyResponseOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *float64 { return v.UpgradeReplicaSetCheckTimeout }).(pulumi.Float64PtrOutput)
}

type ApplicationUpgradePolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicyResponse)(nil)).Elem()
}

func (o ApplicationUpgradePolicyResponsePtrOutput) ToApplicationUpgradePolicyResponsePtrOutput() ApplicationUpgradePolicyResponsePtrOutput {
	return o
}

func (o ApplicationUpgradePolicyResponsePtrOutput) ToApplicationUpgradePolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponsePtrOutput {
	return o
}

func (o ApplicationUpgradePolicyResponsePtrOutput) Elem() ApplicationUpgradePolicyResponseOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) ApplicationUpgradePolicyResponse {
		if v != nil {
			return *v
		}
		var ret ApplicationUpgradePolicyResponse
		return ret
	}).(ApplicationUpgradePolicyResponseOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyResponsePtrOutput) ApplicationHealthPolicy() ApplicationHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *ApplicationHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.ApplicationHealthPolicy
	}).(ApplicationHealthPolicyResponsePtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyResponsePtrOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return v.ForceRestart
	}).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyResponsePtrOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.InstanceCloseDelayDuration
	}).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyResponsePtrOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return v.RecreateApplication
	}).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyResponsePtrOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *RollingUpgradeMonitoringPolicyResponse {
		if v == nil {
			return nil
		}
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyResponsePtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyResponsePtrOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.UpgradeMode
	}).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyResponsePtrOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.UpgradeReplicaSetCheckTimeout
	}).(pulumi.Float64PtrOutput)
}

type ApplicationUserAssignedIdentity struct {
	// The friendly name of user assigned identity.
	Name string `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

// ApplicationUserAssignedIdentityInput is an input type that accepts ApplicationUserAssignedIdentityArgs and ApplicationUserAssignedIdentityOutput values.
// You can construct a concrete instance of `ApplicationUserAssignedIdentityInput` via:
//
//	ApplicationUserAssignedIdentityArgs{...}
type ApplicationUserAssignedIdentityInput interface {
	pulumi.Input

	ToApplicationUserAssignedIdentityOutput() ApplicationUserAssignedIdentityOutput
	ToApplicationUserAssignedIdentityOutputWithContext(context.Context) ApplicationUserAssignedIdentityOutput
}

type ApplicationUserAssignedIdentityArgs struct {
	// The friendly name of user assigned identity.
	Name pulumi.StringInput `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId pulumi.StringInput `pulumi:"principalId"`
}

func (ApplicationUserAssignedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (i ApplicationUserAssignedIdentityArgs) ToApplicationUserAssignedIdentityOutput() ApplicationUserAssignedIdentityOutput {
	return i.ToApplicationUserAssignedIdentityOutputWithContext(context.Background())
}

func (i ApplicationUserAssignedIdentityArgs) ToApplicationUserAssignedIdentityOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUserAssignedIdentityOutput)
}

// ApplicationUserAssignedIdentityArrayInput is an input type that accepts ApplicationUserAssignedIdentityArray and ApplicationUserAssignedIdentityArrayOutput values.
// You can construct a concrete instance of `ApplicationUserAssignedIdentityArrayInput` via:
//
//	ApplicationUserAssignedIdentityArray{ ApplicationUserAssignedIdentityArgs{...} }
type ApplicationUserAssignedIdentityArrayInput interface {
	pulumi.Input

	ToApplicationUserAssignedIdentityArrayOutput() ApplicationUserAssignedIdentityArrayOutput
	ToApplicationUserAssignedIdentityArrayOutputWithContext(context.Context) ApplicationUserAssignedIdentityArrayOutput
}

type ApplicationUserAssignedIdentityArray []ApplicationUserAssignedIdentityInput

func (ApplicationUserAssignedIdentityArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (i ApplicationUserAssignedIdentityArray) ToApplicationUserAssignedIdentityArrayOutput() ApplicationUserAssignedIdentityArrayOutput {
	return i.ToApplicationUserAssignedIdentityArrayOutputWithContext(context.Background())
}

func (i ApplicationUserAssignedIdentityArray) ToApplicationUserAssignedIdentityArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUserAssignedIdentityArrayOutput)
}

type ApplicationUserAssignedIdentityOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityOutput) ToApplicationUserAssignedIdentityOutput() ApplicationUserAssignedIdentityOutput {
	return o
}

func (o ApplicationUserAssignedIdentityOutput) ToApplicationUserAssignedIdentityOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityOutput {
	return o
}

// The friendly name of user assigned identity.
func (o ApplicationUserAssignedIdentityOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentity) string { return v.Name }).(pulumi.StringOutput)
}

// The principal id of user assigned identity.
func (o ApplicationUserAssignedIdentityOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentity) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type ApplicationUserAssignedIdentityArrayOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityArrayOutput) ToApplicationUserAssignedIdentityArrayOutput() ApplicationUserAssignedIdentityArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityArrayOutput) ToApplicationUserAssignedIdentityArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityArrayOutput) Index(i pulumi.IntInput) ApplicationUserAssignedIdentityOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApplicationUserAssignedIdentity {
		return vs[0].([]ApplicationUserAssignedIdentity)[vs[1].(int)]
	}).(ApplicationUserAssignedIdentityOutput)
}

type ApplicationUserAssignedIdentityResponse struct {
	// The friendly name of user assigned identity.
	Name string `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

type ApplicationUserAssignedIdentityResponseOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentityResponse)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityResponseOutput) ToApplicationUserAssignedIdentityResponseOutput() ApplicationUserAssignedIdentityResponseOutput {
	return o
}

func (o ApplicationUserAssignedIdentityResponseOutput) ToApplicationUserAssignedIdentityResponseOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityResponseOutput {
	return o
}

// The friendly name of user assigned identity.
func (o ApplicationUserAssignedIdentityResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentityResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The principal id of user assigned identity.
func (o ApplicationUserAssignedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type ApplicationUserAssignedIdentityResponseArrayOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentityResponse)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityResponseArrayOutput) ToApplicationUserAssignedIdentityResponseArrayOutput() ApplicationUserAssignedIdentityResponseArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityResponseArrayOutput) ToApplicationUserAssignedIdentityResponseArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityResponseArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityResponseArrayOutput) Index(i pulumi.IntInput) ApplicationUserAssignedIdentityResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApplicationUserAssignedIdentityResponse {
		return vs[0].([]ApplicationUserAssignedIdentityResponse)[vs[1].(int)]
	}).(ApplicationUserAssignedIdentityResponseOutput)
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTrigger struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AveragePartitionLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AveragePartitionLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTrigger struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AverageServiceLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
	// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad bool `pulumi:"useOnlyPrimaryLoad"`
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AverageServiceLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
	// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad bool `pulumi:"useOnlyPrimaryLoad"`
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectory struct {
	// Azure active directory client application id.
	ClientApplication *string `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication *string `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId *string `pulumi:"tenantId"`
}

// AzureActiveDirectoryInput is an input type that accepts AzureActiveDirectoryArgs and AzureActiveDirectoryOutput values.
// You can construct a concrete instance of `AzureActiveDirectoryInput` via:
//
//	AzureActiveDirectoryArgs{...}
type AzureActiveDirectoryInput interface {
	pulumi.Input

	ToAzureActiveDirectoryOutput() AzureActiveDirectoryOutput
	ToAzureActiveDirectoryOutputWithContext(context.Context) AzureActiveDirectoryOutput
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryArgs struct {
	// Azure active directory client application id.
	ClientApplication pulumi.StringPtrInput `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication pulumi.StringPtrInput `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId pulumi.StringPtrInput `pulumi:"tenantId"`
}

func (AzureActiveDirectoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectory)(nil)).Elem()
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryOutput() AzureActiveDirectoryOutput {
	return i.ToAzureActiveDirectoryOutputWithContext(context.Background())
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryOutputWithContext(ctx context.Context) AzureActiveDirectoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryOutput)
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return i.ToAzureActiveDirectoryPtrOutputWithContext(context.Background())
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryOutput).ToAzureActiveDirectoryPtrOutputWithContext(ctx)
}

// AzureActiveDirectoryPtrInput is an input type that accepts AzureActiveDirectoryArgs, AzureActiveDirectoryPtr and AzureActiveDirectoryPtrOutput values.
// You can construct a concrete instance of `AzureActiveDirectoryPtrInput` via:
//
//	        AzureActiveDirectoryArgs{...}
//
//	or:
//
//	        nil
type AzureActiveDirectoryPtrInput interface {
	pulumi.Input

	ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput
	ToAzureActiveDirectoryPtrOutputWithContext(context.Context) AzureActiveDirectoryPtrOutput
}

type azureActiveDirectoryPtrType AzureActiveDirectoryArgs

func AzureActiveDirectoryPtr(v *AzureActiveDirectoryArgs) AzureActiveDirectoryPtrInput {
	return (*azureActiveDirectoryPtrType)(v)
}

func (*azureActiveDirectoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectory)(nil)).Elem()
}

func (i *azureActiveDirectoryPtrType) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return i.ToAzureActiveDirectoryPtrOutputWithContext(context.Background())
}

func (i *azureActiveDirectoryPtrType) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryPtrOutput)
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectory)(nil)).Elem()
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryOutput() AzureActiveDirectoryOutput {
	return o
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryOutputWithContext(ctx context.Context) AzureActiveDirectoryOutput {
	return o
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return o.ToAzureActiveDirectoryPtrOutputWithContext(context.Background())
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AzureActiveDirectory) *AzureActiveDirectory {
		return &v
	}).(AzureActiveDirectoryPtrOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *string { return v.ClientApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *string { return v.ClusterApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *string { return v.TenantId }).(pulumi.StringPtrOutput)
}

type AzureActiveDirectoryPtrOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectory)(nil)).Elem()
}

func (o AzureActiveDirectoryPtrOutput) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return o
}

func (o AzureActiveDirectoryPtrOutput) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return o
}

func (o AzureActiveDirectoryPtrOutput) Elem() AzureActiveDirectoryOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) AzureActiveDirectory {
		if v != nil {
			return *v
		}
		var ret AzureActiveDirectory
		return ret
	}).(AzureActiveDirectoryOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryPtrOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) *string {
		if v == nil {
			return nil
		}
		return v.ClientApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryPtrOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) *string {
		if v == nil {
			return nil
		}
		return v.ClusterApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryPtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) *string {
		if v == nil {
			return nil
		}
		return v.TenantId
	}).(pulumi.StringPtrOutput)
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryResponse struct {
	// Azure active directory client application id.
	ClientApplication *string `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication *string `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId *string `pulumi:"tenantId"`
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryResponseOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectoryResponse)(nil)).Elem()
}

func (o AzureActiveDirectoryResponseOutput) ToAzureActiveDirectoryResponseOutput() AzureActiveDirectoryResponseOutput {
	return o
}

func (o AzureActiveDirectoryResponseOutput) ToAzureActiveDirectoryResponseOutputWithContext(ctx context.Context) AzureActiveDirectoryResponseOutput {
	return o
}

// Azure active directory client application id.
func (o AzureActiveDirectoryResponseOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *string { return v.ClientApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryResponseOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *string { return v.ClusterApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryResponseOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *string { return v.TenantId }).(pulumi.StringPtrOutput)
}

type AzureActiveDirectoryResponsePtrOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectoryResponse)(nil)).Elem()
}

func (o AzureActiveDirectoryResponsePtrOutput) ToAzureActiveDirectoryResponsePtrOutput() AzureActiveDirectoryResponsePtrOutput {
	return o
}

func (o AzureActiveDirectoryResponsePtrOutput) ToAzureActiveDirectoryResponsePtrOutputWithContext(ctx context.Context) AzureActiveDirectoryResponsePtrOutput {
	return o
}

func (o AzureActiveDirectoryResponsePtrOutput) Elem() AzureActiveDirectoryResponseOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) AzureActiveDirectoryResponse {
		if v != nil {
			return *v
		}
		var ret AzureActiveDirectoryResponse
		return ret
	}).(AzureActiveDirectoryResponseOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryResponsePtrOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) *string {
		if v == nil {
			return nil
		}
		return v.ClientApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryResponsePtrOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) *string {
		if v == nil {
			return nil
		}
		return v.ClusterApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) *string {
		if v == nil {
			return nil
		}
		return v.TenantId
	}).(pulumi.StringPtrOutput)
}

// Client certificate definition.
type ClientCertificate struct {
	// Certificate common name.
	CommonName *string `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin bool `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint *string `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint *string `pulumi:"thumbprint"`
}

// ClientCertificateInput is an input type that accepts ClientCertificateArgs and ClientCertificateOutput values.
// You can construct a concrete instance of `ClientCertificateInput` via:
//
//	ClientCertificateArgs{...}
type ClientCertificateInput interface {
	pulumi.Input

	ToClientCertificateOutput() ClientCertificateOutput
	ToClientCertificateOutputWithContext(context.Context) ClientCertificateOutput
}

// Client certificate definition.
type ClientCertificateArgs struct {
	// Certificate common name.
	CommonName pulumi.StringPtrInput `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin pulumi.BoolInput `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint pulumi.StringPtrInput `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint pulumi.StringPtrInput `pulumi:"thumbprint"`
}

func (ClientCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificate)(nil)).Elem()
}

func (i ClientCertificateArgs) ToClientCertificateOutput() ClientCertificateOutput {
	return i.ToClientCertificateOutputWithContext(context.Background())
}

func (i ClientCertificateArgs) ToClientCertificateOutputWithContext(ctx context.Context) ClientCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientCertificateOutput)
}

// ClientCertificateArrayInput is an input type that accepts ClientCertificateArray and ClientCertificateArrayOutput values.
// You can construct a concrete instance of `ClientCertificateArrayInput` via:
//
//	ClientCertificateArray{ ClientCertificateArgs{...} }
type ClientCertificateArrayInput interface {
	pulumi.Input

	ToClientCertificateArrayOutput() ClientCertificateArrayOutput
	ToClientCertificateArrayOutputWithContext(context.Context) ClientCertificateArrayOutput
}

type ClientCertificateArray []ClientCertificateInput

func (ClientCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificate)(nil)).Elem()
}

func (i ClientCertificateArray) ToClientCertificateArrayOutput() ClientCertificateArrayOutput {
	return i.ToClientCertificateArrayOutputWithContext(context.Background())
}

func (i ClientCertificateArray) ToClientCertificateArrayOutputWithContext(ctx context.Context) ClientCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientCertificateArrayOutput)
}

// Client certificate definition.
type ClientCertificateOutput struct{ *pulumi.OutputState }

func (ClientCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificate)(nil)).Elem()
}

func (o ClientCertificateOutput) ToClientCertificateOutput() ClientCertificateOutput {
	return o
}

func (o ClientCertificateOutput) ToClientCertificateOutputWithContext(ctx context.Context) ClientCertificateOutput {
	return o
}

// Certificate common name.
func (o ClientCertificateOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificate) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
func (o ClientCertificateOutput) IsAdmin() pulumi.BoolOutput {
	return o.ApplyT(func(v ClientCertificate) bool { return v.IsAdmin }).(pulumi.BoolOutput)
}

// Issuer thumbprint for the certificate. Only used together with CommonName.
func (o ClientCertificateOutput) IssuerThumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificate) *string { return v.IssuerThumbprint }).(pulumi.StringPtrOutput)
}

// Certificate thumbprint.
func (o ClientCertificateOutput) Thumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificate) *string { return v.Thumbprint }).(pulumi.StringPtrOutput)
}

type ClientCertificateArrayOutput struct{ *pulumi.OutputState }

func (ClientCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificate)(nil)).Elem()
}

func (o ClientCertificateArrayOutput) ToClientCertificateArrayOutput() ClientCertificateArrayOutput {
	return o
}

func (o ClientCertificateArrayOutput) ToClientCertificateArrayOutputWithContext(ctx context.Context) ClientCertificateArrayOutput {
	return o
}

func (o ClientCertificateArrayOutput) Index(i pulumi.IntInput) ClientCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClientCertificate {
		return vs[0].([]ClientCertificate)[vs[1].(int)]
	}).(ClientCertificateOutput)
}

// Client certificate definition.
type ClientCertificateResponse struct {
	// Certificate common name.
	CommonName *string `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin bool `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint *string `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint *string `pulumi:"thumbprint"`
}

// Client certificate definition.
type ClientCertificateResponseOutput struct{ *pulumi.OutputState }

func (ClientCertificateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificateResponse)(nil)).Elem()
}

func (o ClientCertificateResponseOutput) ToClientCertificateResponseOutput() ClientCertificateResponseOutput {
	return o
}

func (o ClientCertificateResponseOutput) ToClientCertificateResponseOutputWithContext(ctx context.Context) ClientCertificateResponseOutput {
	return o
}

// Certificate common name.
func (o ClientCertificateResponseOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificateResponse) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
func (o ClientCertificateResponseOutput) IsAdmin() pulumi.BoolOutput {
	return o.ApplyT(func(v ClientCertificateResponse) bool { return v.IsAdmin }).(pulumi.BoolOutput)
}

// Issuer thumbprint for the certificate. Only used together with CommonName.
func (o ClientCertificateResponseOutput) IssuerThumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificateResponse) *string { return v.IssuerThumbprint }).(pulumi.StringPtrOutput)
}

// Certificate thumbprint.
func (o ClientCertificateResponseOutput) Thumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificateResponse) *string { return v.Thumbprint }).(pulumi.StringPtrOutput)
}

type ClientCertificateResponseArrayOutput struct{ *pulumi.OutputState }

func (ClientCertificateResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificateResponse)(nil)).Elem()
}

func (o ClientCertificateResponseArrayOutput) ToClientCertificateResponseArrayOutput() ClientCertificateResponseArrayOutput {
	return o
}

func (o ClientCertificateResponseArrayOutput) ToClientCertificateResponseArrayOutputWithContext(ctx context.Context) ClientCertificateResponseArrayOutput {
	return o
}

func (o ClientCertificateResponseArrayOutput) Index(i pulumi.IntInput) ClientCertificateResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClientCertificateResponse {
		return vs[0].([]ClientCertificateResponse)[vs[1].(int)]
	}).(ClientCertificateResponseOutput)
}

// Port range details
type EndpointRangeDescription struct {
	// End port of a range of ports
	EndPort int `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort int `pulumi:"startPort"`
}

// EndpointRangeDescriptionInput is an input type that accepts EndpointRangeDescriptionArgs and EndpointRangeDescriptionOutput values.
// You can construct a concrete instance of `EndpointRangeDescriptionInput` via:
//
//	EndpointRangeDescriptionArgs{...}
type EndpointRangeDescriptionInput interface {
	pulumi.Input

	ToEndpointRangeDescriptionOutput() EndpointRangeDescriptionOutput
	ToEndpointRangeDescriptionOutputWithContext(context.Context) EndpointRangeDescriptionOutput
}

// Port range details
type EndpointRangeDescriptionArgs struct {
	// End port of a range of ports
	EndPort pulumi.IntInput `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort pulumi.IntInput `pulumi:"startPort"`
}

func (EndpointRangeDescriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescription)(nil)).Elem()
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionOutput() EndpointRangeDescriptionOutput {
	return i.ToEndpointRangeDescriptionOutputWithContext(context.Background())
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionOutputWithContext(ctx context.Context) EndpointRangeDescriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionOutput)
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return i.ToEndpointRangeDescriptionPtrOutputWithContext(context.Background())
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionOutput).ToEndpointRangeDescriptionPtrOutputWithContext(ctx)
}

// EndpointRangeDescriptionPtrInput is an input type that accepts EndpointRangeDescriptionArgs, EndpointRangeDescriptionPtr and EndpointRangeDescriptionPtrOutput values.
// You can construct a concrete instance of `EndpointRangeDescriptionPtrInput` via:
//
//	        EndpointRangeDescriptionArgs{...}
//
//	or:
//
//	        nil
type EndpointRangeDescriptionPtrInput interface {
	pulumi.Input

	ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput
	ToEndpointRangeDescriptionPtrOutputWithContext(context.Context) EndpointRangeDescriptionPtrOutput
}

type endpointRangeDescriptionPtrType EndpointRangeDescriptionArgs

func EndpointRangeDescriptionPtr(v *EndpointRangeDescriptionArgs) EndpointRangeDescriptionPtrInput {
	return (*endpointRangeDescriptionPtrType)(v)
}

func (*endpointRangeDescriptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescription)(nil)).Elem()
}

func (i *endpointRangeDescriptionPtrType) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return i.ToEndpointRangeDescriptionPtrOutputWithContext(context.Background())
}

func (i *endpointRangeDescriptionPtrType) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionPtrOutput)
}

// Port range details
type EndpointRangeDescriptionOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescription)(nil)).Elem()
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionOutput() EndpointRangeDescriptionOutput {
	return o
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionOutputWithContext(ctx context.Context) EndpointRangeDescriptionOutput {
	return o
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return o.ToEndpointRangeDescriptionPtrOutputWithContext(context.Background())
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EndpointRangeDescription) *EndpointRangeDescription {
		return &v
	}).(EndpointRangeDescriptionPtrOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionOutput) EndPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescription) int { return v.EndPort }).(pulumi.IntOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionOutput) StartPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescription) int { return v.StartPort }).(pulumi.IntOutput)
}

type EndpointRangeDescriptionPtrOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescription)(nil)).Elem()
}

func (o EndpointRangeDescriptionPtrOutput) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return o
}

func (o EndpointRangeDescriptionPtrOutput) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return o
}

func (o EndpointRangeDescriptionPtrOutput) Elem() EndpointRangeDescriptionOutput {
	return o.ApplyT(func(v *EndpointRangeDescription) EndpointRangeDescription {
		if v != nil {
			return *v
		}
		var ret EndpointRangeDescription
		return ret
	}).(EndpointRangeDescriptionOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionPtrOutput) EndPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescription) *int {
		if v == nil {
			return nil
		}
		return &v.EndPort
	}).(pulumi.IntPtrOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionPtrOutput) StartPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescription) *int {
		if v == nil {
			return nil
		}
		return &v.StartPort
	}).(pulumi.IntPtrOutput)
}

// Port range details
type EndpointRangeDescriptionResponse struct {
	// End port of a range of ports
	EndPort int `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort int `pulumi:"startPort"`
}

// Port range details
type EndpointRangeDescriptionResponseOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescriptionResponse)(nil)).Elem()
}

func (o EndpointRangeDescriptionResponseOutput) ToEndpointRangeDescriptionResponseOutput() EndpointRangeDescriptionResponseOutput {
	return o
}

func (o EndpointRangeDescriptionResponseOutput) ToEndpointRangeDescriptionResponseOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponseOutput {
	return o
}

// End port of a range of ports
func (o EndpointRangeDescriptionResponseOutput) EndPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescriptionResponse) int { return v.EndPort }).(pulumi.IntOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionResponseOutput) StartPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescriptionResponse) int { return v.StartPort }).(pulumi.IntOutput)
}

type EndpointRangeDescriptionResponsePtrOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescriptionResponse)(nil)).Elem()
}

func (o EndpointRangeDescriptionResponsePtrOutput) ToEndpointRangeDescriptionResponsePtrOutput() EndpointRangeDescriptionResponsePtrOutput {
	return o
}

func (o EndpointRangeDescriptionResponsePtrOutput) ToEndpointRangeDescriptionResponsePtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponsePtrOutput {
	return o
}

func (o EndpointRangeDescriptionResponsePtrOutput) Elem() EndpointRangeDescriptionResponseOutput {
	return o.ApplyT(func(v *EndpointRangeDescriptionResponse) EndpointRangeDescriptionResponse {
		if v != nil {
			return *v
		}
		var ret EndpointRangeDescriptionResponse
		return ret
	}).(EndpointRangeDescriptionResponseOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionResponsePtrOutput) EndPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescriptionResponse) *int {
		if v == nil {
			return nil
		}
		return &v.EndPort
	}).(pulumi.IntPtrOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionResponsePtrOutput) StartPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescriptionResponse) *int {
		if v == nil {
			return nil
		}
		return &v.StartPort
	}).(pulumi.IntPtrOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfiguration struct {
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType *string `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId *string `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId *string `pulumi:"loadBalancerInboundNatPoolId"`
}

// FrontendConfigurationInput is an input type that accepts FrontendConfigurationArgs and FrontendConfigurationOutput values.
// You can construct a concrete instance of `FrontendConfigurationInput` via:
//
//	FrontendConfigurationArgs{...}
type FrontendConfigurationInput interface {
	pulumi.Input

	ToFrontendConfigurationOutput() FrontendConfigurationOutput
	ToFrontendConfigurationOutputWithContext(context.Context) FrontendConfigurationOutput
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationArgs struct {
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType pulumi.StringPtrInput `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId pulumi.StringPtrInput `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId pulumi.StringPtrInput `pulumi:"loadBalancerInboundNatPoolId"`
}

func (FrontendConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfiguration)(nil)).Elem()
}

func (i FrontendConfigurationArgs) ToFrontendConfigurationOutput() FrontendConfigurationOutput {
	return i.ToFrontendConfigurationOutputWithContext(context.Background())
}

func (i FrontendConfigurationArgs) ToFrontendConfigurationOutputWithContext(ctx context.Context) FrontendConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FrontendConfigurationOutput)
}

// FrontendConfigurationArrayInput is an input type that accepts FrontendConfigurationArray and FrontendConfigurationArrayOutput values.
// You can construct a concrete instance of `FrontendConfigurationArrayInput` via:
//
//	FrontendConfigurationArray{ FrontendConfigurationArgs{...} }
type FrontendConfigurationArrayInput interface {
	pulumi.Input

	ToFrontendConfigurationArrayOutput() FrontendConfigurationArrayOutput
	ToFrontendConfigurationArrayOutputWithContext(context.Context) FrontendConfigurationArrayOutput
}

type FrontendConfigurationArray []FrontendConfigurationInput

func (FrontendConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfiguration)(nil)).Elem()
}

func (i FrontendConfigurationArray) ToFrontendConfigurationArrayOutput() FrontendConfigurationArrayOutput {
	return i.ToFrontendConfigurationArrayOutputWithContext(context.Background())
}

func (i FrontendConfigurationArray) ToFrontendConfigurationArrayOutputWithContext(ctx context.Context) FrontendConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FrontendConfigurationArrayOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfiguration)(nil)).Elem()
}

func (o FrontendConfigurationOutput) ToFrontendConfigurationOutput() FrontendConfigurationOutput {
	return o
}

func (o FrontendConfigurationOutput) ToFrontendConfigurationOutputWithContext(ctx context.Context) FrontendConfigurationOutput {
	return o
}

// The IP address type of this frontend configuration. If omitted the default value is IPv4.
func (o FrontendConfigurationOutput) IpAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.IpAddressType }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
func (o FrontendConfigurationOutput) LoadBalancerBackendAddressPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.LoadBalancerBackendAddressPoolId }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
func (o FrontendConfigurationOutput) LoadBalancerInboundNatPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.LoadBalancerInboundNatPoolId }).(pulumi.StringPtrOutput)
}

type FrontendConfigurationArrayOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfiguration)(nil)).Elem()
}

func (o FrontendConfigurationArrayOutput) ToFrontendConfigurationArrayOutput() FrontendConfigurationArrayOutput {
	return o
}

func (o FrontendConfigurationArrayOutput) ToFrontendConfigurationArrayOutputWithContext(ctx context.Context) FrontendConfigurationArrayOutput {
	return o
}

func (o FrontendConfigurationArrayOutput) Index(i pulumi.IntInput) FrontendConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FrontendConfiguration {
		return vs[0].([]FrontendConfiguration)[vs[1].(int)]
	}).(FrontendConfigurationOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationResponse struct {
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType *string `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId *string `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId *string `pulumi:"loadBalancerInboundNatPoolId"`
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationResponseOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfigurationResponse)(nil)).Elem()
}

func (o FrontendConfigurationResponseOutput) ToFrontendConfigurationResponseOutput() FrontendConfigurationResponseOutput {
	return o
}

func (o FrontendConfigurationResponseOutput) ToFrontendConfigurationResponseOutputWithContext(ctx context.Context) FrontendConfigurationResponseOutput {
	return o
}

// The IP address type of this frontend configuration. If omitted the default value is IPv4.
func (o FrontendConfigurationResponseOutput) IpAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.IpAddressType }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
func (o FrontendConfigurationResponseOutput) LoadBalancerBackendAddressPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.LoadBalancerBackendAddressPoolId }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
func (o FrontendConfigurationResponseOutput) LoadBalancerInboundNatPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.LoadBalancerInboundNatPoolId }).(pulumi.StringPtrOutput)
}

type FrontendConfigurationResponseArrayOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfigurationResponse)(nil)).Elem()
}

func (o FrontendConfigurationResponseArrayOutput) ToFrontendConfigurationResponseArrayOutput() FrontendConfigurationResponseArrayOutput {
	return o
}

func (o FrontendConfigurationResponseArrayOutput) ToFrontendConfigurationResponseArrayOutputWithContext(ctx context.Context) FrontendConfigurationResponseArrayOutput {
	return o
}

func (o FrontendConfigurationResponseArrayOutput) Index(i pulumi.IntInput) FrontendConfigurationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FrontendConfigurationResponse {
		return vs[0].([]FrontendConfigurationResponse)[vs[1].(int)]
	}).(FrontendConfigurationResponseOutput)
}

// IPTag associated with the object.
type IPTag struct {
	// The IP tag type.
	IpTagType string `pulumi:"ipTagType"`
	// The value of the IP tag.
	Tag string `pulumi:"tag"`
}

// IPTagInput is an input type that accepts IPTagArgs and IPTagOutput values.
// You can construct a concrete instance of `IPTagInput` via:
//
//	IPTagArgs{...}
type IPTagInput interface {
	pulumi.Input

	ToIPTagOutput() IPTagOutput
	ToIPTagOutputWithContext(context.Context) IPTagOutput
}

// IPTag associated with the object.
type IPTagArgs struct {
	// The IP tag type.
	IpTagType pulumi.StringInput `pulumi:"ipTagType"`
	// The value of the IP tag.
	Tag pulumi.StringInput `pulumi:"tag"`
}

func (IPTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IPTag)(nil)).Elem()
}

func (i IPTagArgs) ToIPTagOutput() IPTagOutput {
	return i.ToIPTagOutputWithContext(context.Background())
}

func (i IPTagArgs) ToIPTagOutputWithContext(ctx context.Context) IPTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPTagOutput)
}

// IPTagArrayInput is an input type that accepts IPTagArray and IPTagArrayOutput values.
// You can construct a concrete instance of `IPTagArrayInput` via:
//
//	IPTagArray{ IPTagArgs{...} }
type IPTagArrayInput interface {
	pulumi.Input

	ToIPTagArrayOutput() IPTagArrayOutput
	ToIPTagArrayOutputWithContext(context.Context) IPTagArrayOutput
}

type IPTagArray []IPTagInput

func (IPTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPTag)(nil)).Elem()
}

func (i IPTagArray) ToIPTagArrayOutput() IPTagArrayOutput {
	return i.ToIPTagArrayOutputWithContext(context.Background())
}

func (i IPTagArray) ToIPTagArrayOutputWithContext(ctx context.Context) IPTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPTagArrayOutput)
}

// IPTag associated with the object.
type IPTagOutput struct{ *pulumi.OutputState }

func (IPTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPTag)(nil)).Elem()
}

func (o IPTagOutput) ToIPTagOutput() IPTagOutput {
	return o
}

func (o IPTagOutput) ToIPTagOutputWithContext(ctx context.Context) IPTagOutput {
	return o
}

// The IP tag type.
func (o IPTagOutput) IpTagType() pulumi.StringOutput {
	return o.ApplyT(func(v IPTag) string { return v.IpTagType }).(pulumi.StringOutput)
}

// The value of the IP tag.
func (o IPTagOutput) Tag() pulumi.StringOutput {
	return o.ApplyT(func(v IPTag) string { return v.Tag }).(pulumi.StringOutput)
}

type IPTagArrayOutput struct{ *pulumi.OutputState }

func (IPTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPTag)(nil)).Elem()
}

func (o IPTagArrayOutput) ToIPTagArrayOutput() IPTagArrayOutput {
	return o
}

func (o IPTagArrayOutput) ToIPTagArrayOutputWithContext(ctx context.Context) IPTagArrayOutput {
	return o
}

func (o IPTagArrayOutput) Index(i pulumi.IntInput) IPTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IPTag {
		return vs[0].([]IPTag)[vs[1].(int)]
	}).(IPTagOutput)
}

// IPTag associated with the object.
type IPTagResponse struct {
	// The IP tag type.
	IpTagType string `pulumi:"ipTagType"`
	// The value of the IP tag.
	Tag string `pulumi:"tag"`
}

// IPTag associated with the object.
type IPTagResponseOutput struct{ *pulumi.OutputState }

func (IPTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPTagResponse)(nil)).Elem()
}

func (o IPTagResponseOutput) ToIPTagResponseOutput() IPTagResponseOutput {
	return o
}

func (o IPTagResponseOutput) ToIPTagResponseOutputWithContext(ctx context.Context) IPTagResponseOutput {
	return o
}

// The IP tag type.
func (o IPTagResponseOutput) IpTagType() pulumi.StringOutput {
	return o.ApplyT(func(v IPTagResponse) string { return v.IpTagType }).(pulumi.StringOutput)
}

// The value of the IP tag.
func (o IPTagResponseOutput) Tag() pulumi.StringOutput {
	return o.ApplyT(func(v IPTagResponse) string { return v.Tag }).(pulumi.StringOutput)
}

type IPTagResponseArrayOutput struct{ *pulumi.OutputState }

func (IPTagResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPTagResponse)(nil)).Elem()
}

func (o IPTagResponseArrayOutput) ToIPTagResponseArrayOutput() IPTagResponseArrayOutput {
	return o
}

func (o IPTagResponseArrayOutput) ToIPTagResponseArrayOutputWithContext(ctx context.Context) IPTagResponseArrayOutput {
	return o
}

func (o IPTagResponseArrayOutput) Index(i pulumi.IntInput) IPTagResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IPTagResponse {
		return vs[0].([]IPTagResponse)[vs[1].(int)]
	}).(IPTagResponseOutput)
}

// Describes a load balancing rule.
type LoadBalancingRule struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort int `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort int `pulumi:"frontendPort"`
	// The load distribution policy for this rule.
	LoadDistribution *string `pulumi:"loadDistribution"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort *int `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol string `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath *string `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol string `pulumi:"protocol"`
}

// LoadBalancingRuleInput is an input type that accepts LoadBalancingRuleArgs and LoadBalancingRuleOutput values.
// You can construct a concrete instance of `LoadBalancingRuleInput` via:
//
//	LoadBalancingRuleArgs{...}
type LoadBalancingRuleInput interface {
	pulumi.Input

	ToLoadBalancingRuleOutput() LoadBalancingRuleOutput
	ToLoadBalancingRuleOutputWithContext(context.Context) LoadBalancingRuleOutput
}

// Describes a load balancing rule.
type LoadBalancingRuleArgs struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort pulumi.IntInput `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort pulumi.IntInput `pulumi:"frontendPort"`
	// The load distribution policy for this rule.
	LoadDistribution pulumi.StringPtrInput `pulumi:"loadDistribution"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort pulumi.IntPtrInput `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol pulumi.StringInput `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath pulumi.StringPtrInput `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol pulumi.StringInput `pulumi:"protocol"`
}

func (LoadBalancingRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRule)(nil)).Elem()
}

func (i LoadBalancingRuleArgs) ToLoadBalancingRuleOutput() LoadBalancingRuleOutput {
	return i.ToLoadBalancingRuleOutputWithContext(context.Background())
}

func (i LoadBalancingRuleArgs) ToLoadBalancingRuleOutputWithContext(ctx context.Context) LoadBalancingRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancingRuleOutput)
}

// LoadBalancingRuleArrayInput is an input type that accepts LoadBalancingRuleArray and LoadBalancingRuleArrayOutput values.
// You can construct a concrete instance of `LoadBalancingRuleArrayInput` via:
//
//	LoadBalancingRuleArray{ LoadBalancingRuleArgs{...} }
type LoadBalancingRuleArrayInput interface {
	pulumi.Input

	ToLoadBalancingRuleArrayOutput() LoadBalancingRuleArrayOutput
	ToLoadBalancingRuleArrayOutputWithContext(context.Context) LoadBalancingRuleArrayOutput
}

type LoadBalancingRuleArray []LoadBalancingRuleInput

func (LoadBalancingRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRule)(nil)).Elem()
}

func (i LoadBalancingRuleArray) ToLoadBalancingRuleArrayOutput() LoadBalancingRuleArrayOutput {
	return i.ToLoadBalancingRuleArrayOutputWithContext(context.Background())
}

func (i LoadBalancingRuleArray) ToLoadBalancingRuleArrayOutputWithContext(ctx context.Context) LoadBalancingRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancingRuleArrayOutput)
}

// Describes a load balancing rule.
type LoadBalancingRuleOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRule)(nil)).Elem()
}

func (o LoadBalancingRuleOutput) ToLoadBalancingRuleOutput() LoadBalancingRuleOutput {
	return o
}

func (o LoadBalancingRuleOutput) ToLoadBalancingRuleOutputWithContext(ctx context.Context) LoadBalancingRuleOutput {
	return o
}

// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleOutput) BackendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRule) int { return v.BackendPort }).(pulumi.IntOutput)
}

// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
func (o LoadBalancingRuleOutput) FrontendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRule) int { return v.FrontendPort }).(pulumi.IntOutput)
}

// The load distribution policy for this rule.
func (o LoadBalancingRuleOutput) LoadDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRule) *string { return v.LoadDistribution }).(pulumi.StringPtrOutput)
}

// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleOutput) ProbePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LoadBalancingRule) *int { return v.ProbePort }).(pulumi.IntPtrOutput)
}

// the reference to the load balancer probe used by the load balancing rule.
func (o LoadBalancingRuleOutput) ProbeProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRule) string { return v.ProbeProtocol }).(pulumi.StringOutput)
}

// The probe request path. Only supported for HTTP/HTTPS probes.
func (o LoadBalancingRuleOutput) ProbeRequestPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRule) *string { return v.ProbeRequestPath }).(pulumi.StringPtrOutput)
}

// The reference to the transport protocol used by the load balancing rule.
func (o LoadBalancingRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRule) string { return v.Protocol }).(pulumi.StringOutput)
}

type LoadBalancingRuleArrayOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRule)(nil)).Elem()
}

func (o LoadBalancingRuleArrayOutput) ToLoadBalancingRuleArrayOutput() LoadBalancingRuleArrayOutput {
	return o
}

func (o LoadBalancingRuleArrayOutput) ToLoadBalancingRuleArrayOutputWithContext(ctx context.Context) LoadBalancingRuleArrayOutput {
	return o
}

func (o LoadBalancingRuleArrayOutput) Index(i pulumi.IntInput) LoadBalancingRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoadBalancingRule {
		return vs[0].([]LoadBalancingRule)[vs[1].(int)]
	}).(LoadBalancingRuleOutput)
}

// Describes a load balancing rule.
type LoadBalancingRuleResponse struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort int `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort int `pulumi:"frontendPort"`
	// The load distribution policy for this rule.
	LoadDistribution *string `pulumi:"loadDistribution"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort *int `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol string `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath *string `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol string `pulumi:"protocol"`
}

// Describes a load balancing rule.
type LoadBalancingRuleResponseOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRuleResponse)(nil)).Elem()
}

func (o LoadBalancingRuleResponseOutput) ToLoadBalancingRuleResponseOutput() LoadBalancingRuleResponseOutput {
	return o
}

func (o LoadBalancingRuleResponseOutput) ToLoadBalancingRuleResponseOutputWithContext(ctx context.Context) LoadBalancingRuleResponseOutput {
	return o
}

// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleResponseOutput) BackendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) int { return v.BackendPort }).(pulumi.IntOutput)
}

// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
func (o LoadBalancingRuleResponseOutput) FrontendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) int { return v.FrontendPort }).(pulumi.IntOutput)
}

// The load distribution policy for this rule.
func (o LoadBalancingRuleResponseOutput) LoadDistribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) *string { return v.LoadDistribution }).(pulumi.StringPtrOutput)
}

// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleResponseOutput) ProbePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) *int { return v.ProbePort }).(pulumi.IntPtrOutput)
}

// the reference to the load balancer probe used by the load balancing rule.
func (o LoadBalancingRuleResponseOutput) ProbeProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) string { return v.ProbeProtocol }).(pulumi.StringOutput)
}

// The probe request path. Only supported for HTTP/HTTPS probes.
func (o LoadBalancingRuleResponseOutput) ProbeRequestPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) *string { return v.ProbeRequestPath }).(pulumi.StringPtrOutput)
}

// The reference to the transport protocol used by the load balancing rule.
func (o LoadBalancingRuleResponseOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) string { return v.Protocol }).(pulumi.StringOutput)
}

type LoadBalancingRuleResponseArrayOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRuleResponse)(nil)).Elem()
}

func (o LoadBalancingRuleResponseArrayOutput) ToLoadBalancingRuleResponseArrayOutput() LoadBalancingRuleResponseArrayOutput {
	return o
}

func (o LoadBalancingRuleResponseArrayOutput) ToLoadBalancingRuleResponseArrayOutputWithContext(ctx context.Context) LoadBalancingRuleResponseArrayOutput {
	return o
}

func (o LoadBalancingRuleResponseArrayOutput) Index(i pulumi.IntInput) LoadBalancingRuleResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoadBalancingRuleResponse {
		return vs[0].([]LoadBalancingRuleResponse)[vs[1].(int)]
	}).(LoadBalancingRuleResponseOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentity struct {
	// The type of managed identity for the resource.
	Type *ManagedIdentityType `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]interface{} `pulumi:"userAssignedIdentities"`
}

// ManagedIdentityInput is an input type that accepts ManagedIdentityArgs and ManagedIdentityOutput values.
// You can construct a concrete instance of `ManagedIdentityInput` via:
//
//	ManagedIdentityArgs{...}
type ManagedIdentityInput interface {
	pulumi.Input

	ToManagedIdentityOutput() ManagedIdentityOutput
	ToManagedIdentityOutputWithContext(context.Context) ManagedIdentityOutput
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityArgs struct {
	// The type of managed identity for the resource.
	Type ManagedIdentityTypePtrInput `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities pulumi.MapInput `pulumi:"userAssignedIdentities"`
}

func (ManagedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentity)(nil)).Elem()
}

func (i ManagedIdentityArgs) ToManagedIdentityOutput() ManagedIdentityOutput {
	return i.ToManagedIdentityOutputWithContext(context.Background())
}

func (i ManagedIdentityArgs) ToManagedIdentityOutputWithContext(ctx context.Context) ManagedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityOutput)
}

func (i ManagedIdentityArgs) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return i.ToManagedIdentityPtrOutputWithContext(context.Background())
}

func (i ManagedIdentityArgs) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityOutput).ToManagedIdentityPtrOutputWithContext(ctx)
}

// ManagedIdentityPtrInput is an input type that accepts ManagedIdentityArgs, ManagedIdentityPtr and ManagedIdentityPtrOutput values.
// You can construct a concrete instance of `ManagedIdentityPtrInput` via:
//
//	        ManagedIdentityArgs{...}
//
//	or:
//
//	        nil
type ManagedIdentityPtrInput interface {
	pulumi.Input

	ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput
	ToManagedIdentityPtrOutputWithContext(context.Context) ManagedIdentityPtrOutput
}

type managedIdentityPtrType ManagedIdentityArgs

func ManagedIdentityPtr(v *ManagedIdentityArgs) ManagedIdentityPtrInput {
	return (*managedIdentityPtrType)(v)
}

func (*managedIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentity)(nil)).Elem()
}

func (i *managedIdentityPtrType) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return i.ToManagedIdentityPtrOutputWithContext(context.Background())
}

func (i *managedIdentityPtrType) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityPtrOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityOutput struct{ *pulumi.OutputState }

func (ManagedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentity)(nil)).Elem()
}

func (o ManagedIdentityOutput) ToManagedIdentityOutput() ManagedIdentityOutput {
	return o
}

func (o ManagedIdentityOutput) ToManagedIdentityOutputWithContext(ctx context.Context) ManagedIdentityOutput {
	return o
}

func (o ManagedIdentityOutput) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return o.ToManagedIdentityPtrOutputWithContext(context.Background())
}

func (o ManagedIdentityOutput) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ManagedIdentity) *ManagedIdentity {
		return &v
	}).(ManagedIdentityPtrOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityOutput) Type() ManagedIdentityTypePtrOutput {
	return o.ApplyT(func(v ManagedIdentity) *ManagedIdentityType { return v.Type }).(ManagedIdentityTypePtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityOutput) UserAssignedIdentities() pulumi.MapOutput {
	return o.ApplyT(func(v ManagedIdentity) map[string]interface{} { return v.UserAssignedIdentities }).(pulumi.MapOutput)
}

type ManagedIdentityPtrOutput struct{ *pulumi.OutputState }

func (ManagedIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentity)(nil)).Elem()
}

func (o ManagedIdentityPtrOutput) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return o
}

func (o ManagedIdentityPtrOutput) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return o
}

func (o ManagedIdentityPtrOutput) Elem() ManagedIdentityOutput {
	return o.ApplyT(func(v *ManagedIdentity) ManagedIdentity {
		if v != nil {
			return *v
		}
		var ret ManagedIdentity
		return ret
	}).(ManagedIdentityOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityPtrOutput) Type() ManagedIdentityTypePtrOutput {
	return o.ApplyT(func(v *ManagedIdentity) *ManagedIdentityType {
		if v == nil {
			return nil
		}
		return v.Type
	}).(ManagedIdentityTypePtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityPtrOutput) UserAssignedIdentities() pulumi.MapOutput {
	return o.ApplyT(func(v *ManagedIdentity) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.MapOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityResponse struct {
	// The principal id of the managed identity. This property will only be provided for a system assigned identity.
	PrincipalId string `pulumi:"principalId"`
	// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
	TenantId string `pulumi:"tenantId"`
	// The type of managed identity for the resource.
	Type *string `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]UserAssignedIdentityResponse `pulumi:"userAssignedIdentities"`
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityResponseOutput struct{ *pulumi.OutputState }

func (ManagedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentityResponse)(nil)).Elem()
}

func (o ManagedIdentityResponseOutput) ToManagedIdentityResponseOutput() ManagedIdentityResponseOutput {
	return o
}

func (o ManagedIdentityResponseOutput) ToManagedIdentityResponseOutputWithContext(ctx context.Context) ManagedIdentityResponseOutput {
	return o
}

// The principal id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponseOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) string { return v.TenantId }).(pulumi.StringOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityResponseOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityResponseOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) map[string]UserAssignedIdentityResponse {
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

type ManagedIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (ManagedIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentityResponse)(nil)).Elem()
}

func (o ManagedIdentityResponsePtrOutput) ToManagedIdentityResponsePtrOutput() ManagedIdentityResponsePtrOutput {
	return o
}

func (o ManagedIdentityResponsePtrOutput) ToManagedIdentityResponsePtrOutputWithContext(ctx context.Context) ManagedIdentityResponsePtrOutput {
	return o
}

func (o ManagedIdentityResponsePtrOutput) Elem() ManagedIdentityResponseOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) ManagedIdentityResponse {
		if v != nil {
			return *v
		}
		var ret ManagedIdentityResponse
		return ret
	}).(ManagedIdentityResponseOutput)
}

// The principal id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponsePtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TenantId
	}).(pulumi.StringPtrOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityResponsePtrOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) map[string]UserAssignedIdentityResponse {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

// Describes the named partition scheme of the service.
type NamedPartitionScheme struct {
	// Array for the names of the partitions.
	Names []string `pulumi:"names"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Named'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeResponse struct {
	// Array for the names of the partitions.
	Names []string `pulumi:"names"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Named'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// Describes a network security rule.
type NetworkSecurityRule struct {
	// The network traffic is allowed or denied.
	Access string `pulumi:"access"`
	// Network security rule description.
	Description *string `pulumi:"description"`
	// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
	DestinationAddressPrefix *string `pulumi:"destinationAddressPrefix"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes []string `pulumi:"destinationAddressPrefixes"`
	// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	DestinationPortRange *string `pulumi:"destinationPortRange"`
	// The destination port ranges.
	DestinationPortRanges []string `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction string `pulumi:"direction"`
	// Network security rule name.
	Name string `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority int `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol string `pulumi:"protocol"`
	// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
	SourceAddressPrefix *string `pulumi:"sourceAddressPrefix"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes []string `pulumi:"sourceAddressPrefixes"`
	// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	SourcePortRange *string `pulumi:"sourcePortRange"`
	// The source port ranges.
	SourcePortRanges []string `pulumi:"sourcePortRanges"`
}

// NetworkSecurityRuleInput is an input type that accepts NetworkSecurityRuleArgs and NetworkSecurityRuleOutput values.
// You can construct a concrete instance of `NetworkSecurityRuleInput` via:
//
//	NetworkSecurityRuleArgs{...}
type NetworkSecurityRuleInput interface {
	pulumi.Input

	ToNetworkSecurityRuleOutput() NetworkSecurityRuleOutput
	ToNetworkSecurityRuleOutputWithContext(context.Context) NetworkSecurityRuleOutput
}

// Describes a network security rule.
type NetworkSecurityRuleArgs struct {
	// The network traffic is allowed or denied.
	Access pulumi.StringInput `pulumi:"access"`
	// Network security rule description.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
	DestinationAddressPrefix pulumi.StringPtrInput `pulumi:"destinationAddressPrefix"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes pulumi.StringArrayInput `pulumi:"destinationAddressPrefixes"`
	// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	DestinationPortRange pulumi.StringPtrInput `pulumi:"destinationPortRange"`
	// The destination port ranges.
	DestinationPortRanges pulumi.StringArrayInput `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction pulumi.StringInput `pulumi:"direction"`
	// Network security rule name.
	Name pulumi.StringInput `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority pulumi.IntInput `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol pulumi.StringInput `pulumi:"protocol"`
	// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
	SourceAddressPrefix pulumi.StringPtrInput `pulumi:"sourceAddressPrefix"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes pulumi.StringArrayInput `pulumi:"sourceAddressPrefixes"`
	// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	SourcePortRange pulumi.StringPtrInput `pulumi:"sourcePortRange"`
	// The source port ranges.
	SourcePortRanges pulumi.StringArrayInput `pulumi:"sourcePortRanges"`
}

func (NetworkSecurityRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRule)(nil)).Elem()
}

func (i NetworkSecurityRuleArgs) ToNetworkSecurityRuleOutput() NetworkSecurityRuleOutput {
	return i.ToNetworkSecurityRuleOutputWithContext(context.Background())
}

func (i NetworkSecurityRuleArgs) ToNetworkSecurityRuleOutputWithContext(ctx context.Context) NetworkSecurityRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkSecurityRuleOutput)
}

// NetworkSecurityRuleArrayInput is an input type that accepts NetworkSecurityRuleArray and NetworkSecurityRuleArrayOutput values.
// You can construct a concrete instance of `NetworkSecurityRuleArrayInput` via:
//
//	NetworkSecurityRuleArray{ NetworkSecurityRuleArgs{...} }
type NetworkSecurityRuleArrayInput interface {
	pulumi.Input

	ToNetworkSecurityRuleArrayOutput() NetworkSecurityRuleArrayOutput
	ToNetworkSecurityRuleArrayOutputWithContext(context.Context) NetworkSecurityRuleArrayOutput
}

type NetworkSecurityRuleArray []NetworkSecurityRuleInput

func (NetworkSecurityRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRule)(nil)).Elem()
}

func (i NetworkSecurityRuleArray) ToNetworkSecurityRuleArrayOutput() NetworkSecurityRuleArrayOutput {
	return i.ToNetworkSecurityRuleArrayOutputWithContext(context.Background())
}

func (i NetworkSecurityRuleArray) ToNetworkSecurityRuleArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkSecurityRuleArrayOutput)
}

// Describes a network security rule.
type NetworkSecurityRuleOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRule)(nil)).Elem()
}

func (o NetworkSecurityRuleOutput) ToNetworkSecurityRuleOutput() NetworkSecurityRuleOutput {
	return o
}

func (o NetworkSecurityRuleOutput) ToNetworkSecurityRuleOutputWithContext(ctx context.Context) NetworkSecurityRuleOutput {
	return o
}

// The network traffic is allowed or denied.
func (o NetworkSecurityRuleOutput) Access() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Access }).(pulumi.StringOutput)
}

// Network security rule description.
func (o NetworkSecurityRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
func (o NetworkSecurityRuleOutput) DestinationAddressPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.DestinationAddressPrefix }).(pulumi.StringPtrOutput)
}

// The destination address prefixes. CIDR or destination IP ranges.
func (o NetworkSecurityRuleOutput) DestinationAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.DestinationAddressPrefixes }).(pulumi.StringArrayOutput)
}

// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
func (o NetworkSecurityRuleOutput) DestinationPortRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.DestinationPortRange }).(pulumi.StringPtrOutput)
}

// The destination port ranges.
func (o NetworkSecurityRuleOutput) DestinationPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.DestinationPortRanges }).(pulumi.StringArrayOutput)
}

// Network security rule direction.
func (o NetworkSecurityRuleOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Direction }).(pulumi.StringOutput)
}

// Network security rule name.
func (o NetworkSecurityRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Name }).(pulumi.StringOutput)
}

// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
func (o NetworkSecurityRuleOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v NetworkSecurityRule) int { return v.Priority }).(pulumi.IntOutput)
}

// Network protocol this rule applies to.
func (o NetworkSecurityRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Protocol }).(pulumi.StringOutput)
}

// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
func (o NetworkSecurityRuleOutput) SourceAddressPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.SourceAddressPrefix }).(pulumi.StringPtrOutput)
}

// The CIDR or source IP ranges.
func (o NetworkSecurityRuleOutput) SourceAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.SourceAddressPrefixes }).(pulumi.StringArrayOutput)
}

// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
func (o NetworkSecurityRuleOutput) SourcePortRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.SourcePortRange }).(pulumi.StringPtrOutput)
}

// The source port ranges.
func (o NetworkSecurityRuleOutput) SourcePortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.SourcePortRanges }).(pulumi.StringArrayOutput)
}

type NetworkSecurityRuleArrayOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRule)(nil)).Elem()
}

func (o NetworkSecurityRuleArrayOutput) ToNetworkSecurityRuleArrayOutput() NetworkSecurityRuleArrayOutput {
	return o
}

func (o NetworkSecurityRuleArrayOutput) ToNetworkSecurityRuleArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleArrayOutput {
	return o
}

func (o NetworkSecurityRuleArrayOutput) Index(i pulumi.IntInput) NetworkSecurityRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkSecurityRule {
		return vs[0].([]NetworkSecurityRule)[vs[1].(int)]
	}).(NetworkSecurityRuleOutput)
}

// Describes a network security rule.
type NetworkSecurityRuleResponse struct {
	// The network traffic is allowed or denied.
	Access string `pulumi:"access"`
	// Network security rule description.
	Description *string `pulumi:"description"`
	// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
	DestinationAddressPrefix *string `pulumi:"destinationAddressPrefix"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes []string `pulumi:"destinationAddressPrefixes"`
	// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	DestinationPortRange *string `pulumi:"destinationPortRange"`
	// The destination port ranges.
	DestinationPortRanges []string `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction string `pulumi:"direction"`
	// Network security rule name.
	Name string `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority int `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol string `pulumi:"protocol"`
	// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
	SourceAddressPrefix *string `pulumi:"sourceAddressPrefix"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes []string `pulumi:"sourceAddressPrefixes"`
	// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	SourcePortRange *string `pulumi:"sourcePortRange"`
	// The source port ranges.
	SourcePortRanges []string `pulumi:"sourcePortRanges"`
}

// Describes a network security rule.
type NetworkSecurityRuleResponseOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRuleResponse)(nil)).Elem()
}

func (o NetworkSecurityRuleResponseOutput) ToNetworkSecurityRuleResponseOutput() NetworkSecurityRuleResponseOutput {
	return o
}

func (o NetworkSecurityRuleResponseOutput) ToNetworkSecurityRuleResponseOutputWithContext(ctx context.Context) NetworkSecurityRuleResponseOutput {
	return o
}

// The network traffic is allowed or denied.
func (o NetworkSecurityRuleResponseOutput) Access() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Access }).(pulumi.StringOutput)
}

// Network security rule description.
func (o NetworkSecurityRuleResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
func (o NetworkSecurityRuleResponseOutput) DestinationAddressPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.DestinationAddressPrefix }).(pulumi.StringPtrOutput)
}

// The destination address prefixes. CIDR or destination IP ranges.
func (o NetworkSecurityRuleResponseOutput) DestinationAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.DestinationAddressPrefixes }).(pulumi.StringArrayOutput)
}

// he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
func (o NetworkSecurityRuleResponseOutput) DestinationPortRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.DestinationPortRange }).(pulumi.StringPtrOutput)
}

// The destination port ranges.
func (o NetworkSecurityRuleResponseOutput) DestinationPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.DestinationPortRanges }).(pulumi.StringArrayOutput)
}

// Network security rule direction.
func (o NetworkSecurityRuleResponseOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Direction }).(pulumi.StringOutput)
}

// Network security rule name.
func (o NetworkSecurityRuleResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
func (o NetworkSecurityRuleResponseOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) int { return v.Priority }).(pulumi.IntOutput)
}

// Network protocol this rule applies to.
func (o NetworkSecurityRuleResponseOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Protocol }).(pulumi.StringOutput)
}

// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
func (o NetworkSecurityRuleResponseOutput) SourceAddressPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.SourceAddressPrefix }).(pulumi.StringPtrOutput)
}

// The CIDR or source IP ranges.
func (o NetworkSecurityRuleResponseOutput) SourceAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.SourceAddressPrefixes }).(pulumi.StringArrayOutput)
}

// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
func (o NetworkSecurityRuleResponseOutput) SourcePortRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.SourcePortRange }).(pulumi.StringPtrOutput)
}

// The source port ranges.
func (o NetworkSecurityRuleResponseOutput) SourcePortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.SourcePortRanges }).(pulumi.StringArrayOutput)
}

type NetworkSecurityRuleResponseArrayOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRuleResponse)(nil)).Elem()
}

func (o NetworkSecurityRuleResponseArrayOutput) ToNetworkSecurityRuleResponseArrayOutput() NetworkSecurityRuleResponseArrayOutput {
	return o
}

func (o NetworkSecurityRuleResponseArrayOutput) ToNetworkSecurityRuleResponseArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleResponseArrayOutput {
	return o
}

func (o NetworkSecurityRuleResponseArrayOutput) Index(i pulumi.IntInput) NetworkSecurityRuleResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkSecurityRuleResponse {
		return vs[0].([]NetworkSecurityRuleResponse)[vs[1].(int)]
	}).(NetworkSecurityRuleResponseOutput)
}

// Describes a node type sku.
type NodeTypeSku struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity int `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name *string `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier *string `pulumi:"tier"`
}

// NodeTypeSkuInput is an input type that accepts NodeTypeSkuArgs and NodeTypeSkuOutput values.
// You can construct a concrete instance of `NodeTypeSkuInput` via:
//
//	NodeTypeSkuArgs{...}
type NodeTypeSkuInput interface {
	pulumi.Input

	ToNodeTypeSkuOutput() NodeTypeSkuOutput
	ToNodeTypeSkuOutputWithContext(context.Context) NodeTypeSkuOutput
}

// Describes a node type sku.
type NodeTypeSkuArgs struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity pulumi.IntInput `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier pulumi.StringPtrInput `pulumi:"tier"`
}

func (NodeTypeSkuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSku)(nil)).Elem()
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuOutput() NodeTypeSkuOutput {
	return i.ToNodeTypeSkuOutputWithContext(context.Background())
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuOutputWithContext(ctx context.Context) NodeTypeSkuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuOutput)
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return i.ToNodeTypeSkuPtrOutputWithContext(context.Background())
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuOutput).ToNodeTypeSkuPtrOutputWithContext(ctx)
}

// NodeTypeSkuPtrInput is an input type that accepts NodeTypeSkuArgs, NodeTypeSkuPtr and NodeTypeSkuPtrOutput values.
// You can construct a concrete instance of `NodeTypeSkuPtrInput` via:
//
//	        NodeTypeSkuArgs{...}
//
//	or:
//
//	        nil
type NodeTypeSkuPtrInput interface {
	pulumi.Input

	ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput
	ToNodeTypeSkuPtrOutputWithContext(context.Context) NodeTypeSkuPtrOutput
}

type nodeTypeSkuPtrType NodeTypeSkuArgs

func NodeTypeSkuPtr(v *NodeTypeSkuArgs) NodeTypeSkuPtrInput {
	return (*nodeTypeSkuPtrType)(v)
}

func (*nodeTypeSkuPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSku)(nil)).Elem()
}

func (i *nodeTypeSkuPtrType) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return i.ToNodeTypeSkuPtrOutputWithContext(context.Background())
}

func (i *nodeTypeSkuPtrType) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuPtrOutput)
}

// Describes a node type sku.
type NodeTypeSkuOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSku)(nil)).Elem()
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuOutput() NodeTypeSkuOutput {
	return o
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuOutputWithContext(ctx context.Context) NodeTypeSkuOutput {
	return o
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return o.ToNodeTypeSkuPtrOutputWithContext(context.Background())
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NodeTypeSku) *NodeTypeSku {
		return &v
	}).(NodeTypeSkuPtrOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuOutput) Capacity() pulumi.IntOutput {
	return o.ApplyT(func(v NodeTypeSku) int { return v.Capacity }).(pulumi.IntOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSku) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSku) *string { return v.Tier }).(pulumi.StringPtrOutput)
}

type NodeTypeSkuPtrOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSku)(nil)).Elem()
}

func (o NodeTypeSkuPtrOutput) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return o
}

func (o NodeTypeSkuPtrOutput) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return o
}

func (o NodeTypeSkuPtrOutput) Elem() NodeTypeSkuOutput {
	return o.ApplyT(func(v *NodeTypeSku) NodeTypeSku {
		if v != nil {
			return *v
		}
		var ret NodeTypeSku
		return ret
	}).(NodeTypeSkuOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuPtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NodeTypeSku) *int {
		if v == nil {
			return nil
		}
		return &v.Capacity
	}).(pulumi.IntPtrOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSku) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuPtrOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSku) *string {
		if v == nil {
			return nil
		}
		return v.Tier
	}).(pulumi.StringPtrOutput)
}

// Describes a node type sku.
type NodeTypeSkuResponse struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity int `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name *string `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier *string `pulumi:"tier"`
}

// Describes a node type sku.
type NodeTypeSkuResponseOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSkuResponse)(nil)).Elem()
}

func (o NodeTypeSkuResponseOutput) ToNodeTypeSkuResponseOutput() NodeTypeSkuResponseOutput {
	return o
}

func (o NodeTypeSkuResponseOutput) ToNodeTypeSkuResponseOutputWithContext(ctx context.Context) NodeTypeSkuResponseOutput {
	return o
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuResponseOutput) Capacity() pulumi.IntOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) int { return v.Capacity }).(pulumi.IntOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuResponseOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) *string { return v.Tier }).(pulumi.StringPtrOutput)
}

type NodeTypeSkuResponsePtrOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSkuResponse)(nil)).Elem()
}

func (o NodeTypeSkuResponsePtrOutput) ToNodeTypeSkuResponsePtrOutput() NodeTypeSkuResponsePtrOutput {
	return o
}

func (o NodeTypeSkuResponsePtrOutput) ToNodeTypeSkuResponsePtrOutputWithContext(ctx context.Context) NodeTypeSkuResponsePtrOutput {
	return o
}

func (o NodeTypeSkuResponsePtrOutput) Elem() NodeTypeSkuResponseOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) NodeTypeSkuResponse {
		if v != nil {
			return *v
		}
		var ret NodeTypeSkuResponse
		return ret
	}).(NodeTypeSkuResponseOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuResponsePtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Capacity
	}).(pulumi.IntPtrOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuResponsePtrOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) *string {
		if v == nil {
			return nil
		}
		return v.Tier
	}).(pulumi.StringPtrOutput)
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanism struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'ScalePartitionInstanceCount'.
	Kind string `pulumi:"kind"`
	// Maximum number of instances of the partition.
	MaxInstanceCount int `pulumi:"maxInstanceCount"`
	// Minimum number of instances of the partition.
	MinInstanceCount int `pulumi:"minInstanceCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'ScalePartitionInstanceCount'.
	Kind string `pulumi:"kind"`
	// Maximum number of instances of the partition.
	MaxInstanceCount int `pulumi:"maxInstanceCount"`
	// Minimum number of instances of the partition.
	MinInstanceCount int `pulumi:"minInstanceCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicy struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction string `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout string `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration string `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration string `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout string `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout string `pulumi:"upgradeTimeout"`
}

// RollingUpgradeMonitoringPolicyInput is an input type that accepts RollingUpgradeMonitoringPolicyArgs and RollingUpgradeMonitoringPolicyOutput values.
// You can construct a concrete instance of `RollingUpgradeMonitoringPolicyInput` via:
//
//	RollingUpgradeMonitoringPolicyArgs{...}
type RollingUpgradeMonitoringPolicyInput interface {
	pulumi.Input

	ToRollingUpgradeMonitoringPolicyOutput() RollingUpgradeMonitoringPolicyOutput
	ToRollingUpgradeMonitoringPolicyOutputWithContext(context.Context) RollingUpgradeMonitoringPolicyOutput
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyArgs struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction pulumi.StringInput `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout pulumi.StringInput `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration pulumi.StringInput `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration pulumi.StringInput `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout pulumi.StringInput `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout pulumi.StringInput `pulumi:"upgradeTimeout"`
}

func (RollingUpgradeMonitoringPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyOutput() RollingUpgradeMonitoringPolicyOutput {
	return i.ToRollingUpgradeMonitoringPolicyOutputWithContext(context.Background())
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyOutput)
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return i.ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyOutput).ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx)
}

// RollingUpgradeMonitoringPolicyPtrInput is an input type that accepts RollingUpgradeMonitoringPolicyArgs, RollingUpgradeMonitoringPolicyPtr and RollingUpgradeMonitoringPolicyPtrOutput values.
// You can construct a concrete instance of `RollingUpgradeMonitoringPolicyPtrInput` via:
//
//	        RollingUpgradeMonitoringPolicyArgs{...}
//
//	or:
//
//	        nil
type RollingUpgradeMonitoringPolicyPtrInput interface {
	pulumi.Input

	ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput
	ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Context) RollingUpgradeMonitoringPolicyPtrOutput
}

type rollingUpgradeMonitoringPolicyPtrType RollingUpgradeMonitoringPolicyArgs

func RollingUpgradeMonitoringPolicyPtr(v *RollingUpgradeMonitoringPolicyArgs) RollingUpgradeMonitoringPolicyPtrInput {
	return (*rollingUpgradeMonitoringPolicyPtrType)(v)
}

func (*rollingUpgradeMonitoringPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (i *rollingUpgradeMonitoringPolicyPtrType) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return i.ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (i *rollingUpgradeMonitoringPolicyPtrType) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyOutput() RollingUpgradeMonitoringPolicyOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RollingUpgradeMonitoringPolicy) *RollingUpgradeMonitoringPolicy {
		return &v
	}).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyOutput) FailureAction() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.FailureAction }).(pulumi.StringOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) HealthCheckRetryTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.HealthCheckRetryTimeout }).(pulumi.StringOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) HealthCheckStableDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.HealthCheckStableDuration }).(pulumi.StringOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) HealthCheckWaitDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.HealthCheckWaitDuration }).(pulumi.StringOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) UpgradeDomainTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.UpgradeDomainTimeout }).(pulumi.StringOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) UpgradeTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.UpgradeTimeout }).(pulumi.StringOutput)
}

type RollingUpgradeMonitoringPolicyPtrOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyPtrOutput) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyPtrOutput) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyPtrOutput) Elem() RollingUpgradeMonitoringPolicyOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) RollingUpgradeMonitoringPolicy {
		if v != nil {
			return *v
		}
		var ret RollingUpgradeMonitoringPolicy
		return ret
	}).(RollingUpgradeMonitoringPolicyOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyPtrOutput) FailureAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.FailureAction
	}).(pulumi.StringPtrOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) HealthCheckRetryTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckRetryTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) HealthCheckStableDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckStableDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) HealthCheckWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckWaitDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) UpgradeDomainTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeDomainTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) UpgradeTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeTimeout
	}).(pulumi.StringPtrOutput)
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyResponse struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction string `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout string `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration string `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration string `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout string `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout string `pulumi:"upgradeTimeout"`
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyResponseOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicyResponse)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyResponseOutput) ToRollingUpgradeMonitoringPolicyResponseOutput() RollingUpgradeMonitoringPolicyResponseOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponseOutput) ToRollingUpgradeMonitoringPolicyResponseOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponseOutput {
	return o
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyResponseOutput) FailureAction() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.FailureAction }).(pulumi.StringOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) HealthCheckRetryTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.HealthCheckRetryTimeout }).(pulumi.StringOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) HealthCheckStableDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.HealthCheckStableDuration }).(pulumi.StringOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) HealthCheckWaitDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.HealthCheckWaitDuration }).(pulumi.StringOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) UpgradeDomainTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.UpgradeDomainTimeout }).(pulumi.StringOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) UpgradeTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.UpgradeTimeout }).(pulumi.StringOutput)
}

type RollingUpgradeMonitoringPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicyResponse)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) ToRollingUpgradeMonitoringPolicyResponsePtrOutput() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) Elem() RollingUpgradeMonitoringPolicyResponseOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) RollingUpgradeMonitoringPolicyResponse {
		if v != nil {
			return *v
		}
		var ret RollingUpgradeMonitoringPolicyResponse
		return ret
	}).(RollingUpgradeMonitoringPolicyResponseOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) FailureAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.FailureAction
	}).(pulumi.StringPtrOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) HealthCheckRetryTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckRetryTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) HealthCheckStableDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckStableDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) HealthCheckWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckWaitDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) UpgradeDomainTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeDomainTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) UpgradeTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeTimeout
	}).(pulumi.StringPtrOutput)
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicy struct {
	// Specifies the mechanism associated with this scaling policy
	ScalingMechanism interface{} `pulumi:"scalingMechanism"`
	// Specifies the trigger associated with this scaling policy.
	ScalingTrigger interface{} `pulumi:"scalingTrigger"`
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyResponse struct {
	// Specifies the mechanism associated with this scaling policy
	ScalingMechanism interface{} `pulumi:"scalingMechanism"`
	// Specifies the trigger associated with this scaling policy.
	ScalingTrigger interface{} `pulumi:"scalingTrigger"`
}

// Creates a particular correlation between services.
type ServiceCorrelation struct {
	// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme string `pulumi:"scheme"`
	// The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName string `pulumi:"serviceName"`
}

// Creates a particular correlation between services.
type ServiceCorrelationResponse struct {
	// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme string `pulumi:"scheme"`
	// The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName string `pulumi:"serviceName"`
}

// The service endpoint properties.
type ServiceEndpoint struct {
	// A list of locations.
	Locations []string `pulumi:"locations"`
	// The type of the endpoint service.
	Service string `pulumi:"service"`
}

// ServiceEndpointInput is an input type that accepts ServiceEndpointArgs and ServiceEndpointOutput values.
// You can construct a concrete instance of `ServiceEndpointInput` via:
//
//	ServiceEndpointArgs{...}
type ServiceEndpointInput interface {
	pulumi.Input

	ToServiceEndpointOutput() ServiceEndpointOutput
	ToServiceEndpointOutputWithContext(context.Context) ServiceEndpointOutput
}

// The service endpoint properties.
type ServiceEndpointArgs struct {
	// A list of locations.
	Locations pulumi.StringArrayInput `pulumi:"locations"`
	// The type of the endpoint service.
	Service pulumi.StringInput `pulumi:"service"`
}

func (ServiceEndpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceEndpoint)(nil)).Elem()
}

func (i ServiceEndpointArgs) ToServiceEndpointOutput() ServiceEndpointOutput {
	return i.ToServiceEndpointOutputWithContext(context.Background())
}

func (i ServiceEndpointArgs) ToServiceEndpointOutputWithContext(ctx context.Context) ServiceEndpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceEndpointOutput)
}

// ServiceEndpointArrayInput is an input type that accepts ServiceEndpointArray and ServiceEndpointArrayOutput values.
// You can construct a concrete instance of `ServiceEndpointArrayInput` via:
//
//	ServiceEndpointArray{ ServiceEndpointArgs{...} }
type ServiceEndpointArrayInput interface {
	pulumi.Input

	ToServiceEndpointArrayOutput() ServiceEndpointArrayOutput
	ToServiceEndpointArrayOutputWithContext(context.Context) ServiceEndpointArrayOutput
}

type ServiceEndpointArray []ServiceEndpointInput

func (ServiceEndpointArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceEndpoint)(nil)).Elem()
}

func (i ServiceEndpointArray) ToServiceEndpointArrayOutput() ServiceEndpointArrayOutput {
	return i.ToServiceEndpointArrayOutputWithContext(context.Background())
}

func (i ServiceEndpointArray) ToServiceEndpointArrayOutputWithContext(ctx context.Context) ServiceEndpointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceEndpointArrayOutput)
}

// The service endpoint properties.
type ServiceEndpointOutput struct{ *pulumi.OutputState }

func (ServiceEndpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceEndpoint)(nil)).Elem()
}

func (o ServiceEndpointOutput) ToServiceEndpointOutput() ServiceEndpointOutput {
	return o
}

func (o ServiceEndpointOutput) ToServiceEndpointOutputWithContext(ctx context.Context) ServiceEndpointOutput {
	return o
}

// A list of locations.
func (o ServiceEndpointOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServiceEndpoint) []string { return v.Locations }).(pulumi.StringArrayOutput)
}

// The type of the endpoint service.
func (o ServiceEndpointOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceEndpoint) string { return v.Service }).(pulumi.StringOutput)
}

type ServiceEndpointArrayOutput struct{ *pulumi.OutputState }

func (ServiceEndpointArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceEndpoint)(nil)).Elem()
}

func (o ServiceEndpointArrayOutput) ToServiceEndpointArrayOutput() ServiceEndpointArrayOutput {
	return o
}

func (o ServiceEndpointArrayOutput) ToServiceEndpointArrayOutputWithContext(ctx context.Context) ServiceEndpointArrayOutput {
	return o
}

func (o ServiceEndpointArrayOutput) Index(i pulumi.IntInput) ServiceEndpointOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceEndpoint {
		return vs[0].([]ServiceEndpoint)[vs[1].(int)]
	}).(ServiceEndpointOutput)
}

// The service endpoint properties.
type ServiceEndpointResponse struct {
	// A list of locations.
	Locations []string `pulumi:"locations"`
	// The type of the endpoint service.
	Service string `pulumi:"service"`
}

// The service endpoint properties.
type ServiceEndpointResponseOutput struct{ *pulumi.OutputState }

func (ServiceEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceEndpointResponse)(nil)).Elem()
}

func (o ServiceEndpointResponseOutput) ToServiceEndpointResponseOutput() ServiceEndpointResponseOutput {
	return o
}

func (o ServiceEndpointResponseOutput) ToServiceEndpointResponseOutputWithContext(ctx context.Context) ServiceEndpointResponseOutput {
	return o
}

// A list of locations.
func (o ServiceEndpointResponseOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServiceEndpointResponse) []string { return v.Locations }).(pulumi.StringArrayOutput)
}

// The type of the endpoint service.
func (o ServiceEndpointResponseOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceEndpointResponse) string { return v.Service }).(pulumi.StringOutput)
}

type ServiceEndpointResponseArrayOutput struct{ *pulumi.OutputState }

func (ServiceEndpointResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceEndpointResponse)(nil)).Elem()
}

func (o ServiceEndpointResponseArrayOutput) ToServiceEndpointResponseArrayOutput() ServiceEndpointResponseArrayOutput {
	return o
}

func (o ServiceEndpointResponseArrayOutput) ToServiceEndpointResponseArrayOutputWithContext(ctx context.Context) ServiceEndpointResponseArrayOutput {
	return o
}

func (o ServiceEndpointResponseArrayOutput) Index(i pulumi.IntInput) ServiceEndpointResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceEndpointResponse {
		return vs[0].([]ServiceEndpointResponse)[vs[1].(int)]
	}).(ServiceEndpointResponseOutput)
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetric struct {
	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad *int `pulumi:"defaultLoad"`
	// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name string `pulumi:"name"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad *int `pulumi:"primaryDefaultLoad"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad *int `pulumi:"secondaryDefaultLoad"`
	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight *string `pulumi:"weight"`
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricResponse struct {
	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad *int `pulumi:"defaultLoad"`
	// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name string `pulumi:"name"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad *int `pulumi:"primaryDefaultLoad"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad *int `pulumi:"secondaryDefaultLoad"`
	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight *string `pulumi:"weight"`
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicy struct {
	// The name of the domain that should not be used for placement.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'InvalidDomain'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyResponse struct {
	// The name of the domain that should not be used for placement.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'InvalidDomain'.
	Type string `pulumi:"type"`
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicy struct {
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'NonPartiallyPlaceService'.
	Type string `pulumi:"type"`
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyResponse struct {
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'NonPartiallyPlaceService'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicy struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'PreferredPrimaryDomain'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyResponse struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'PreferredPrimaryDomain'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicy struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomainDistribution'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyResponse struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomainDistribution'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicy struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomain'.
	Type string `pulumi:"type"`
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyResponse struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomain'.
	Type string `pulumi:"type"`
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicy struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService int `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition int `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices int `pulumi:"maxPercentUnhealthyServices"`
}

// ServiceTypeHealthPolicyInput is an input type that accepts ServiceTypeHealthPolicyArgs and ServiceTypeHealthPolicyOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyInput` via:
//
//	ServiceTypeHealthPolicyArgs{...}
type ServiceTypeHealthPolicyInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyOutput() ServiceTypeHealthPolicyOutput
	ToServiceTypeHealthPolicyOutputWithContext(context.Context) ServiceTypeHealthPolicyOutput
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyArgs struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService pulumi.IntInput `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition pulumi.IntInput `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices pulumi.IntInput `pulumi:"maxPercentUnhealthyServices"`
}

func (ServiceTypeHealthPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicy)(nil)).Elem()
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyOutput() ServiceTypeHealthPolicyOutput {
	return i.ToServiceTypeHealthPolicyOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyOutput)
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return i.ToServiceTypeHealthPolicyPtrOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyOutput).ToServiceTypeHealthPolicyPtrOutputWithContext(ctx)
}

// ServiceTypeHealthPolicyPtrInput is an input type that accepts ServiceTypeHealthPolicyArgs, ServiceTypeHealthPolicyPtr and ServiceTypeHealthPolicyPtrOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyPtrInput` via:
//
//	        ServiceTypeHealthPolicyArgs{...}
//
//	or:
//
//	        nil
type ServiceTypeHealthPolicyPtrInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput
	ToServiceTypeHealthPolicyPtrOutputWithContext(context.Context) ServiceTypeHealthPolicyPtrOutput
}

type serviceTypeHealthPolicyPtrType ServiceTypeHealthPolicyArgs

func ServiceTypeHealthPolicyPtr(v *ServiceTypeHealthPolicyArgs) ServiceTypeHealthPolicyPtrInput {
	return (*serviceTypeHealthPolicyPtrType)(v)
}

func (*serviceTypeHealthPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicy)(nil)).Elem()
}

func (i *serviceTypeHealthPolicyPtrType) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return i.ToServiceTypeHealthPolicyPtrOutputWithContext(context.Background())
}

func (i *serviceTypeHealthPolicyPtrType) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyPtrOutput)
}

// ServiceTypeHealthPolicyMapInput is an input type that accepts ServiceTypeHealthPolicyMap and ServiceTypeHealthPolicyMapOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyMapInput` via:
//
//	ServiceTypeHealthPolicyMap{ "key": ServiceTypeHealthPolicyArgs{...} }
type ServiceTypeHealthPolicyMapInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyMapOutput() ServiceTypeHealthPolicyMapOutput
	ToServiceTypeHealthPolicyMapOutputWithContext(context.Context) ServiceTypeHealthPolicyMapOutput
}

type ServiceTypeHealthPolicyMap map[string]ServiceTypeHealthPolicyInput

func (ServiceTypeHealthPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicy)(nil)).Elem()
}

func (i ServiceTypeHealthPolicyMap) ToServiceTypeHealthPolicyMapOutput() ServiceTypeHealthPolicyMapOutput {
	return i.ToServiceTypeHealthPolicyMapOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyMap) ToServiceTypeHealthPolicyMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyMapOutput)
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicy)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyOutput() ServiceTypeHealthPolicyOutput {
	return o
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyOutput {
	return o
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return o.ToServiceTypeHealthPolicyPtrOutputWithContext(context.Background())
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServiceTypeHealthPolicy) *ServiceTypeHealthPolicy {
		return &v
	}).(ServiceTypeHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) int { return v.MaxPercentUnhealthyPartitionsPerService }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) int { return v.MaxPercentUnhealthyReplicasPerPartition }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyOutput) MaxPercentUnhealthyServices() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) int { return v.MaxPercentUnhealthyServices }).(pulumi.IntOutput)
}

type ServiceTypeHealthPolicyPtrOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicy)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyPtrOutput) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyPtrOutput) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyPtrOutput) Elem() ServiceTypeHealthPolicyOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) ServiceTypeHealthPolicy {
		if v != nil {
			return *v
		}
		var ret ServiceTypeHealthPolicy
		return ret
	}).(ServiceTypeHealthPolicyOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyPtrOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyPartitionsPerService
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyPtrOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyReplicasPerPartition
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyPtrOutput) MaxPercentUnhealthyServices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyServices
	}).(pulumi.IntPtrOutput)
}

type ServiceTypeHealthPolicyMapOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicy)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyMapOutput) ToServiceTypeHealthPolicyMapOutput() ServiceTypeHealthPolicyMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyMapOutput) ToServiceTypeHealthPolicyMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyMapOutput) MapIndex(k pulumi.StringInput) ServiceTypeHealthPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ServiceTypeHealthPolicy {
		return vs[0].(map[string]ServiceTypeHealthPolicy)[vs[1].(string)]
	}).(ServiceTypeHealthPolicyOutput)
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyResponse struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService int `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition int `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices int `pulumi:"maxPercentUnhealthyServices"`
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyResponseOutput) ToServiceTypeHealthPolicyResponseOutput() ServiceTypeHealthPolicyResponseOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseOutput) ToServiceTypeHealthPolicyResponseOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponseOutput {
	return o
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyResponseOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) int { return v.MaxPercentUnhealthyPartitionsPerService }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyResponseOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) int { return v.MaxPercentUnhealthyReplicasPerPartition }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyResponseOutput) MaxPercentUnhealthyServices() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) int { return v.MaxPercentUnhealthyServices }).(pulumi.IntOutput)
}

type ServiceTypeHealthPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyResponsePtrOutput) ToServiceTypeHealthPolicyResponsePtrOutput() ServiceTypeHealthPolicyResponsePtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponsePtrOutput) ToServiceTypeHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponsePtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponsePtrOutput) Elem() ServiceTypeHealthPolicyResponseOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) ServiceTypeHealthPolicyResponse {
		if v != nil {
			return *v
		}
		var ret ServiceTypeHealthPolicyResponse
		return ret
	}).(ServiceTypeHealthPolicyResponseOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyResponsePtrOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyPartitionsPerService
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyResponsePtrOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyReplicasPerPartition
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyResponsePtrOutput) MaxPercentUnhealthyServices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyServices
	}).(pulumi.IntPtrOutput)
}

type ServiceTypeHealthPolicyResponseMapOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyResponseMapOutput) ToServiceTypeHealthPolicyResponseMapOutput() ServiceTypeHealthPolicyResponseMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseMapOutput) ToServiceTypeHealthPolicyResponseMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponseMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseMapOutput) MapIndex(k pulumi.StringInput) ServiceTypeHealthPolicyResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ServiceTypeHealthPolicyResponse {
		return vs[0].(map[string]ServiceTypeHealthPolicyResponse)[vs[1].(string)]
	}).(ServiceTypeHealthPolicyResponseOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescription struct {
	// The parameter name of fabric setting.
	Name string `pulumi:"name"`
	// The parameter value of fabric setting.
	Value string `pulumi:"value"`
}

// SettingsParameterDescriptionInput is an input type that accepts SettingsParameterDescriptionArgs and SettingsParameterDescriptionOutput values.
// You can construct a concrete instance of `SettingsParameterDescriptionInput` via:
//
//	SettingsParameterDescriptionArgs{...}
type SettingsParameterDescriptionInput interface {
	pulumi.Input

	ToSettingsParameterDescriptionOutput() SettingsParameterDescriptionOutput
	ToSettingsParameterDescriptionOutputWithContext(context.Context) SettingsParameterDescriptionOutput
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionArgs struct {
	// The parameter name of fabric setting.
	Name pulumi.StringInput `pulumi:"name"`
	// The parameter value of fabric setting.
	Value pulumi.StringInput `pulumi:"value"`
}

func (SettingsParameterDescriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescription)(nil)).Elem()
}

func (i SettingsParameterDescriptionArgs) ToSettingsParameterDescriptionOutput() SettingsParameterDescriptionOutput {
	return i.ToSettingsParameterDescriptionOutputWithContext(context.Background())
}

func (i SettingsParameterDescriptionArgs) ToSettingsParameterDescriptionOutputWithContext(ctx context.Context) SettingsParameterDescriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsParameterDescriptionOutput)
}

// SettingsParameterDescriptionArrayInput is an input type that accepts SettingsParameterDescriptionArray and SettingsParameterDescriptionArrayOutput values.
// You can construct a concrete instance of `SettingsParameterDescriptionArrayInput` via:
//
//	SettingsParameterDescriptionArray{ SettingsParameterDescriptionArgs{...} }
type SettingsParameterDescriptionArrayInput interface {
	pulumi.Input

	ToSettingsParameterDescriptionArrayOutput() SettingsParameterDescriptionArrayOutput
	ToSettingsParameterDescriptionArrayOutputWithContext(context.Context) SettingsParameterDescriptionArrayOutput
}

type SettingsParameterDescriptionArray []SettingsParameterDescriptionInput

func (SettingsParameterDescriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescription)(nil)).Elem()
}

func (i SettingsParameterDescriptionArray) ToSettingsParameterDescriptionArrayOutput() SettingsParameterDescriptionArrayOutput {
	return i.ToSettingsParameterDescriptionArrayOutputWithContext(context.Background())
}

func (i SettingsParameterDescriptionArray) ToSettingsParameterDescriptionArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsParameterDescriptionArrayOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescription)(nil)).Elem()
}

func (o SettingsParameterDescriptionOutput) ToSettingsParameterDescriptionOutput() SettingsParameterDescriptionOutput {
	return o
}

func (o SettingsParameterDescriptionOutput) ToSettingsParameterDescriptionOutputWithContext(ctx context.Context) SettingsParameterDescriptionOutput {
	return o
}

// The parameter name of fabric setting.
func (o SettingsParameterDescriptionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescription) string { return v.Name }).(pulumi.StringOutput)
}

// The parameter value of fabric setting.
func (o SettingsParameterDescriptionOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescription) string { return v.Value }).(pulumi.StringOutput)
}

type SettingsParameterDescriptionArrayOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescription)(nil)).Elem()
}

func (o SettingsParameterDescriptionArrayOutput) ToSettingsParameterDescriptionArrayOutput() SettingsParameterDescriptionArrayOutput {
	return o
}

func (o SettingsParameterDescriptionArrayOutput) ToSettingsParameterDescriptionArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionArrayOutput {
	return o
}

func (o SettingsParameterDescriptionArrayOutput) Index(i pulumi.IntInput) SettingsParameterDescriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsParameterDescription {
		return vs[0].([]SettingsParameterDescription)[vs[1].(int)]
	}).(SettingsParameterDescriptionOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionResponse struct {
	// The parameter name of fabric setting.
	Name string `pulumi:"name"`
	// The parameter value of fabric setting.
	Value string `pulumi:"value"`
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionResponseOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescriptionResponse)(nil)).Elem()
}

func (o SettingsParameterDescriptionResponseOutput) ToSettingsParameterDescriptionResponseOutput() SettingsParameterDescriptionResponseOutput {
	return o
}

func (o SettingsParameterDescriptionResponseOutput) ToSettingsParameterDescriptionResponseOutputWithContext(ctx context.Context) SettingsParameterDescriptionResponseOutput {
	return o
}

// The parameter name of fabric setting.
func (o SettingsParameterDescriptionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescriptionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The parameter value of fabric setting.
func (o SettingsParameterDescriptionResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescriptionResponse) string { return v.Value }).(pulumi.StringOutput)
}

type SettingsParameterDescriptionResponseArrayOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescriptionResponse)(nil)).Elem()
}

func (o SettingsParameterDescriptionResponseArrayOutput) ToSettingsParameterDescriptionResponseArrayOutput() SettingsParameterDescriptionResponseArrayOutput {
	return o
}

func (o SettingsParameterDescriptionResponseArrayOutput) ToSettingsParameterDescriptionResponseArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionResponseArrayOutput {
	return o
}

func (o SettingsParameterDescriptionResponseArrayOutput) Index(i pulumi.IntInput) SettingsParameterDescriptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsParameterDescriptionResponse {
		return vs[0].([]SettingsParameterDescriptionResponse)[vs[1].(int)]
	}).(SettingsParameterDescriptionResponseOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescription struct {
	// The section name of the fabric settings.
	Name string `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters []SettingsParameterDescription `pulumi:"parameters"`
}

// SettingsSectionDescriptionInput is an input type that accepts SettingsSectionDescriptionArgs and SettingsSectionDescriptionOutput values.
// You can construct a concrete instance of `SettingsSectionDescriptionInput` via:
//
//	SettingsSectionDescriptionArgs{...}
type SettingsSectionDescriptionInput interface {
	pulumi.Input

	ToSettingsSectionDescriptionOutput() SettingsSectionDescriptionOutput
	ToSettingsSectionDescriptionOutputWithContext(context.Context) SettingsSectionDescriptionOutput
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionArgs struct {
	// The section name of the fabric settings.
	Name pulumi.StringInput `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters SettingsParameterDescriptionArrayInput `pulumi:"parameters"`
}

func (SettingsSectionDescriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescription)(nil)).Elem()
}

func (i SettingsSectionDescriptionArgs) ToSettingsSectionDescriptionOutput() SettingsSectionDescriptionOutput {
	return i.ToSettingsSectionDescriptionOutputWithContext(context.Background())
}

func (i SettingsSectionDescriptionArgs) ToSettingsSectionDescriptionOutputWithContext(ctx context.Context) SettingsSectionDescriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsSectionDescriptionOutput)
}

// SettingsSectionDescriptionArrayInput is an input type that accepts SettingsSectionDescriptionArray and SettingsSectionDescriptionArrayOutput values.
// You can construct a concrete instance of `SettingsSectionDescriptionArrayInput` via:
//
//	SettingsSectionDescriptionArray{ SettingsSectionDescriptionArgs{...} }
type SettingsSectionDescriptionArrayInput interface {
	pulumi.Input

	ToSettingsSectionDescriptionArrayOutput() SettingsSectionDescriptionArrayOutput
	ToSettingsSectionDescriptionArrayOutputWithContext(context.Context) SettingsSectionDescriptionArrayOutput
}

type SettingsSectionDescriptionArray []SettingsSectionDescriptionInput

func (SettingsSectionDescriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescription)(nil)).Elem()
}

func (i SettingsSectionDescriptionArray) ToSettingsSectionDescriptionArrayOutput() SettingsSectionDescriptionArrayOutput {
	return i.ToSettingsSectionDescriptionArrayOutputWithContext(context.Background())
}

func (i SettingsSectionDescriptionArray) ToSettingsSectionDescriptionArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsSectionDescriptionArrayOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescription)(nil)).Elem()
}

func (o SettingsSectionDescriptionOutput) ToSettingsSectionDescriptionOutput() SettingsSectionDescriptionOutput {
	return o
}

func (o SettingsSectionDescriptionOutput) ToSettingsSectionDescriptionOutputWithContext(ctx context.Context) SettingsSectionDescriptionOutput {
	return o
}

// The section name of the fabric settings.
func (o SettingsSectionDescriptionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsSectionDescription) string { return v.Name }).(pulumi.StringOutput)
}

// The collection of parameters in the section.
func (o SettingsSectionDescriptionOutput) Parameters() SettingsParameterDescriptionArrayOutput {
	return o.ApplyT(func(v SettingsSectionDescription) []SettingsParameterDescription { return v.Parameters }).(SettingsParameterDescriptionArrayOutput)
}

type SettingsSectionDescriptionArrayOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescription)(nil)).Elem()
}

func (o SettingsSectionDescriptionArrayOutput) ToSettingsSectionDescriptionArrayOutput() SettingsSectionDescriptionArrayOutput {
	return o
}

func (o SettingsSectionDescriptionArrayOutput) ToSettingsSectionDescriptionArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionArrayOutput {
	return o
}

func (o SettingsSectionDescriptionArrayOutput) Index(i pulumi.IntInput) SettingsSectionDescriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsSectionDescription {
		return vs[0].([]SettingsSectionDescription)[vs[1].(int)]
	}).(SettingsSectionDescriptionOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionResponse struct {
	// The section name of the fabric settings.
	Name string `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters []SettingsParameterDescriptionResponse `pulumi:"parameters"`
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionResponseOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescriptionResponse)(nil)).Elem()
}

func (o SettingsSectionDescriptionResponseOutput) ToSettingsSectionDescriptionResponseOutput() SettingsSectionDescriptionResponseOutput {
	return o
}

func (o SettingsSectionDescriptionResponseOutput) ToSettingsSectionDescriptionResponseOutputWithContext(ctx context.Context) SettingsSectionDescriptionResponseOutput {
	return o
}

// The section name of the fabric settings.
func (o SettingsSectionDescriptionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsSectionDescriptionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The collection of parameters in the section.
func (o SettingsSectionDescriptionResponseOutput) Parameters() SettingsParameterDescriptionResponseArrayOutput {
	return o.ApplyT(func(v SettingsSectionDescriptionResponse) []SettingsParameterDescriptionResponse { return v.Parameters }).(SettingsParameterDescriptionResponseArrayOutput)
}

type SettingsSectionDescriptionResponseArrayOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescriptionResponse)(nil)).Elem()
}

func (o SettingsSectionDescriptionResponseArrayOutput) ToSettingsSectionDescriptionResponseArrayOutput() SettingsSectionDescriptionResponseArrayOutput {
	return o
}

func (o SettingsSectionDescriptionResponseArrayOutput) ToSettingsSectionDescriptionResponseArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionResponseArrayOutput {
	return o
}

func (o SettingsSectionDescriptionResponseArrayOutput) Index(i pulumi.IntInput) SettingsSectionDescriptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsSectionDescriptionResponse {
		return vs[0].([]SettingsSectionDescriptionResponse)[vs[1].(int)]
	}).(SettingsSectionDescriptionResponseOutput)
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionScheme struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Singleton'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Singleton'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// Service Fabric managed cluster Sku definition
type Sku struct {
	// Sku Name.
	Name string `pulumi:"name"`
}

// SkuInput is an input type that accepts SkuArgs and SkuOutput values.
// You can construct a concrete instance of `SkuInput` via:
//
//	SkuArgs{...}
type SkuInput interface {
	pulumi.Input

	ToSkuOutput() SkuOutput
	ToSkuOutputWithContext(context.Context) SkuOutput
}

// Service Fabric managed cluster Sku definition
type SkuArgs struct {
	// Sku Name.
	Name pulumi.StringInput `pulumi:"name"`
}

func (SkuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (i SkuArgs) ToSkuOutput() SkuOutput {
	return i.ToSkuOutputWithContext(context.Background())
}

func (i SkuArgs) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuOutput)
}

func (i SkuArgs) ToSkuPtrOutput() SkuPtrOutput {
	return i.ToSkuPtrOutputWithContext(context.Background())
}

func (i SkuArgs) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuOutput).ToSkuPtrOutputWithContext(ctx)
}

// SkuPtrInput is an input type that accepts SkuArgs, SkuPtr and SkuPtrOutput values.
// You can construct a concrete instance of `SkuPtrInput` via:
//
//	        SkuArgs{...}
//
//	or:
//
//	        nil
type SkuPtrInput interface {
	pulumi.Input

	ToSkuPtrOutput() SkuPtrOutput
	ToSkuPtrOutputWithContext(context.Context) SkuPtrOutput
}

type skuPtrType SkuArgs

func SkuPtr(v *SkuArgs) SkuPtrInput {
	return (*skuPtrType)(v)
}

func (*skuPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Sku)(nil)).Elem()
}

func (i *skuPtrType) ToSkuPtrOutput() SkuPtrOutput {
	return i.ToSkuPtrOutputWithContext(context.Background())
}

func (i *skuPtrType) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuPtrOutput)
}

// Service Fabric managed cluster Sku definition
type SkuOutput struct{ *pulumi.OutputState }

func (SkuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (o SkuOutput) ToSkuOutput() SkuOutput {
	return o
}

func (o SkuOutput) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return o
}

func (o SkuOutput) ToSkuPtrOutput() SkuPtrOutput {
	return o.ToSkuPtrOutputWithContext(context.Background())
}

func (o SkuOutput) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Sku) *Sku {
		return &v
	}).(SkuPtrOutput)
}

// Sku Name.
func (o SkuOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Sku) string { return v.Name }).(pulumi.StringOutput)
}

type SkuPtrOutput struct{ *pulumi.OutputState }

func (SkuPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Sku)(nil)).Elem()
}

func (o SkuPtrOutput) ToSkuPtrOutput() SkuPtrOutput {
	return o
}

func (o SkuPtrOutput) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return o
}

func (o SkuPtrOutput) Elem() SkuOutput {
	return o.ApplyT(func(v *Sku) Sku {
		if v != nil {
			return *v
		}
		var ret Sku
		return ret
	}).(SkuOutput)
}

// Sku Name.
func (o SkuPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Sku) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Service Fabric managed cluster Sku definition
type SkuResponse struct {
	// Sku Name.
	Name string `pulumi:"name"`
}

// Service Fabric managed cluster Sku definition
type SkuResponseOutput struct{ *pulumi.OutputState }

func (SkuResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SkuResponse)(nil)).Elem()
}

func (o SkuResponseOutput) ToSkuResponseOutput() SkuResponseOutput {
	return o
}

func (o SkuResponseOutput) ToSkuResponseOutputWithContext(ctx context.Context) SkuResponseOutput {
	return o
}

// Sku Name.
func (o SkuResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SkuResponse) string { return v.Name }).(pulumi.StringOutput)
}

type SkuResponsePtrOutput struct{ *pulumi.OutputState }

func (SkuResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SkuResponse)(nil)).Elem()
}

func (o SkuResponsePtrOutput) ToSkuResponsePtrOutput() SkuResponsePtrOutput {
	return o
}

func (o SkuResponsePtrOutput) ToSkuResponsePtrOutputWithContext(ctx context.Context) SkuResponsePtrOutput {
	return o
}

func (o SkuResponsePtrOutput) Elem() SkuResponseOutput {
	return o.ApplyT(func(v *SkuResponse) SkuResponse {
		if v != nil {
			return *v
		}
		var ret SkuResponse
		return ret
	}).(SkuResponseOutput)
}

// Sku Name.
func (o SkuResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SkuResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// The properties of a stateful service resource.
type StatefulServiceProperties struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelation `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
	HasPersistedState *bool `pulumi:"hasPersistedState"`
	// The minimum replica set size as a number.
	MinReplicaSetSize *int `pulumi:"minReplicaSetSize"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration *string `pulumi:"quorumLossWaitDuration"`
	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration *string `pulumi:"replicaRestartWaitDuration"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicy `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateful'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetric `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit *string `pulumi:"servicePlacementTimeLimit"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration *string `pulumi:"standByReplicaKeepDuration"`
	// The target replica set size as a number.
	TargetReplicaSetSize *int `pulumi:"targetReplicaSetSize"`
}

// The properties of a stateful service resource.
type StatefulServicePropertiesResponse struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelationResponse `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
	HasPersistedState *bool `pulumi:"hasPersistedState"`
	// The minimum replica set size as a number.
	MinReplicaSetSize *int `pulumi:"minReplicaSetSize"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// The current deployment or provisioning state, which only appears in the response
	ProvisioningState string `pulumi:"provisioningState"`
	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration *string `pulumi:"quorumLossWaitDuration"`
	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration *string `pulumi:"replicaRestartWaitDuration"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicyResponse `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateful'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetricResponse `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit *string `pulumi:"servicePlacementTimeLimit"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration *string `pulumi:"standByReplicaKeepDuration"`
	// The target replica set size as a number.
	TargetReplicaSetSize *int `pulumi:"targetReplicaSetSize"`
}

// The properties of a stateless service resource.
type StatelessServiceProperties struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelation `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// The instance count.
	InstanceCount int `pulumi:"instanceCount"`
	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount *int `pulumi:"minInstanceCount"`
	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage *int `pulumi:"minInstancePercentage"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicy `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateless'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetric `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
}

// The properties of a stateless service resource.
type StatelessServicePropertiesResponse struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelationResponse `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// The instance count.
	InstanceCount int `pulumi:"instanceCount"`
	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount *int `pulumi:"minInstanceCount"`
	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage *int `pulumi:"minInstancePercentage"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// The current deployment or provisioning state, which only appears in the response
	ProvisioningState string `pulumi:"provisioningState"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicyResponse `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateless'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetricResponse `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
}

// Azure resource identifier.
type SubResource struct {
	// Azure resource identifier.
	Id *string `pulumi:"id"`
}

// SubResourceInput is an input type that accepts SubResourceArgs and SubResourceOutput values.
// You can construct a concrete instance of `SubResourceInput` via:
//
//	SubResourceArgs{...}
type SubResourceInput interface {
	pulumi.Input

	ToSubResourceOutput() SubResourceOutput
	ToSubResourceOutputWithContext(context.Context) SubResourceOutput
}

// Azure resource identifier.
type SubResourceArgs struct {
	// Azure resource identifier.
	Id pulumi.StringPtrInput `pulumi:"id"`
}

func (SubResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResource)(nil)).Elem()
}

func (i SubResourceArgs) ToSubResourceOutput() SubResourceOutput {
	return i.ToSubResourceOutputWithContext(context.Background())
}

func (i SubResourceArgs) ToSubResourceOutputWithContext(ctx context.Context) SubResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubResourceOutput)
}

// Azure resource identifier.
type SubResourceOutput struct{ *pulumi.OutputState }

func (SubResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResource)(nil)).Elem()
}

func (o SubResourceOutput) ToSubResourceOutput() SubResourceOutput {
	return o
}

func (o SubResourceOutput) ToSubResourceOutputWithContext(ctx context.Context) SubResourceOutput {
	return o
}

// Azure resource identifier.
func (o SubResourceOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubResource) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Azure resource identifier.
type SubResourceResponse struct {
	// Azure resource identifier.
	Id *string `pulumi:"id"`
}

// Azure resource identifier.
type SubResourceResponseOutput struct{ *pulumi.OutputState }

func (SubResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResourceResponse)(nil)).Elem()
}

func (o SubResourceResponseOutput) ToSubResourceResponseOutput() SubResourceResponseOutput {
	return o
}

func (o SubResourceResponseOutput) ToSubResourceResponseOutputWithContext(ctx context.Context) SubResourceResponseOutput {
	return o
}

// Azure resource identifier.
func (o SubResourceResponseOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubResourceResponse) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Describes a Subnet.
type Subnet struct {
	// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
	EnableIpv6 *bool `pulumi:"enableIpv6"`
	// Subnet name.
	Name string `pulumi:"name"`
	// Full resource id for the network security group.
	NetworkSecurityGroupId *string `pulumi:"networkSecurityGroupId"`
	// Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies *string `pulumi:"privateEndpointNetworkPolicies"`
	// Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *string `pulumi:"privateLinkServiceNetworkPolicies"`
}

// SubnetInput is an input type that accepts SubnetArgs and SubnetOutput values.
// You can construct a concrete instance of `SubnetInput` via:
//
//	SubnetArgs{...}
type SubnetInput interface {
	pulumi.Input

	ToSubnetOutput() SubnetOutput
	ToSubnetOutputWithContext(context.Context) SubnetOutput
}

// Describes a Subnet.
type SubnetArgs struct {
	// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
	EnableIpv6 pulumi.BoolPtrInput `pulumi:"enableIpv6"`
	// Subnet name.
	Name pulumi.StringInput `pulumi:"name"`
	// Full resource id for the network security group.
	NetworkSecurityGroupId pulumi.StringPtrInput `pulumi:"networkSecurityGroupId"`
	// Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies pulumi.StringPtrInput `pulumi:"privateEndpointNetworkPolicies"`
	// Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies pulumi.StringPtrInput `pulumi:"privateLinkServiceNetworkPolicies"`
}

func (SubnetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Subnet)(nil)).Elem()
}

func (i SubnetArgs) ToSubnetOutput() SubnetOutput {
	return i.ToSubnetOutputWithContext(context.Background())
}

func (i SubnetArgs) ToSubnetOutputWithContext(ctx context.Context) SubnetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubnetOutput)
}

// SubnetArrayInput is an input type that accepts SubnetArray and SubnetArrayOutput values.
// You can construct a concrete instance of `SubnetArrayInput` via:
//
//	SubnetArray{ SubnetArgs{...} }
type SubnetArrayInput interface {
	pulumi.Input

	ToSubnetArrayOutput() SubnetArrayOutput
	ToSubnetArrayOutputWithContext(context.Context) SubnetArrayOutput
}

type SubnetArray []SubnetInput

func (SubnetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Subnet)(nil)).Elem()
}

func (i SubnetArray) ToSubnetArrayOutput() SubnetArrayOutput {
	return i.ToSubnetArrayOutputWithContext(context.Background())
}

func (i SubnetArray) ToSubnetArrayOutputWithContext(ctx context.Context) SubnetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubnetArrayOutput)
}

// Describes a Subnet.
type SubnetOutput struct{ *pulumi.OutputState }

func (SubnetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Subnet)(nil)).Elem()
}

func (o SubnetOutput) ToSubnetOutput() SubnetOutput {
	return o
}

func (o SubnetOutput) ToSubnetOutputWithContext(ctx context.Context) SubnetOutput {
	return o
}

// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
func (o SubnetOutput) EnableIpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Subnet) *bool { return v.EnableIpv6 }).(pulumi.BoolPtrOutput)
}

// Subnet name.
func (o SubnetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Subnet) string { return v.Name }).(pulumi.StringOutput)
}

// Full resource id for the network security group.
func (o SubnetOutput) NetworkSecurityGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Subnet) *string { return v.NetworkSecurityGroupId }).(pulumi.StringPtrOutput)
}

// Enable or Disable apply network policies on private end point in the subnet.
func (o SubnetOutput) PrivateEndpointNetworkPolicies() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Subnet) *string { return v.PrivateEndpointNetworkPolicies }).(pulumi.StringPtrOutput)
}

// Enable or Disable apply network policies on private link service in the subnet.
func (o SubnetOutput) PrivateLinkServiceNetworkPolicies() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Subnet) *string { return v.PrivateLinkServiceNetworkPolicies }).(pulumi.StringPtrOutput)
}

type SubnetArrayOutput struct{ *pulumi.OutputState }

func (SubnetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Subnet)(nil)).Elem()
}

func (o SubnetArrayOutput) ToSubnetArrayOutput() SubnetArrayOutput {
	return o
}

func (o SubnetArrayOutput) ToSubnetArrayOutputWithContext(ctx context.Context) SubnetArrayOutput {
	return o
}

func (o SubnetArrayOutput) Index(i pulumi.IntInput) SubnetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Subnet {
		return vs[0].([]Subnet)[vs[1].(int)]
	}).(SubnetOutput)
}

// Describes a Subnet.
type SubnetResponse struct {
	// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
	EnableIpv6 *bool `pulumi:"enableIpv6"`
	// Subnet name.
	Name string `pulumi:"name"`
	// Full resource id for the network security group.
	NetworkSecurityGroupId *string `pulumi:"networkSecurityGroupId"`
	// Enable or Disable apply network policies on private end point in the subnet.
	PrivateEndpointNetworkPolicies *string `pulumi:"privateEndpointNetworkPolicies"`
	// Enable or Disable apply network policies on private link service in the subnet.
	PrivateLinkServiceNetworkPolicies *string `pulumi:"privateLinkServiceNetworkPolicies"`
}

// Describes a Subnet.
type SubnetResponseOutput struct{ *pulumi.OutputState }

func (SubnetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubnetResponse)(nil)).Elem()
}

func (o SubnetResponseOutput) ToSubnetResponseOutput() SubnetResponseOutput {
	return o
}

func (o SubnetResponseOutput) ToSubnetResponseOutputWithContext(ctx context.Context) SubnetResponseOutput {
	return o
}

// Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
func (o SubnetResponseOutput) EnableIpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SubnetResponse) *bool { return v.EnableIpv6 }).(pulumi.BoolPtrOutput)
}

// Subnet name.
func (o SubnetResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SubnetResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Full resource id for the network security group.
func (o SubnetResponseOutput) NetworkSecurityGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetResponse) *string { return v.NetworkSecurityGroupId }).(pulumi.StringPtrOutput)
}

// Enable or Disable apply network policies on private end point in the subnet.
func (o SubnetResponseOutput) PrivateEndpointNetworkPolicies() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetResponse) *string { return v.PrivateEndpointNetworkPolicies }).(pulumi.StringPtrOutput)
}

// Enable or Disable apply network policies on private link service in the subnet.
func (o SubnetResponseOutput) PrivateLinkServiceNetworkPolicies() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetResponse) *string { return v.PrivateLinkServiceNetworkPolicies }).(pulumi.StringPtrOutput)
}

type SubnetResponseArrayOutput struct{ *pulumi.OutputState }

func (SubnetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubnetResponse)(nil)).Elem()
}

func (o SubnetResponseArrayOutput) ToSubnetResponseArrayOutput() SubnetResponseArrayOutput {
	return o
}

func (o SubnetResponseArrayOutput) ToSubnetResponseArrayOutputWithContext(ctx context.Context) SubnetResponseArrayOutput {
	return o
}

func (o SubnetResponseArrayOutput) Index(i pulumi.IntInput) SubnetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubnetResponse {
		return vs[0].([]SubnetResponse)[vs[1].(int)]
	}).(SubnetResponseOutput)
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponse struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *string `pulumi:"createdAt"`
	// The identity that created the resource.
	CreatedBy *string `pulumi:"createdBy"`
	// The type of identity that created the resource.
	CreatedByType *string `pulumi:"createdByType"`
	// The timestamp of resource last modification (UTC).
	LastModifiedAt *string `pulumi:"lastModifiedAt"`
	// The identity that last modified the resource.
	LastModifiedBy *string `pulumi:"lastModifiedBy"`
	// The type of identity that last modified the resource.
	LastModifiedByType *string `pulumi:"lastModifiedByType"`
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponseOutput struct{ *pulumi.OutputState }

func (SystemDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SystemDataResponse)(nil)).Elem()
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutput() SystemDataResponseOutput {
	return o
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutputWithContext(ctx context.Context) SystemDataResponseOutput {
	return o
}

// The timestamp of resource creation (UTC).
func (o SystemDataResponseOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedAt }).(pulumi.StringPtrOutput)
}

// The identity that created the resource.
func (o SystemDataResponseOutput) CreatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that created the resource.
func (o SystemDataResponseOutput) CreatedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedByType }).(pulumi.StringPtrOutput)
}

// The timestamp of resource last modification (UTC).
func (o SystemDataResponseOutput) LastModifiedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedAt }).(pulumi.StringPtrOutput)
}

// The identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedByType }).(pulumi.StringPtrOutput)
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionScheme struct {
	// The number of partitions.
	Count int `pulumi:"count"`
	// The upper bound of the partition key range that
	// should be split between the partition ‘Count’
	HighKey float64 `pulumi:"highKey"`
	// The lower bound of the partition key range that
	// should be split between the partition ‘Count’
	LowKey float64 `pulumi:"lowKey"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'UniformInt64Range'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeResponse struct {
	// The number of partitions.
	Count int `pulumi:"count"`
	// The upper bound of the partition key range that
	// should be split between the partition ‘Count’
	HighKey float64 `pulumi:"highKey"`
	// The lower bound of the partition key range that
	// should be split between the partition ‘Count’
	LowKey float64 `pulumi:"lowKey"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'UniformInt64Range'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

type UserAssignedIdentityResponse struct {
	// The client id of user assigned identity.
	ClientId string `pulumi:"clientId"`
	// The principal id of user assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

type UserAssignedIdentityResponseOutput struct{ *pulumi.OutputState }

func (UserAssignedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserAssignedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedIdentityResponseOutput) ToUserAssignedIdentityResponseOutput() UserAssignedIdentityResponseOutput {
	return o
}

func (o UserAssignedIdentityResponseOutput) ToUserAssignedIdentityResponseOutputWithContext(ctx context.Context) UserAssignedIdentityResponseOutput {
	return o
}

// The client id of user assigned identity.
func (o UserAssignedIdentityResponseOutput) ClientId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedIdentityResponse) string { return v.ClientId }).(pulumi.StringOutput)
}

// The principal id of user assigned identity.
func (o UserAssignedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type UserAssignedIdentityResponseMapOutput struct{ *pulumi.OutputState }

func (UserAssignedIdentityResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]UserAssignedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedIdentityResponseMapOutput) ToUserAssignedIdentityResponseMapOutput() UserAssignedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedIdentityResponseMapOutput) ToUserAssignedIdentityResponseMapOutputWithContext(ctx context.Context) UserAssignedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedIdentityResponseMapOutput) MapIndex(k pulumi.StringInput) UserAssignedIdentityResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) UserAssignedIdentityResponse {
		return vs[0].(map[string]UserAssignedIdentityResponse)[vs[1].(string)]
	}).(UserAssignedIdentityResponseOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtension struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion *bool `pulumi:"autoUpgradeMinorVersion"`
	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
	EnableAutomaticUpgrade *bool `pulumi:"enableAutomaticUpgrade"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name string `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings interface{} `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `pulumi:"provisionAfterExtensions"`
	// The name of the extension handler publisher.
	Publisher string `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings interface{} `pulumi:"settings"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type string `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion string `pulumi:"typeHandlerVersion"`
}

// VMSSExtensionInput is an input type that accepts VMSSExtensionArgs and VMSSExtensionOutput values.
// You can construct a concrete instance of `VMSSExtensionInput` via:
//
//	VMSSExtensionArgs{...}
type VMSSExtensionInput interface {
	pulumi.Input

	ToVMSSExtensionOutput() VMSSExtensionOutput
	ToVMSSExtensionOutputWithContext(context.Context) VMSSExtensionOutput
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionArgs struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion pulumi.BoolPtrInput `pulumi:"autoUpgradeMinorVersion"`
	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
	EnableAutomaticUpgrade pulumi.BoolPtrInput `pulumi:"enableAutomaticUpgrade"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag pulumi.StringPtrInput `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name pulumi.StringInput `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings pulumi.Input `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions pulumi.StringArrayInput `pulumi:"provisionAfterExtensions"`
	// The name of the extension handler publisher.
	Publisher pulumi.StringInput `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings pulumi.Input `pulumi:"settings"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type pulumi.StringInput `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion pulumi.StringInput `pulumi:"typeHandlerVersion"`
}

func (VMSSExtensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtension)(nil)).Elem()
}

func (i VMSSExtensionArgs) ToVMSSExtensionOutput() VMSSExtensionOutput {
	return i.ToVMSSExtensionOutputWithContext(context.Background())
}

func (i VMSSExtensionArgs) ToVMSSExtensionOutputWithContext(ctx context.Context) VMSSExtensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMSSExtensionOutput)
}

// VMSSExtensionArrayInput is an input type that accepts VMSSExtensionArray and VMSSExtensionArrayOutput values.
// You can construct a concrete instance of `VMSSExtensionArrayInput` via:
//
//	VMSSExtensionArray{ VMSSExtensionArgs{...} }
type VMSSExtensionArrayInput interface {
	pulumi.Input

	ToVMSSExtensionArrayOutput() VMSSExtensionArrayOutput
	ToVMSSExtensionArrayOutputWithContext(context.Context) VMSSExtensionArrayOutput
}

type VMSSExtensionArray []VMSSExtensionInput

func (VMSSExtensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtension)(nil)).Elem()
}

func (i VMSSExtensionArray) ToVMSSExtensionArrayOutput() VMSSExtensionArrayOutput {
	return i.ToVMSSExtensionArrayOutputWithContext(context.Background())
}

func (i VMSSExtensionArray) ToVMSSExtensionArrayOutputWithContext(ctx context.Context) VMSSExtensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMSSExtensionArrayOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionOutput struct{ *pulumi.OutputState }

func (VMSSExtensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtension)(nil)).Elem()
}

func (o VMSSExtensionOutput) ToVMSSExtensionOutput() VMSSExtensionOutput {
	return o
}

func (o VMSSExtensionOutput) ToVMSSExtensionOutputWithContext(ctx context.Context) VMSSExtensionOutput {
	return o
}

// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
func (o VMSSExtensionOutput) AutoUpgradeMinorVersion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtension) *bool { return v.AutoUpgradeMinorVersion }).(pulumi.BoolPtrOutput)
}

// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
func (o VMSSExtensionOutput) EnableAutomaticUpgrade() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtension) *bool { return v.EnableAutomaticUpgrade }).(pulumi.BoolPtrOutput)
}

// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
func (o VMSSExtensionOutput) ForceUpdateTag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMSSExtension) *string { return v.ForceUpdateTag }).(pulumi.StringPtrOutput)
}

// The name of the extension.
func (o VMSSExtensionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.Name }).(pulumi.StringOutput)
}

// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
func (o VMSSExtensionOutput) ProtectedSettings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtension) interface{} { return v.ProtectedSettings }).(pulumi.AnyOutput)
}

// Collection of extension names after which this extension needs to be provisioned.
func (o VMSSExtensionOutput) ProvisionAfterExtensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMSSExtension) []string { return v.ProvisionAfterExtensions }).(pulumi.StringArrayOutput)
}

// The name of the extension handler publisher.
func (o VMSSExtensionOutput) Publisher() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.Publisher }).(pulumi.StringOutput)
}

// Json formatted public settings for the extension.
func (o VMSSExtensionOutput) Settings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtension) interface{} { return v.Settings }).(pulumi.AnyOutput)
}

// Specifies the type of the extension; an example is "CustomScriptExtension".
func (o VMSSExtensionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.Type }).(pulumi.StringOutput)
}

// Specifies the version of the script handler.
func (o VMSSExtensionOutput) TypeHandlerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.TypeHandlerVersion }).(pulumi.StringOutput)
}

type VMSSExtensionArrayOutput struct{ *pulumi.OutputState }

func (VMSSExtensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtension)(nil)).Elem()
}

func (o VMSSExtensionArrayOutput) ToVMSSExtensionArrayOutput() VMSSExtensionArrayOutput {
	return o
}

func (o VMSSExtensionArrayOutput) ToVMSSExtensionArrayOutputWithContext(ctx context.Context) VMSSExtensionArrayOutput {
	return o
}

func (o VMSSExtensionArrayOutput) Index(i pulumi.IntInput) VMSSExtensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMSSExtension {
		return vs[0].([]VMSSExtension)[vs[1].(int)]
	}).(VMSSExtensionOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionResponse struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion *bool `pulumi:"autoUpgradeMinorVersion"`
	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
	EnableAutomaticUpgrade *bool `pulumi:"enableAutomaticUpgrade"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name string `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings interface{} `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `pulumi:"provisionAfterExtensions"`
	// The provisioning state, which only appears in the response.
	ProvisioningState string `pulumi:"provisioningState"`
	// The name of the extension handler publisher.
	Publisher string `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings interface{} `pulumi:"settings"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type string `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion string `pulumi:"typeHandlerVersion"`
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionResponseOutput struct{ *pulumi.OutputState }

func (VMSSExtensionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtensionResponse)(nil)).Elem()
}

func (o VMSSExtensionResponseOutput) ToVMSSExtensionResponseOutput() VMSSExtensionResponseOutput {
	return o
}

func (o VMSSExtensionResponseOutput) ToVMSSExtensionResponseOutputWithContext(ctx context.Context) VMSSExtensionResponseOutput {
	return o
}

// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
func (o VMSSExtensionResponseOutput) AutoUpgradeMinorVersion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) *bool { return v.AutoUpgradeMinorVersion }).(pulumi.BoolPtrOutput)
}

// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
func (o VMSSExtensionResponseOutput) EnableAutomaticUpgrade() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) *bool { return v.EnableAutomaticUpgrade }).(pulumi.BoolPtrOutput)
}

// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
func (o VMSSExtensionResponseOutput) ForceUpdateTag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) *string { return v.ForceUpdateTag }).(pulumi.StringPtrOutput)
}

// The name of the extension.
func (o VMSSExtensionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
func (o VMSSExtensionResponseOutput) ProtectedSettings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) interface{} { return v.ProtectedSettings }).(pulumi.AnyOutput)
}

// Collection of extension names after which this extension needs to be provisioned.
func (o VMSSExtensionResponseOutput) ProvisionAfterExtensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) []string { return v.ProvisionAfterExtensions }).(pulumi.StringArrayOutput)
}

// The provisioning state, which only appears in the response.
func (o VMSSExtensionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// The name of the extension handler publisher.
func (o VMSSExtensionResponseOutput) Publisher() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.Publisher }).(pulumi.StringOutput)
}

// Json formatted public settings for the extension.
func (o VMSSExtensionResponseOutput) Settings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) interface{} { return v.Settings }).(pulumi.AnyOutput)
}

// Specifies the type of the extension; an example is "CustomScriptExtension".
func (o VMSSExtensionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Specifies the version of the script handler.
func (o VMSSExtensionResponseOutput) TypeHandlerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.TypeHandlerVersion }).(pulumi.StringOutput)
}

type VMSSExtensionResponseArrayOutput struct{ *pulumi.OutputState }

func (VMSSExtensionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtensionResponse)(nil)).Elem()
}

func (o VMSSExtensionResponseArrayOutput) ToVMSSExtensionResponseArrayOutput() VMSSExtensionResponseArrayOutput {
	return o
}

func (o VMSSExtensionResponseArrayOutput) ToVMSSExtensionResponseArrayOutputWithContext(ctx context.Context) VMSSExtensionResponseArrayOutput {
	return o
}

func (o VMSSExtensionResponseArrayOutput) Index(i pulumi.IntInput) VMSSExtensionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMSSExtensionResponse {
		return vs[0].([]VMSSExtensionResponse)[vs[1].(int)]
	}).(VMSSExtensionResponseOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificate struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore string `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
	CertificateUrl string `pulumi:"certificateUrl"`
}

// VaultCertificateInput is an input type that accepts VaultCertificateArgs and VaultCertificateOutput values.
// You can construct a concrete instance of `VaultCertificateInput` via:
//
//	VaultCertificateArgs{...}
type VaultCertificateInput interface {
	pulumi.Input

	ToVaultCertificateOutput() VaultCertificateOutput
	ToVaultCertificateOutputWithContext(context.Context) VaultCertificateOutput
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateArgs struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore pulumi.StringInput `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
	CertificateUrl pulumi.StringInput `pulumi:"certificateUrl"`
}

func (VaultCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificate)(nil)).Elem()
}

func (i VaultCertificateArgs) ToVaultCertificateOutput() VaultCertificateOutput {
	return i.ToVaultCertificateOutputWithContext(context.Background())
}

func (i VaultCertificateArgs) ToVaultCertificateOutputWithContext(ctx context.Context) VaultCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultCertificateOutput)
}

// VaultCertificateArrayInput is an input type that accepts VaultCertificateArray and VaultCertificateArrayOutput values.
// You can construct a concrete instance of `VaultCertificateArrayInput` via:
//
//	VaultCertificateArray{ VaultCertificateArgs{...} }
type VaultCertificateArrayInput interface {
	pulumi.Input

	ToVaultCertificateArrayOutput() VaultCertificateArrayOutput
	ToVaultCertificateArrayOutputWithContext(context.Context) VaultCertificateArrayOutput
}

type VaultCertificateArray []VaultCertificateInput

func (VaultCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificate)(nil)).Elem()
}

func (i VaultCertificateArray) ToVaultCertificateArrayOutput() VaultCertificateArrayOutput {
	return i.ToVaultCertificateArrayOutputWithContext(context.Background())
}

func (i VaultCertificateArray) ToVaultCertificateArrayOutputWithContext(ctx context.Context) VaultCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultCertificateArrayOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateOutput struct{ *pulumi.OutputState }

func (VaultCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificate)(nil)).Elem()
}

func (o VaultCertificateOutput) ToVaultCertificateOutput() VaultCertificateOutput {
	return o
}

func (o VaultCertificateOutput) ToVaultCertificateOutputWithContext(ctx context.Context) VaultCertificateOutput {
	return o
}

// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
func (o VaultCertificateOutput) CertificateStore() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificate) string { return v.CertificateStore }).(pulumi.StringOutput)
}

// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
func (o VaultCertificateOutput) CertificateUrl() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificate) string { return v.CertificateUrl }).(pulumi.StringOutput)
}

type VaultCertificateArrayOutput struct{ *pulumi.OutputState }

func (VaultCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificate)(nil)).Elem()
}

func (o VaultCertificateArrayOutput) ToVaultCertificateArrayOutput() VaultCertificateArrayOutput {
	return o
}

func (o VaultCertificateArrayOutput) ToVaultCertificateArrayOutputWithContext(ctx context.Context) VaultCertificateArrayOutput {
	return o
}

func (o VaultCertificateArrayOutput) Index(i pulumi.IntInput) VaultCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultCertificate {
		return vs[0].([]VaultCertificate)[vs[1].(int)]
	}).(VaultCertificateOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateResponse struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore string `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
	CertificateUrl string `pulumi:"certificateUrl"`
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateResponseOutput struct{ *pulumi.OutputState }

func (VaultCertificateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificateResponse)(nil)).Elem()
}

func (o VaultCertificateResponseOutput) ToVaultCertificateResponseOutput() VaultCertificateResponseOutput {
	return o
}

func (o VaultCertificateResponseOutput) ToVaultCertificateResponseOutputWithContext(ctx context.Context) VaultCertificateResponseOutput {
	return o
}

// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
func (o VaultCertificateResponseOutput) CertificateStore() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificateResponse) string { return v.CertificateStore }).(pulumi.StringOutput)
}

// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
func (o VaultCertificateResponseOutput) CertificateUrl() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificateResponse) string { return v.CertificateUrl }).(pulumi.StringOutput)
}

type VaultCertificateResponseArrayOutput struct{ *pulumi.OutputState }

func (VaultCertificateResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificateResponse)(nil)).Elem()
}

func (o VaultCertificateResponseArrayOutput) ToVaultCertificateResponseArrayOutput() VaultCertificateResponseArrayOutput {
	return o
}

func (o VaultCertificateResponseArrayOutput) ToVaultCertificateResponseArrayOutputWithContext(ctx context.Context) VaultCertificateResponseArrayOutput {
	return o
}

func (o VaultCertificateResponseArrayOutput) Index(i pulumi.IntInput) VaultCertificateResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultCertificateResponse {
		return vs[0].([]VaultCertificateResponse)[vs[1].(int)]
	}).(VaultCertificateResponseOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroup struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResource `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []VaultCertificate `pulumi:"vaultCertificates"`
}

// VaultSecretGroupInput is an input type that accepts VaultSecretGroupArgs and VaultSecretGroupOutput values.
// You can construct a concrete instance of `VaultSecretGroupInput` via:
//
//	VaultSecretGroupArgs{...}
type VaultSecretGroupInput interface {
	pulumi.Input

	ToVaultSecretGroupOutput() VaultSecretGroupOutput
	ToVaultSecretGroupOutputWithContext(context.Context) VaultSecretGroupOutput
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupArgs struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResourceInput `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates VaultCertificateArrayInput `pulumi:"vaultCertificates"`
}

func (VaultSecretGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroup)(nil)).Elem()
}

func (i VaultSecretGroupArgs) ToVaultSecretGroupOutput() VaultSecretGroupOutput {
	return i.ToVaultSecretGroupOutputWithContext(context.Background())
}

func (i VaultSecretGroupArgs) ToVaultSecretGroupOutputWithContext(ctx context.Context) VaultSecretGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultSecretGroupOutput)
}

// VaultSecretGroupArrayInput is an input type that accepts VaultSecretGroupArray and VaultSecretGroupArrayOutput values.
// You can construct a concrete instance of `VaultSecretGroupArrayInput` via:
//
//	VaultSecretGroupArray{ VaultSecretGroupArgs{...} }
type VaultSecretGroupArrayInput interface {
	pulumi.Input

	ToVaultSecretGroupArrayOutput() VaultSecretGroupArrayOutput
	ToVaultSecretGroupArrayOutputWithContext(context.Context) VaultSecretGroupArrayOutput
}

type VaultSecretGroupArray []VaultSecretGroupInput

func (VaultSecretGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroup)(nil)).Elem()
}

func (i VaultSecretGroupArray) ToVaultSecretGroupArrayOutput() VaultSecretGroupArrayOutput {
	return i.ToVaultSecretGroupArrayOutputWithContext(context.Background())
}

func (i VaultSecretGroupArray) ToVaultSecretGroupArrayOutputWithContext(ctx context.Context) VaultSecretGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultSecretGroupArrayOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroup)(nil)).Elem()
}

func (o VaultSecretGroupOutput) ToVaultSecretGroupOutput() VaultSecretGroupOutput {
	return o
}

func (o VaultSecretGroupOutput) ToVaultSecretGroupOutputWithContext(ctx context.Context) VaultSecretGroupOutput {
	return o
}

// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
func (o VaultSecretGroupOutput) SourceVault() SubResourceOutput {
	return o.ApplyT(func(v VaultSecretGroup) SubResource { return v.SourceVault }).(SubResourceOutput)
}

// The list of key vault references in SourceVault which contain certificates.
func (o VaultSecretGroupOutput) VaultCertificates() VaultCertificateArrayOutput {
	return o.ApplyT(func(v VaultSecretGroup) []VaultCertificate { return v.VaultCertificates }).(VaultCertificateArrayOutput)
}

type VaultSecretGroupArrayOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroup)(nil)).Elem()
}

func (o VaultSecretGroupArrayOutput) ToVaultSecretGroupArrayOutput() VaultSecretGroupArrayOutput {
	return o
}

func (o VaultSecretGroupArrayOutput) ToVaultSecretGroupArrayOutputWithContext(ctx context.Context) VaultSecretGroupArrayOutput {
	return o
}

func (o VaultSecretGroupArrayOutput) Index(i pulumi.IntInput) VaultSecretGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultSecretGroup {
		return vs[0].([]VaultSecretGroup)[vs[1].(int)]
	}).(VaultSecretGroupOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupResponse struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResourceResponse `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []VaultCertificateResponse `pulumi:"vaultCertificates"`
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupResponseOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroupResponse)(nil)).Elem()
}

func (o VaultSecretGroupResponseOutput) ToVaultSecretGroupResponseOutput() VaultSecretGroupResponseOutput {
	return o
}

func (o VaultSecretGroupResponseOutput) ToVaultSecretGroupResponseOutputWithContext(ctx context.Context) VaultSecretGroupResponseOutput {
	return o
}

// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
func (o VaultSecretGroupResponseOutput) SourceVault() SubResourceResponseOutput {
	return o.ApplyT(func(v VaultSecretGroupResponse) SubResourceResponse { return v.SourceVault }).(SubResourceResponseOutput)
}

// The list of key vault references in SourceVault which contain certificates.
func (o VaultSecretGroupResponseOutput) VaultCertificates() VaultCertificateResponseArrayOutput {
	return o.ApplyT(func(v VaultSecretGroupResponse) []VaultCertificateResponse { return v.VaultCertificates }).(VaultCertificateResponseArrayOutput)
}

type VaultSecretGroupResponseArrayOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroupResponse)(nil)).Elem()
}

func (o VaultSecretGroupResponseArrayOutput) ToVaultSecretGroupResponseArrayOutput() VaultSecretGroupResponseArrayOutput {
	return o
}

func (o VaultSecretGroupResponseArrayOutput) ToVaultSecretGroupResponseArrayOutputWithContext(ctx context.Context) VaultSecretGroupResponseArrayOutput {
	return o
}

func (o VaultSecretGroupResponseArrayOutput) Index(i pulumi.IntInput) VaultSecretGroupResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultSecretGroupResponse {
		return vs[0].([]VaultSecretGroupResponse)[vs[1].(int)]
	}).(VaultSecretGroupResponseOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentity struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []string `pulumi:"userAssignedIdentities"`
}

// VmManagedIdentityInput is an input type that accepts VmManagedIdentityArgs and VmManagedIdentityOutput values.
// You can construct a concrete instance of `VmManagedIdentityInput` via:
//
//	VmManagedIdentityArgs{...}
type VmManagedIdentityInput interface {
	pulumi.Input

	ToVmManagedIdentityOutput() VmManagedIdentityOutput
	ToVmManagedIdentityOutputWithContext(context.Context) VmManagedIdentityOutput
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityArgs struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities pulumi.StringArrayInput `pulumi:"userAssignedIdentities"`
}

func (VmManagedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentity)(nil)).Elem()
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityOutput() VmManagedIdentityOutput {
	return i.ToVmManagedIdentityOutputWithContext(context.Background())
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityOutputWithContext(ctx context.Context) VmManagedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityOutput)
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return i.ToVmManagedIdentityPtrOutputWithContext(context.Background())
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityOutput).ToVmManagedIdentityPtrOutputWithContext(ctx)
}

// VmManagedIdentityPtrInput is an input type that accepts VmManagedIdentityArgs, VmManagedIdentityPtr and VmManagedIdentityPtrOutput values.
// You can construct a concrete instance of `VmManagedIdentityPtrInput` via:
//
//	        VmManagedIdentityArgs{...}
//
//	or:
//
//	        nil
type VmManagedIdentityPtrInput interface {
	pulumi.Input

	ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput
	ToVmManagedIdentityPtrOutputWithContext(context.Context) VmManagedIdentityPtrOutput
}

type vmManagedIdentityPtrType VmManagedIdentityArgs

func VmManagedIdentityPtr(v *VmManagedIdentityArgs) VmManagedIdentityPtrInput {
	return (*vmManagedIdentityPtrType)(v)
}

func (*vmManagedIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentity)(nil)).Elem()
}

func (i *vmManagedIdentityPtrType) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return i.ToVmManagedIdentityPtrOutputWithContext(context.Background())
}

func (i *vmManagedIdentityPtrType) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityPtrOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentity)(nil)).Elem()
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityOutput() VmManagedIdentityOutput {
	return o
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityOutputWithContext(ctx context.Context) VmManagedIdentityOutput {
	return o
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return o.ToVmManagedIdentityPtrOutputWithContext(context.Background())
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VmManagedIdentity) *VmManagedIdentity {
		return &v
	}).(VmManagedIdentityPtrOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmManagedIdentity) []string { return v.UserAssignedIdentities }).(pulumi.StringArrayOutput)
}

type VmManagedIdentityPtrOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentity)(nil)).Elem()
}

func (o VmManagedIdentityPtrOutput) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return o
}

func (o VmManagedIdentityPtrOutput) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return o
}

func (o VmManagedIdentityPtrOutput) Elem() VmManagedIdentityOutput {
	return o.ApplyT(func(v *VmManagedIdentity) VmManagedIdentity {
		if v != nil {
			return *v
		}
		var ret VmManagedIdentity
		return ret
	}).(VmManagedIdentityOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityPtrOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VmManagedIdentity) []string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.StringArrayOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityResponse struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []string `pulumi:"userAssignedIdentities"`
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityResponseOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentityResponse)(nil)).Elem()
}

func (o VmManagedIdentityResponseOutput) ToVmManagedIdentityResponseOutput() VmManagedIdentityResponseOutput {
	return o
}

func (o VmManagedIdentityResponseOutput) ToVmManagedIdentityResponseOutputWithContext(ctx context.Context) VmManagedIdentityResponseOutput {
	return o
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityResponseOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmManagedIdentityResponse) []string { return v.UserAssignedIdentities }).(pulumi.StringArrayOutput)
}

type VmManagedIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentityResponse)(nil)).Elem()
}

func (o VmManagedIdentityResponsePtrOutput) ToVmManagedIdentityResponsePtrOutput() VmManagedIdentityResponsePtrOutput {
	return o
}

func (o VmManagedIdentityResponsePtrOutput) ToVmManagedIdentityResponsePtrOutputWithContext(ctx context.Context) VmManagedIdentityResponsePtrOutput {
	return o
}

func (o VmManagedIdentityResponsePtrOutput) Elem() VmManagedIdentityResponseOutput {
	return o.ApplyT(func(v *VmManagedIdentityResponse) VmManagedIdentityResponse {
		if v != nil {
			return *v
		}
		var ret VmManagedIdentityResponse
		return ret
	}).(VmManagedIdentityResponseOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityResponsePtrOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VmManagedIdentityResponse) []string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.StringArrayOutput)
}

// Managed data disk description.
type VmssDataDisk struct {
	// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DiskLetter string `pulumi:"diskLetter"`
	// Disk size for each vm in the node type in GBs.
	DiskSizeGB int `pulumi:"diskSizeGB"`
	// Managed data disk type. Specifies the storage account type for the managed disk
	DiskType string `pulumi:"diskType"`
	// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
	Lun int `pulumi:"lun"`
}

// VmssDataDiskInput is an input type that accepts VmssDataDiskArgs and VmssDataDiskOutput values.
// You can construct a concrete instance of `VmssDataDiskInput` via:
//
//	VmssDataDiskArgs{...}
type VmssDataDiskInput interface {
	pulumi.Input

	ToVmssDataDiskOutput() VmssDataDiskOutput
	ToVmssDataDiskOutputWithContext(context.Context) VmssDataDiskOutput
}

// Managed data disk description.
type VmssDataDiskArgs struct {
	// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DiskLetter pulumi.StringInput `pulumi:"diskLetter"`
	// Disk size for each vm in the node type in GBs.
	DiskSizeGB pulumi.IntInput `pulumi:"diskSizeGB"`
	// Managed data disk type. Specifies the storage account type for the managed disk
	DiskType pulumi.StringInput `pulumi:"diskType"`
	// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
	Lun pulumi.IntInput `pulumi:"lun"`
}

func (VmssDataDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmssDataDisk)(nil)).Elem()
}

func (i VmssDataDiskArgs) ToVmssDataDiskOutput() VmssDataDiskOutput {
	return i.ToVmssDataDiskOutputWithContext(context.Background())
}

func (i VmssDataDiskArgs) ToVmssDataDiskOutputWithContext(ctx context.Context) VmssDataDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmssDataDiskOutput)
}

// VmssDataDiskArrayInput is an input type that accepts VmssDataDiskArray and VmssDataDiskArrayOutput values.
// You can construct a concrete instance of `VmssDataDiskArrayInput` via:
//
//	VmssDataDiskArray{ VmssDataDiskArgs{...} }
type VmssDataDiskArrayInput interface {
	pulumi.Input

	ToVmssDataDiskArrayOutput() VmssDataDiskArrayOutput
	ToVmssDataDiskArrayOutputWithContext(context.Context) VmssDataDiskArrayOutput
}

type VmssDataDiskArray []VmssDataDiskInput

func (VmssDataDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmssDataDisk)(nil)).Elem()
}

func (i VmssDataDiskArray) ToVmssDataDiskArrayOutput() VmssDataDiskArrayOutput {
	return i.ToVmssDataDiskArrayOutputWithContext(context.Background())
}

func (i VmssDataDiskArray) ToVmssDataDiskArrayOutputWithContext(ctx context.Context) VmssDataDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmssDataDiskArrayOutput)
}

// Managed data disk description.
type VmssDataDiskOutput struct{ *pulumi.OutputState }

func (VmssDataDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmssDataDisk)(nil)).Elem()
}

func (o VmssDataDiskOutput) ToVmssDataDiskOutput() VmssDataDiskOutput {
	return o
}

func (o VmssDataDiskOutput) ToVmssDataDiskOutputWithContext(ctx context.Context) VmssDataDiskOutput {
	return o
}

// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
func (o VmssDataDiskOutput) DiskLetter() pulumi.StringOutput {
	return o.ApplyT(func(v VmssDataDisk) string { return v.DiskLetter }).(pulumi.StringOutput)
}

// Disk size for each vm in the node type in GBs.
func (o VmssDataDiskOutput) DiskSizeGB() pulumi.IntOutput {
	return o.ApplyT(func(v VmssDataDisk) int { return v.DiskSizeGB }).(pulumi.IntOutput)
}

// Managed data disk type. Specifies the storage account type for the managed disk
func (o VmssDataDiskOutput) DiskType() pulumi.StringOutput {
	return o.ApplyT(func(v VmssDataDisk) string { return v.DiskType }).(pulumi.StringOutput)
}

// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
func (o VmssDataDiskOutput) Lun() pulumi.IntOutput {
	return o.ApplyT(func(v VmssDataDisk) int { return v.Lun }).(pulumi.IntOutput)
}

type VmssDataDiskArrayOutput struct{ *pulumi.OutputState }

func (VmssDataDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmssDataDisk)(nil)).Elem()
}

func (o VmssDataDiskArrayOutput) ToVmssDataDiskArrayOutput() VmssDataDiskArrayOutput {
	return o
}

func (o VmssDataDiskArrayOutput) ToVmssDataDiskArrayOutputWithContext(ctx context.Context) VmssDataDiskArrayOutput {
	return o
}

func (o VmssDataDiskArrayOutput) Index(i pulumi.IntInput) VmssDataDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmssDataDisk {
		return vs[0].([]VmssDataDisk)[vs[1].(int)]
	}).(VmssDataDiskOutput)
}

// Managed data disk description.
type VmssDataDiskResponse struct {
	// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
	DiskLetter string `pulumi:"diskLetter"`
	// Disk size for each vm in the node type in GBs.
	DiskSizeGB int `pulumi:"diskSizeGB"`
	// Managed data disk type. Specifies the storage account type for the managed disk
	DiskType string `pulumi:"diskType"`
	// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
	Lun int `pulumi:"lun"`
}

// Managed data disk description.
type VmssDataDiskResponseOutput struct{ *pulumi.OutputState }

func (VmssDataDiskResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmssDataDiskResponse)(nil)).Elem()
}

func (o VmssDataDiskResponseOutput) ToVmssDataDiskResponseOutput() VmssDataDiskResponseOutput {
	return o
}

func (o VmssDataDiskResponseOutput) ToVmssDataDiskResponseOutputWithContext(ctx context.Context) VmssDataDiskResponseOutput {
	return o
}

// Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
func (o VmssDataDiskResponseOutput) DiskLetter() pulumi.StringOutput {
	return o.ApplyT(func(v VmssDataDiskResponse) string { return v.DiskLetter }).(pulumi.StringOutput)
}

// Disk size for each vm in the node type in GBs.
func (o VmssDataDiskResponseOutput) DiskSizeGB() pulumi.IntOutput {
	return o.ApplyT(func(v VmssDataDiskResponse) int { return v.DiskSizeGB }).(pulumi.IntOutput)
}

// Managed data disk type. Specifies the storage account type for the managed disk
func (o VmssDataDiskResponseOutput) DiskType() pulumi.StringOutput {
	return o.ApplyT(func(v VmssDataDiskResponse) string { return v.DiskType }).(pulumi.StringOutput)
}

// Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
func (o VmssDataDiskResponseOutput) Lun() pulumi.IntOutput {
	return o.ApplyT(func(v VmssDataDiskResponse) int { return v.Lun }).(pulumi.IntOutput)
}

type VmssDataDiskResponseArrayOutput struct{ *pulumi.OutputState }

func (VmssDataDiskResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmssDataDiskResponse)(nil)).Elem()
}

func (o VmssDataDiskResponseArrayOutput) ToVmssDataDiskResponseArrayOutput() VmssDataDiskResponseArrayOutput {
	return o
}

func (o VmssDataDiskResponseArrayOutput) ToVmssDataDiskResponseArrayOutputWithContext(ctx context.Context) VmssDataDiskResponseArrayOutput {
	return o
}

func (o VmssDataDiskResponseArrayOutput) Index(i pulumi.IntInput) VmssDataDiskResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmssDataDiskResponse {
		return vs[0].([]VmssDataDiskResponse)[vs[1].(int)]
	}).(VmssDataDiskResponseOutput)
}

func init() {
	pulumi.RegisterOutputType(ApplicationHealthPolicyOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyPtrOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyResponseOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyPtrOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyResponseOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyPtrOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyResponseOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityArrayOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityResponseOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityResponseArrayOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryPtrOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryResponseOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryResponsePtrOutput{})
	pulumi.RegisterOutputType(ClientCertificateOutput{})
	pulumi.RegisterOutputType(ClientCertificateArrayOutput{})
	pulumi.RegisterOutputType(ClientCertificateResponseOutput{})
	pulumi.RegisterOutputType(ClientCertificateResponseArrayOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionPtrOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionResponseOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionResponsePtrOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationArrayOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationResponseOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationResponseArrayOutput{})
	pulumi.RegisterOutputType(IPTagOutput{})
	pulumi.RegisterOutputType(IPTagArrayOutput{})
	pulumi.RegisterOutputType(IPTagResponseOutput{})
	pulumi.RegisterOutputType(IPTagResponseArrayOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleArrayOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleResponseOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleResponseArrayOutput{})
	pulumi.RegisterOutputType(ManagedIdentityOutput{})
	pulumi.RegisterOutputType(ManagedIdentityPtrOutput{})
	pulumi.RegisterOutputType(ManagedIdentityResponseOutput{})
	pulumi.RegisterOutputType(ManagedIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleArrayOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleResponseOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleResponseArrayOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuPtrOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuResponseOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuResponsePtrOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyPtrOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyResponseOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ServiceEndpointOutput{})
	pulumi.RegisterOutputType(ServiceEndpointArrayOutput{})
	pulumi.RegisterOutputType(ServiceEndpointResponseOutput{})
	pulumi.RegisterOutputType(ServiceEndpointResponseArrayOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyPtrOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyMapOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyResponseMapOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionArrayOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionResponseOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionResponseArrayOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionArrayOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionResponseOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionResponseArrayOutput{})
	pulumi.RegisterOutputType(SkuOutput{})
	pulumi.RegisterOutputType(SkuPtrOutput{})
	pulumi.RegisterOutputType(SkuResponseOutput{})
	pulumi.RegisterOutputType(SkuResponsePtrOutput{})
	pulumi.RegisterOutputType(SubResourceOutput{})
	pulumi.RegisterOutputType(SubResourceResponseOutput{})
	pulumi.RegisterOutputType(SubnetOutput{})
	pulumi.RegisterOutputType(SubnetArrayOutput{})
	pulumi.RegisterOutputType(SubnetResponseOutput{})
	pulumi.RegisterOutputType(SubnetResponseArrayOutput{})
	pulumi.RegisterOutputType(SystemDataResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedIdentityResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedIdentityResponseMapOutput{})
	pulumi.RegisterOutputType(VMSSExtensionOutput{})
	pulumi.RegisterOutputType(VMSSExtensionArrayOutput{})
	pulumi.RegisterOutputType(VMSSExtensionResponseOutput{})
	pulumi.RegisterOutputType(VMSSExtensionResponseArrayOutput{})
	pulumi.RegisterOutputType(VaultCertificateOutput{})
	pulumi.RegisterOutputType(VaultCertificateArrayOutput{})
	pulumi.RegisterOutputType(VaultCertificateResponseOutput{})
	pulumi.RegisterOutputType(VaultCertificateResponseArrayOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupArrayOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupResponseOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupResponseArrayOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityPtrOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityResponseOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(VmssDataDiskOutput{})
	pulumi.RegisterOutputType(VmssDataDiskArrayOutput{})
	pulumi.RegisterOutputType(VmssDataDiskResponseOutput{})
	pulumi.RegisterOutputType(VmssDataDiskResponseArrayOutput{})
}
