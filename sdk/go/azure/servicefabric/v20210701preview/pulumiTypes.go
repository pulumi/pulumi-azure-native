// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v20210701preview

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanism struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AddRemoveIncrementalNamedPartition'.
	Kind string `pulumi:"kind"`
	// Maximum number of named partitions of the service.
	MaxPartitionCount int `pulumi:"maxPartitionCount"`
	// Minimum number of named partitions of the service.
	MinPartitionCount int `pulumi:"minPartitionCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// AddRemoveIncrementalNamedPartitionScalingMechanismInput is an input type that accepts AddRemoveIncrementalNamedPartitionScalingMechanismArgs and AddRemoveIncrementalNamedPartitionScalingMechanismOutput values.
// You can construct a concrete instance of `AddRemoveIncrementalNamedPartitionScalingMechanismInput` via:
//
//          AddRemoveIncrementalNamedPartitionScalingMechanismArgs{...}
type AddRemoveIncrementalNamedPartitionScalingMechanismInput interface {
	pulumi.Input

	ToAddRemoveIncrementalNamedPartitionScalingMechanismOutput() AddRemoveIncrementalNamedPartitionScalingMechanismOutput
	ToAddRemoveIncrementalNamedPartitionScalingMechanismOutputWithContext(context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismOutput
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AddRemoveIncrementalNamedPartition'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// Maximum number of named partitions of the service.
	MaxPartitionCount pulumi.IntInput `pulumi:"maxPartitionCount"`
	// Minimum number of named partitions of the service.
	MinPartitionCount pulumi.IntInput `pulumi:"minPartitionCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement pulumi.IntInput `pulumi:"scaleIncrement"`
}

func (AddRemoveIncrementalNamedPartitionScalingMechanismArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AddRemoveIncrementalNamedPartitionScalingMechanism)(nil)).Elem()
}

func (i AddRemoveIncrementalNamedPartitionScalingMechanismArgs) ToAddRemoveIncrementalNamedPartitionScalingMechanismOutput() AddRemoveIncrementalNamedPartitionScalingMechanismOutput {
	return i.ToAddRemoveIncrementalNamedPartitionScalingMechanismOutputWithContext(context.Background())
}

func (i AddRemoveIncrementalNamedPartitionScalingMechanismArgs) ToAddRemoveIncrementalNamedPartitionScalingMechanismOutputWithContext(ctx context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddRemoveIncrementalNamedPartitionScalingMechanismOutput)
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismOutput struct{ *pulumi.OutputState }

func (AddRemoveIncrementalNamedPartitionScalingMechanismOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AddRemoveIncrementalNamedPartitionScalingMechanism)(nil)).Elem()
}

func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) ToAddRemoveIncrementalNamedPartitionScalingMechanismOutput() AddRemoveIncrementalNamedPartitionScalingMechanismOutput {
	return o
}

func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) ToAddRemoveIncrementalNamedPartitionScalingMechanismOutputWithContext(ctx context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AddRemoveIncrementalNamedPartition'.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanism) string { return v.Kind }).(pulumi.StringOutput)
}

// Maximum number of named partitions of the service.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) MaxPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanism) int { return v.MaxPartitionCount }).(pulumi.IntOutput)
}

// Minimum number of named partitions of the service.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) MinPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanism) int { return v.MinPartitionCount }).(pulumi.IntOutput)
}

// The number of instances to add or remove during a scaling operation.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismOutput) ScaleIncrement() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanism) int { return v.ScaleIncrement }).(pulumi.IntOutput)
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AddRemoveIncrementalNamedPartition'.
	Kind string `pulumi:"kind"`
	// Maximum number of named partitions of the service.
	MaxPartitionCount int `pulumi:"maxPartitionCount"`
	// Minimum number of named partitions of the service.
	MinPartitionCount int `pulumi:"minPartitionCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// AddRemoveIncrementalNamedPartitionScalingMechanismResponseInput is an input type that accepts AddRemoveIncrementalNamedPartitionScalingMechanismResponseArgs and AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput values.
// You can construct a concrete instance of `AddRemoveIncrementalNamedPartitionScalingMechanismResponseInput` via:
//
//          AddRemoveIncrementalNamedPartitionScalingMechanismResponseArgs{...}
type AddRemoveIncrementalNamedPartitionScalingMechanismResponseInput interface {
	pulumi.Input

	ToAddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput() AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput
	ToAddRemoveIncrementalNamedPartitionScalingMechanismResponseOutputWithContext(context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismResponseArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AddRemoveIncrementalNamedPartition'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// Maximum number of named partitions of the service.
	MaxPartitionCount pulumi.IntInput `pulumi:"maxPartitionCount"`
	// Minimum number of named partitions of the service.
	MinPartitionCount pulumi.IntInput `pulumi:"minPartitionCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement pulumi.IntInput `pulumi:"scaleIncrement"`
}

func (AddRemoveIncrementalNamedPartitionScalingMechanismResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AddRemoveIncrementalNamedPartitionScalingMechanismResponse)(nil)).Elem()
}

func (i AddRemoveIncrementalNamedPartitionScalingMechanismResponseArgs) ToAddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput() AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput {
	return i.ToAddRemoveIncrementalNamedPartitionScalingMechanismResponseOutputWithContext(context.Background())
}

func (i AddRemoveIncrementalNamedPartitionScalingMechanismResponseArgs) ToAddRemoveIncrementalNamedPartitionScalingMechanismResponseOutputWithContext(ctx context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput)
}

// Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
type AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput struct{ *pulumi.OutputState }

func (AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AddRemoveIncrementalNamedPartitionScalingMechanismResponse)(nil)).Elem()
}

func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) ToAddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput() AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput {
	return o
}

func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) ToAddRemoveIncrementalNamedPartitionScalingMechanismResponseOutputWithContext(ctx context.Context) AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AddRemoveIncrementalNamedPartition'.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanismResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// Maximum number of named partitions of the service.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) MaxPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanismResponse) int { return v.MaxPartitionCount }).(pulumi.IntOutput)
}

// Minimum number of named partitions of the service.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) MinPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanismResponse) int { return v.MinPartitionCount }).(pulumi.IntOutput)
}

// The number of instances to add or remove during a scaling operation.
func (o AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput) ScaleIncrement() pulumi.IntOutput {
	return o.ApplyT(func(v AddRemoveIncrementalNamedPartitionScalingMechanismResponse) int { return v.ScaleIncrement }).(pulumi.IntOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicy struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError bool `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ServiceTypeHealthPolicy `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications int `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]ServiceTypeHealthPolicy `pulumi:"serviceTypeHealthPolicyMap"`
}

// ApplicationHealthPolicyInput is an input type that accepts ApplicationHealthPolicyArgs and ApplicationHealthPolicyOutput values.
// You can construct a concrete instance of `ApplicationHealthPolicyInput` via:
//
//          ApplicationHealthPolicyArgs{...}
type ApplicationHealthPolicyInput interface {
	pulumi.Input

	ToApplicationHealthPolicyOutput() ApplicationHealthPolicyOutput
	ToApplicationHealthPolicyOutputWithContext(context.Context) ApplicationHealthPolicyOutput
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyArgs struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError pulumi.BoolInput `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy ServiceTypeHealthPolicyPtrInput `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications pulumi.IntInput `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap ServiceTypeHealthPolicyMapInput `pulumi:"serviceTypeHealthPolicyMap"`
}

func (ApplicationHealthPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicy)(nil)).Elem()
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyOutput() ApplicationHealthPolicyOutput {
	return i.ToApplicationHealthPolicyOutputWithContext(context.Background())
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyOutputWithContext(ctx context.Context) ApplicationHealthPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyOutput)
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return i.ToApplicationHealthPolicyPtrOutputWithContext(context.Background())
}

func (i ApplicationHealthPolicyArgs) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyOutput).ToApplicationHealthPolicyPtrOutputWithContext(ctx)
}

// ApplicationHealthPolicyPtrInput is an input type that accepts ApplicationHealthPolicyArgs, ApplicationHealthPolicyPtr and ApplicationHealthPolicyPtrOutput values.
// You can construct a concrete instance of `ApplicationHealthPolicyPtrInput` via:
//
//          ApplicationHealthPolicyArgs{...}
//
//  or:
//
//          nil
type ApplicationHealthPolicyPtrInput interface {
	pulumi.Input

	ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput
	ToApplicationHealthPolicyPtrOutputWithContext(context.Context) ApplicationHealthPolicyPtrOutput
}

type applicationHealthPolicyPtrType ApplicationHealthPolicyArgs

func ApplicationHealthPolicyPtr(v *ApplicationHealthPolicyArgs) ApplicationHealthPolicyPtrInput {
	return (*applicationHealthPolicyPtrType)(v)
}

func (*applicationHealthPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicy)(nil)).Elem()
}

func (i *applicationHealthPolicyPtrType) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return i.ToApplicationHealthPolicyPtrOutputWithContext(context.Background())
}

func (i *applicationHealthPolicyPtrType) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyPtrOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicy)(nil)).Elem()
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyOutput() ApplicationHealthPolicyOutput {
	return o
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyOutputWithContext(ctx context.Context) ApplicationHealthPolicyOutput {
	return o
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return o.ToApplicationHealthPolicyPtrOutputWithContext(context.Background())
}

func (o ApplicationHealthPolicyOutput) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) *ApplicationHealthPolicy {
		return &v
	}).(ApplicationHealthPolicyPtrOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyOutput) ConsiderWarningAsError() pulumi.BoolOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) bool { return v.ConsiderWarningAsError }).(pulumi.BoolOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) *ServiceTypeHealthPolicy { return v.DefaultServiceTypeHealthPolicy }).(ServiceTypeHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) int { return v.MaxPercentUnhealthyDeployedApplications }).(pulumi.IntOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyMapOutput {
	return o.ApplyT(func(v ApplicationHealthPolicy) map[string]ServiceTypeHealthPolicy {
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyMapOutput)
}

type ApplicationHealthPolicyPtrOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicy)(nil)).Elem()
}

func (o ApplicationHealthPolicyPtrOutput) ToApplicationHealthPolicyPtrOutput() ApplicationHealthPolicyPtrOutput {
	return o
}

func (o ApplicationHealthPolicyPtrOutput) ToApplicationHealthPolicyPtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyPtrOutput {
	return o
}

func (o ApplicationHealthPolicyPtrOutput) Elem() ApplicationHealthPolicyOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) ApplicationHealthPolicy { return *v }).(ApplicationHealthPolicyOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyPtrOutput) ConsiderWarningAsError() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) *bool {
		if v == nil {
			return nil
		}
		return &v.ConsiderWarningAsError
	}).(pulumi.BoolPtrOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyPtrOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) *ServiceTypeHealthPolicy {
		if v == nil {
			return nil
		}
		return v.DefaultServiceTypeHealthPolicy
	}).(ServiceTypeHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyPtrOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyDeployedApplications
	}).(pulumi.IntPtrOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyPtrOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyMapOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicy) map[string]ServiceTypeHealthPolicy {
		if v == nil {
			return nil
		}
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyMapOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyResponse struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError bool `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy *ServiceTypeHealthPolicyResponse `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications int `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap map[string]ServiceTypeHealthPolicyResponse `pulumi:"serviceTypeHealthPolicyMap"`
}

// ApplicationHealthPolicyResponseInput is an input type that accepts ApplicationHealthPolicyResponseArgs and ApplicationHealthPolicyResponseOutput values.
// You can construct a concrete instance of `ApplicationHealthPolicyResponseInput` via:
//
//          ApplicationHealthPolicyResponseArgs{...}
type ApplicationHealthPolicyResponseInput interface {
	pulumi.Input

	ToApplicationHealthPolicyResponseOutput() ApplicationHealthPolicyResponseOutput
	ToApplicationHealthPolicyResponseOutputWithContext(context.Context) ApplicationHealthPolicyResponseOutput
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyResponseArgs struct {
	// Indicates whether warnings are treated with the same severity as errors.
	ConsiderWarningAsError pulumi.BoolInput `pulumi:"considerWarningAsError"`
	// The health policy used by default to evaluate the health of a service type.
	DefaultServiceTypeHealthPolicy ServiceTypeHealthPolicyResponsePtrInput `pulumi:"defaultServiceTypeHealthPolicy"`
	// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
	// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
	// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
	// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
	MaxPercentUnhealthyDeployedApplications pulumi.IntInput `pulumi:"maxPercentUnhealthyDeployedApplications"`
	// The map with service type health policy per service type name. The map is empty by default.
	ServiceTypeHealthPolicyMap ServiceTypeHealthPolicyResponseMapInput `pulumi:"serviceTypeHealthPolicyMap"`
}

func (ApplicationHealthPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicyResponse)(nil)).Elem()
}

func (i ApplicationHealthPolicyResponseArgs) ToApplicationHealthPolicyResponseOutput() ApplicationHealthPolicyResponseOutput {
	return i.ToApplicationHealthPolicyResponseOutputWithContext(context.Background())
}

func (i ApplicationHealthPolicyResponseArgs) ToApplicationHealthPolicyResponseOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyResponseOutput)
}

func (i ApplicationHealthPolicyResponseArgs) ToApplicationHealthPolicyResponsePtrOutput() ApplicationHealthPolicyResponsePtrOutput {
	return i.ToApplicationHealthPolicyResponsePtrOutputWithContext(context.Background())
}

func (i ApplicationHealthPolicyResponseArgs) ToApplicationHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyResponseOutput).ToApplicationHealthPolicyResponsePtrOutputWithContext(ctx)
}

// ApplicationHealthPolicyResponsePtrInput is an input type that accepts ApplicationHealthPolicyResponseArgs, ApplicationHealthPolicyResponsePtr and ApplicationHealthPolicyResponsePtrOutput values.
// You can construct a concrete instance of `ApplicationHealthPolicyResponsePtrInput` via:
//
//          ApplicationHealthPolicyResponseArgs{...}
//
//  or:
//
//          nil
type ApplicationHealthPolicyResponsePtrInput interface {
	pulumi.Input

	ToApplicationHealthPolicyResponsePtrOutput() ApplicationHealthPolicyResponsePtrOutput
	ToApplicationHealthPolicyResponsePtrOutputWithContext(context.Context) ApplicationHealthPolicyResponsePtrOutput
}

type applicationHealthPolicyResponsePtrType ApplicationHealthPolicyResponseArgs

func ApplicationHealthPolicyResponsePtr(v *ApplicationHealthPolicyResponseArgs) ApplicationHealthPolicyResponsePtrInput {
	return (*applicationHealthPolicyResponsePtrType)(v)
}

func (*applicationHealthPolicyResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicyResponse)(nil)).Elem()
}

func (i *applicationHealthPolicyResponsePtrType) ToApplicationHealthPolicyResponsePtrOutput() ApplicationHealthPolicyResponsePtrOutput {
	return i.ToApplicationHealthPolicyResponsePtrOutputWithContext(context.Background())
}

func (i *applicationHealthPolicyResponsePtrType) ToApplicationHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationHealthPolicyResponsePtrOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
type ApplicationHealthPolicyResponseOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationHealthPolicyResponse)(nil)).Elem()
}

func (o ApplicationHealthPolicyResponseOutput) ToApplicationHealthPolicyResponseOutput() ApplicationHealthPolicyResponseOutput {
	return o
}

func (o ApplicationHealthPolicyResponseOutput) ToApplicationHealthPolicyResponseOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponseOutput {
	return o
}

func (o ApplicationHealthPolicyResponseOutput) ToApplicationHealthPolicyResponsePtrOutput() ApplicationHealthPolicyResponsePtrOutput {
	return o.ToApplicationHealthPolicyResponsePtrOutputWithContext(context.Background())
}

func (o ApplicationHealthPolicyResponseOutput) ToApplicationHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) *ApplicationHealthPolicyResponse {
		return &v
	}).(ApplicationHealthPolicyResponsePtrOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyResponseOutput) ConsiderWarningAsError() pulumi.BoolOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) bool { return v.ConsiderWarningAsError }).(pulumi.BoolOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyResponseOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) *ServiceTypeHealthPolicyResponse {
		return v.DefaultServiceTypeHealthPolicy
	}).(ServiceTypeHealthPolicyResponsePtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyResponseOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) int { return v.MaxPercentUnhealthyDeployedApplications }).(pulumi.IntOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyResponseOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyResponseMapOutput {
	return o.ApplyT(func(v ApplicationHealthPolicyResponse) map[string]ServiceTypeHealthPolicyResponse {
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyResponseMapOutput)
}

type ApplicationHealthPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationHealthPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationHealthPolicyResponse)(nil)).Elem()
}

func (o ApplicationHealthPolicyResponsePtrOutput) ToApplicationHealthPolicyResponsePtrOutput() ApplicationHealthPolicyResponsePtrOutput {
	return o
}

func (o ApplicationHealthPolicyResponsePtrOutput) ToApplicationHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationHealthPolicyResponsePtrOutput {
	return o
}

func (o ApplicationHealthPolicyResponsePtrOutput) Elem() ApplicationHealthPolicyResponseOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) ApplicationHealthPolicyResponse { return *v }).(ApplicationHealthPolicyResponseOutput)
}

// Indicates whether warnings are treated with the same severity as errors.
func (o ApplicationHealthPolicyResponsePtrOutput) ConsiderWarningAsError() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.ConsiderWarningAsError
	}).(pulumi.BoolPtrOutput)
}

// The health policy used by default to evaluate the health of a service type.
func (o ApplicationHealthPolicyResponsePtrOutput) DefaultServiceTypeHealthPolicy() ServiceTypeHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) *ServiceTypeHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.DefaultServiceTypeHealthPolicy
	}).(ServiceTypeHealthPolicyResponsePtrOutput)
}

// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
func (o ApplicationHealthPolicyResponsePtrOutput) MaxPercentUnhealthyDeployedApplications() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyDeployedApplications
	}).(pulumi.IntPtrOutput)
}

// The map with service type health policy per service type name. The map is empty by default.
func (o ApplicationHealthPolicyResponsePtrOutput) ServiceTypeHealthPolicyMap() ServiceTypeHealthPolicyResponseMapOutput {
	return o.ApplyT(func(v *ApplicationHealthPolicyResponse) map[string]ServiceTypeHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.ServiceTypeHealthPolicyMap
	}).(ServiceTypeHealthPolicyResponseMapOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicy struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep int `pulumi:"maxUnusedVersionsToKeep"`
}

// ApplicationTypeVersionsCleanupPolicyInput is an input type that accepts ApplicationTypeVersionsCleanupPolicyArgs and ApplicationTypeVersionsCleanupPolicyOutput values.
// You can construct a concrete instance of `ApplicationTypeVersionsCleanupPolicyInput` via:
//
//          ApplicationTypeVersionsCleanupPolicyArgs{...}
type ApplicationTypeVersionsCleanupPolicyInput interface {
	pulumi.Input

	ToApplicationTypeVersionsCleanupPolicyOutput() ApplicationTypeVersionsCleanupPolicyOutput
	ToApplicationTypeVersionsCleanupPolicyOutputWithContext(context.Context) ApplicationTypeVersionsCleanupPolicyOutput
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyArgs struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep pulumi.IntInput `pulumi:"maxUnusedVersionsToKeep"`
}

func (ApplicationTypeVersionsCleanupPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyOutput() ApplicationTypeVersionsCleanupPolicyOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyOutputWithContext(context.Background())
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyOutput)
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Background())
}

func (i ApplicationTypeVersionsCleanupPolicyArgs) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyOutput).ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx)
}

// ApplicationTypeVersionsCleanupPolicyPtrInput is an input type that accepts ApplicationTypeVersionsCleanupPolicyArgs, ApplicationTypeVersionsCleanupPolicyPtr and ApplicationTypeVersionsCleanupPolicyPtrOutput values.
// You can construct a concrete instance of `ApplicationTypeVersionsCleanupPolicyPtrInput` via:
//
//          ApplicationTypeVersionsCleanupPolicyArgs{...}
//
//  or:
//
//          nil
type ApplicationTypeVersionsCleanupPolicyPtrInput interface {
	pulumi.Input

	ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput
	ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput
}

type applicationTypeVersionsCleanupPolicyPtrType ApplicationTypeVersionsCleanupPolicyArgs

func ApplicationTypeVersionsCleanupPolicyPtr(v *ApplicationTypeVersionsCleanupPolicyArgs) ApplicationTypeVersionsCleanupPolicyPtrInput {
	return (*applicationTypeVersionsCleanupPolicyPtrType)(v)
}

func (*applicationTypeVersionsCleanupPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (i *applicationTypeVersionsCleanupPolicyPtrType) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Background())
}

func (i *applicationTypeVersionsCleanupPolicyPtrType) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyPtrOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyOutput() ApplicationTypeVersionsCleanupPolicyOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o.ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(context.Background())
}

func (o ApplicationTypeVersionsCleanupPolicyOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationTypeVersionsCleanupPolicy) *ApplicationTypeVersionsCleanupPolicy {
		return &v
	}).(ApplicationTypeVersionsCleanupPolicyPtrOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyOutput) MaxUnusedVersionsToKeep() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationTypeVersionsCleanupPolicy) int { return v.MaxUnusedVersionsToKeep }).(pulumi.IntOutput)
}

type ApplicationTypeVersionsCleanupPolicyPtrOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicy)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutput() ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) ToApplicationTypeVersionsCleanupPolicyPtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyPtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) Elem() ApplicationTypeVersionsCleanupPolicyOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicy) ApplicationTypeVersionsCleanupPolicy { return *v }).(ApplicationTypeVersionsCleanupPolicyOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyPtrOutput) MaxUnusedVersionsToKeep() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxUnusedVersionsToKeep
	}).(pulumi.IntPtrOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyResponse struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep int `pulumi:"maxUnusedVersionsToKeep"`
}

// ApplicationTypeVersionsCleanupPolicyResponseInput is an input type that accepts ApplicationTypeVersionsCleanupPolicyResponseArgs and ApplicationTypeVersionsCleanupPolicyResponseOutput values.
// You can construct a concrete instance of `ApplicationTypeVersionsCleanupPolicyResponseInput` via:
//
//          ApplicationTypeVersionsCleanupPolicyResponseArgs{...}
type ApplicationTypeVersionsCleanupPolicyResponseInput interface {
	pulumi.Input

	ToApplicationTypeVersionsCleanupPolicyResponseOutput() ApplicationTypeVersionsCleanupPolicyResponseOutput
	ToApplicationTypeVersionsCleanupPolicyResponseOutputWithContext(context.Context) ApplicationTypeVersionsCleanupPolicyResponseOutput
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyResponseArgs struct {
	// Number of unused versions per application type to keep.
	MaxUnusedVersionsToKeep pulumi.IntInput `pulumi:"maxUnusedVersionsToKeep"`
}

func (ApplicationTypeVersionsCleanupPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicyResponse)(nil)).Elem()
}

func (i ApplicationTypeVersionsCleanupPolicyResponseArgs) ToApplicationTypeVersionsCleanupPolicyResponseOutput() ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyResponseOutputWithContext(context.Background())
}

func (i ApplicationTypeVersionsCleanupPolicyResponseArgs) ToApplicationTypeVersionsCleanupPolicyResponseOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyResponseOutput)
}

func (i ApplicationTypeVersionsCleanupPolicyResponseArgs) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutput() ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(context.Background())
}

func (i ApplicationTypeVersionsCleanupPolicyResponseArgs) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyResponseOutput).ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(ctx)
}

// ApplicationTypeVersionsCleanupPolicyResponsePtrInput is an input type that accepts ApplicationTypeVersionsCleanupPolicyResponseArgs, ApplicationTypeVersionsCleanupPolicyResponsePtr and ApplicationTypeVersionsCleanupPolicyResponsePtrOutput values.
// You can construct a concrete instance of `ApplicationTypeVersionsCleanupPolicyResponsePtrInput` via:
//
//          ApplicationTypeVersionsCleanupPolicyResponseArgs{...}
//
//  or:
//
//          nil
type ApplicationTypeVersionsCleanupPolicyResponsePtrInput interface {
	pulumi.Input

	ToApplicationTypeVersionsCleanupPolicyResponsePtrOutput() ApplicationTypeVersionsCleanupPolicyResponsePtrOutput
	ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(context.Context) ApplicationTypeVersionsCleanupPolicyResponsePtrOutput
}

type applicationTypeVersionsCleanupPolicyResponsePtrType ApplicationTypeVersionsCleanupPolicyResponseArgs

func ApplicationTypeVersionsCleanupPolicyResponsePtr(v *ApplicationTypeVersionsCleanupPolicyResponseArgs) ApplicationTypeVersionsCleanupPolicyResponsePtrInput {
	return (*applicationTypeVersionsCleanupPolicyResponsePtrType)(v)
}

func (*applicationTypeVersionsCleanupPolicyResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicyResponse)(nil)).Elem()
}

func (i *applicationTypeVersionsCleanupPolicyResponsePtrType) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutput() ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return i.ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(context.Background())
}

func (i *applicationTypeVersionsCleanupPolicyResponsePtrType) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationTypeVersionsCleanupPolicyResponsePtrOutput)
}

// The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
type ApplicationTypeVersionsCleanupPolicyResponseOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationTypeVersionsCleanupPolicyResponse)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) ToApplicationTypeVersionsCleanupPolicyResponseOutput() ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) ToApplicationTypeVersionsCleanupPolicyResponseOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutput() ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return o.ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(context.Background())
}

func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationTypeVersionsCleanupPolicyResponse) *ApplicationTypeVersionsCleanupPolicyResponse {
		return &v
	}).(ApplicationTypeVersionsCleanupPolicyResponsePtrOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyResponseOutput) MaxUnusedVersionsToKeep() pulumi.IntOutput {
	return o.ApplyT(func(v ApplicationTypeVersionsCleanupPolicyResponse) int { return v.MaxUnusedVersionsToKeep }).(pulumi.IntOutput)
}

type ApplicationTypeVersionsCleanupPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationTypeVersionsCleanupPolicyResponse)(nil)).Elem()
}

func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutput() ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) ToApplicationTypeVersionsCleanupPolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationTypeVersionsCleanupPolicyResponsePtrOutput {
	return o
}

func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) Elem() ApplicationTypeVersionsCleanupPolicyResponseOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicyResponse) ApplicationTypeVersionsCleanupPolicyResponse {
		return *v
	}).(ApplicationTypeVersionsCleanupPolicyResponseOutput)
}

// Number of unused versions per application type to keep.
func (o ApplicationTypeVersionsCleanupPolicyResponsePtrOutput) MaxUnusedVersionsToKeep() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ApplicationTypeVersionsCleanupPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxUnusedVersionsToKeep
	}).(pulumi.IntPtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicy struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *ApplicationHealthPolicy `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart *bool `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration *float64 `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication *bool `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy *RollingUpgradeMonitoringPolicy `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode *string `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout *float64 `pulumi:"upgradeReplicaSetCheckTimeout"`
}

// ApplicationUpgradePolicyInput is an input type that accepts ApplicationUpgradePolicyArgs and ApplicationUpgradePolicyOutput values.
// You can construct a concrete instance of `ApplicationUpgradePolicyInput` via:
//
//          ApplicationUpgradePolicyArgs{...}
type ApplicationUpgradePolicyInput interface {
	pulumi.Input

	ToApplicationUpgradePolicyOutput() ApplicationUpgradePolicyOutput
	ToApplicationUpgradePolicyOutputWithContext(context.Context) ApplicationUpgradePolicyOutput
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyArgs struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy ApplicationHealthPolicyPtrInput `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart pulumi.BoolPtrInput `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration pulumi.Float64PtrInput `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication pulumi.BoolPtrInput `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy RollingUpgradeMonitoringPolicyPtrInput `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode pulumi.StringPtrInput `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout pulumi.Float64PtrInput `pulumi:"upgradeReplicaSetCheckTimeout"`
}

func (ApplicationUpgradePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicy)(nil)).Elem()
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyOutput() ApplicationUpgradePolicyOutput {
	return i.ToApplicationUpgradePolicyOutputWithContext(context.Background())
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyOutputWithContext(ctx context.Context) ApplicationUpgradePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyOutput)
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return i.ToApplicationUpgradePolicyPtrOutputWithContext(context.Background())
}

func (i ApplicationUpgradePolicyArgs) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyOutput).ToApplicationUpgradePolicyPtrOutputWithContext(ctx)
}

// ApplicationUpgradePolicyPtrInput is an input type that accepts ApplicationUpgradePolicyArgs, ApplicationUpgradePolicyPtr and ApplicationUpgradePolicyPtrOutput values.
// You can construct a concrete instance of `ApplicationUpgradePolicyPtrInput` via:
//
//          ApplicationUpgradePolicyArgs{...}
//
//  or:
//
//          nil
type ApplicationUpgradePolicyPtrInput interface {
	pulumi.Input

	ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput
	ToApplicationUpgradePolicyPtrOutputWithContext(context.Context) ApplicationUpgradePolicyPtrOutput
}

type applicationUpgradePolicyPtrType ApplicationUpgradePolicyArgs

func ApplicationUpgradePolicyPtr(v *ApplicationUpgradePolicyArgs) ApplicationUpgradePolicyPtrInput {
	return (*applicationUpgradePolicyPtrType)(v)
}

func (*applicationUpgradePolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicy)(nil)).Elem()
}

func (i *applicationUpgradePolicyPtrType) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return i.ToApplicationUpgradePolicyPtrOutputWithContext(context.Background())
}

func (i *applicationUpgradePolicyPtrType) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyPtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicy)(nil)).Elem()
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyOutput() ApplicationUpgradePolicyOutput {
	return o
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyOutputWithContext(ctx context.Context) ApplicationUpgradePolicyOutput {
	return o
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return o.ToApplicationUpgradePolicyPtrOutputWithContext(context.Background())
}

func (o ApplicationUpgradePolicyOutput) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *ApplicationUpgradePolicy {
		return &v
	}).(ApplicationUpgradePolicyPtrOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyOutput) ApplicationHealthPolicy() ApplicationHealthPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *ApplicationHealthPolicy { return v.ApplicationHealthPolicy }).(ApplicationHealthPolicyPtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *bool { return v.ForceRestart }).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *float64 { return v.InstanceCloseDelayDuration }).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *bool { return v.RecreateApplication }).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *RollingUpgradeMonitoringPolicy {
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *string { return v.UpgradeMode }).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicy) *float64 { return v.UpgradeReplicaSetCheckTimeout }).(pulumi.Float64PtrOutput)
}

type ApplicationUpgradePolicyPtrOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicy)(nil)).Elem()
}

func (o ApplicationUpgradePolicyPtrOutput) ToApplicationUpgradePolicyPtrOutput() ApplicationUpgradePolicyPtrOutput {
	return o
}

func (o ApplicationUpgradePolicyPtrOutput) ToApplicationUpgradePolicyPtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyPtrOutput {
	return o
}

func (o ApplicationUpgradePolicyPtrOutput) Elem() ApplicationUpgradePolicyOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) ApplicationUpgradePolicy { return *v }).(ApplicationUpgradePolicyOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyPtrOutput) ApplicationHealthPolicy() ApplicationHealthPolicyPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *ApplicationHealthPolicy {
		if v == nil {
			return nil
		}
		return v.ApplicationHealthPolicy
	}).(ApplicationHealthPolicyPtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyPtrOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.ForceRestart
	}).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyPtrOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.InstanceCloseDelayDuration
	}).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyPtrOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.RecreateApplication
	}).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyPtrOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *RollingUpgradeMonitoringPolicy {
		if v == nil {
			return nil
		}
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyPtrOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *string {
		if v == nil {
			return nil
		}
		return v.UpgradeMode
	}).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyPtrOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.UpgradeReplicaSetCheckTimeout
	}).(pulumi.Float64PtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyResponse struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy *ApplicationHealthPolicyResponse `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart *bool `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration *float64 `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication *bool `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy *RollingUpgradeMonitoringPolicyResponse `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode *string `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout *float64 `pulumi:"upgradeReplicaSetCheckTimeout"`
}

// ApplicationUpgradePolicyResponseInput is an input type that accepts ApplicationUpgradePolicyResponseArgs and ApplicationUpgradePolicyResponseOutput values.
// You can construct a concrete instance of `ApplicationUpgradePolicyResponseInput` via:
//
//          ApplicationUpgradePolicyResponseArgs{...}
type ApplicationUpgradePolicyResponseInput interface {
	pulumi.Input

	ToApplicationUpgradePolicyResponseOutput() ApplicationUpgradePolicyResponseOutput
	ToApplicationUpgradePolicyResponseOutputWithContext(context.Context) ApplicationUpgradePolicyResponseOutput
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyResponseArgs struct {
	// Defines a health policy used to evaluate the health of an application or one of its children entities.
	ApplicationHealthPolicy ApplicationHealthPolicyResponsePtrInput `pulumi:"applicationHealthPolicy"`
	// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
	ForceRestart pulumi.BoolPtrInput `pulumi:"forceRestart"`
	// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
	InstanceCloseDelayDuration pulumi.Float64PtrInput `pulumi:"instanceCloseDelayDuration"`
	// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
	RecreateApplication pulumi.BoolPtrInput `pulumi:"recreateApplication"`
	// The policy used for monitoring the application upgrade
	RollingUpgradeMonitoringPolicy RollingUpgradeMonitoringPolicyResponsePtrInput `pulumi:"rollingUpgradeMonitoringPolicy"`
	// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
	UpgradeMode pulumi.StringPtrInput `pulumi:"upgradeMode"`
	// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
	UpgradeReplicaSetCheckTimeout pulumi.Float64PtrInput `pulumi:"upgradeReplicaSetCheckTimeout"`
}

func (ApplicationUpgradePolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicyResponse)(nil)).Elem()
}

func (i ApplicationUpgradePolicyResponseArgs) ToApplicationUpgradePolicyResponseOutput() ApplicationUpgradePolicyResponseOutput {
	return i.ToApplicationUpgradePolicyResponseOutputWithContext(context.Background())
}

func (i ApplicationUpgradePolicyResponseArgs) ToApplicationUpgradePolicyResponseOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyResponseOutput)
}

func (i ApplicationUpgradePolicyResponseArgs) ToApplicationUpgradePolicyResponsePtrOutput() ApplicationUpgradePolicyResponsePtrOutput {
	return i.ToApplicationUpgradePolicyResponsePtrOutputWithContext(context.Background())
}

func (i ApplicationUpgradePolicyResponseArgs) ToApplicationUpgradePolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyResponseOutput).ToApplicationUpgradePolicyResponsePtrOutputWithContext(ctx)
}

// ApplicationUpgradePolicyResponsePtrInput is an input type that accepts ApplicationUpgradePolicyResponseArgs, ApplicationUpgradePolicyResponsePtr and ApplicationUpgradePolicyResponsePtrOutput values.
// You can construct a concrete instance of `ApplicationUpgradePolicyResponsePtrInput` via:
//
//          ApplicationUpgradePolicyResponseArgs{...}
//
//  or:
//
//          nil
type ApplicationUpgradePolicyResponsePtrInput interface {
	pulumi.Input

	ToApplicationUpgradePolicyResponsePtrOutput() ApplicationUpgradePolicyResponsePtrOutput
	ToApplicationUpgradePolicyResponsePtrOutputWithContext(context.Context) ApplicationUpgradePolicyResponsePtrOutput
}

type applicationUpgradePolicyResponsePtrType ApplicationUpgradePolicyResponseArgs

func ApplicationUpgradePolicyResponsePtr(v *ApplicationUpgradePolicyResponseArgs) ApplicationUpgradePolicyResponsePtrInput {
	return (*applicationUpgradePolicyResponsePtrType)(v)
}

func (*applicationUpgradePolicyResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicyResponse)(nil)).Elem()
}

func (i *applicationUpgradePolicyResponsePtrType) ToApplicationUpgradePolicyResponsePtrOutput() ApplicationUpgradePolicyResponsePtrOutput {
	return i.ToApplicationUpgradePolicyResponsePtrOutputWithContext(context.Background())
}

func (i *applicationUpgradePolicyResponsePtrType) ToApplicationUpgradePolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUpgradePolicyResponsePtrOutput)
}

// Describes the policy for a monitored application upgrade.
type ApplicationUpgradePolicyResponseOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUpgradePolicyResponse)(nil)).Elem()
}

func (o ApplicationUpgradePolicyResponseOutput) ToApplicationUpgradePolicyResponseOutput() ApplicationUpgradePolicyResponseOutput {
	return o
}

func (o ApplicationUpgradePolicyResponseOutput) ToApplicationUpgradePolicyResponseOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponseOutput {
	return o
}

func (o ApplicationUpgradePolicyResponseOutput) ToApplicationUpgradePolicyResponsePtrOutput() ApplicationUpgradePolicyResponsePtrOutput {
	return o.ToApplicationUpgradePolicyResponsePtrOutputWithContext(context.Background())
}

func (o ApplicationUpgradePolicyResponseOutput) ToApplicationUpgradePolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *ApplicationUpgradePolicyResponse {
		return &v
	}).(ApplicationUpgradePolicyResponsePtrOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyResponseOutput) ApplicationHealthPolicy() ApplicationHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *ApplicationHealthPolicyResponse {
		return v.ApplicationHealthPolicy
	}).(ApplicationHealthPolicyResponsePtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyResponseOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *bool { return v.ForceRestart }).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyResponseOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *float64 { return v.InstanceCloseDelayDuration }).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyResponseOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *bool { return v.RecreateApplication }).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyResponseOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *RollingUpgradeMonitoringPolicyResponse {
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyResponsePtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyResponseOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *string { return v.UpgradeMode }).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyResponseOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ApplicationUpgradePolicyResponse) *float64 { return v.UpgradeReplicaSetCheckTimeout }).(pulumi.Float64PtrOutput)
}

type ApplicationUpgradePolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationUpgradePolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationUpgradePolicyResponse)(nil)).Elem()
}

func (o ApplicationUpgradePolicyResponsePtrOutput) ToApplicationUpgradePolicyResponsePtrOutput() ApplicationUpgradePolicyResponsePtrOutput {
	return o
}

func (o ApplicationUpgradePolicyResponsePtrOutput) ToApplicationUpgradePolicyResponsePtrOutputWithContext(ctx context.Context) ApplicationUpgradePolicyResponsePtrOutput {
	return o
}

func (o ApplicationUpgradePolicyResponsePtrOutput) Elem() ApplicationUpgradePolicyResponseOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) ApplicationUpgradePolicyResponse { return *v }).(ApplicationUpgradePolicyResponseOutput)
}

// Defines a health policy used to evaluate the health of an application or one of its children entities.
func (o ApplicationUpgradePolicyResponsePtrOutput) ApplicationHealthPolicy() ApplicationHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *ApplicationHealthPolicyResponse {
		if v == nil {
			return nil
		}
		return v.ApplicationHealthPolicy
	}).(ApplicationHealthPolicyResponsePtrOutput)
}

// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
func (o ApplicationUpgradePolicyResponsePtrOutput) ForceRestart() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return v.ForceRestart
	}).(pulumi.BoolPtrOutput)
}

// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
func (o ApplicationUpgradePolicyResponsePtrOutput) InstanceCloseDelayDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.InstanceCloseDelayDuration
	}).(pulumi.Float64PtrOutput)
}

// Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
func (o ApplicationUpgradePolicyResponsePtrOutput) RecreateApplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *bool {
		if v == nil {
			return nil
		}
		return v.RecreateApplication
	}).(pulumi.BoolPtrOutput)
}

// The policy used for monitoring the application upgrade
func (o ApplicationUpgradePolicyResponsePtrOutput) RollingUpgradeMonitoringPolicy() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *RollingUpgradeMonitoringPolicyResponse {
		if v == nil {
			return nil
		}
		return v.RollingUpgradeMonitoringPolicy
	}).(RollingUpgradeMonitoringPolicyResponsePtrOutput)
}

// The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
func (o ApplicationUpgradePolicyResponsePtrOutput) UpgradeMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.UpgradeMode
	}).(pulumi.StringPtrOutput)
}

// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
func (o ApplicationUpgradePolicyResponsePtrOutput) UpgradeReplicaSetCheckTimeout() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ApplicationUpgradePolicyResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.UpgradeReplicaSetCheckTimeout
	}).(pulumi.Float64PtrOutput)
}

type ApplicationUserAssignedIdentity struct {
	// The friendly name of user assigned identity.
	Name string `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

// ApplicationUserAssignedIdentityInput is an input type that accepts ApplicationUserAssignedIdentityArgs and ApplicationUserAssignedIdentityOutput values.
// You can construct a concrete instance of `ApplicationUserAssignedIdentityInput` via:
//
//          ApplicationUserAssignedIdentityArgs{...}
type ApplicationUserAssignedIdentityInput interface {
	pulumi.Input

	ToApplicationUserAssignedIdentityOutput() ApplicationUserAssignedIdentityOutput
	ToApplicationUserAssignedIdentityOutputWithContext(context.Context) ApplicationUserAssignedIdentityOutput
}

type ApplicationUserAssignedIdentityArgs struct {
	// The friendly name of user assigned identity.
	Name pulumi.StringInput `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId pulumi.StringInput `pulumi:"principalId"`
}

func (ApplicationUserAssignedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (i ApplicationUserAssignedIdentityArgs) ToApplicationUserAssignedIdentityOutput() ApplicationUserAssignedIdentityOutput {
	return i.ToApplicationUserAssignedIdentityOutputWithContext(context.Background())
}

func (i ApplicationUserAssignedIdentityArgs) ToApplicationUserAssignedIdentityOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUserAssignedIdentityOutput)
}

// ApplicationUserAssignedIdentityArrayInput is an input type that accepts ApplicationUserAssignedIdentityArray and ApplicationUserAssignedIdentityArrayOutput values.
// You can construct a concrete instance of `ApplicationUserAssignedIdentityArrayInput` via:
//
//          ApplicationUserAssignedIdentityArray{ ApplicationUserAssignedIdentityArgs{...} }
type ApplicationUserAssignedIdentityArrayInput interface {
	pulumi.Input

	ToApplicationUserAssignedIdentityArrayOutput() ApplicationUserAssignedIdentityArrayOutput
	ToApplicationUserAssignedIdentityArrayOutputWithContext(context.Context) ApplicationUserAssignedIdentityArrayOutput
}

type ApplicationUserAssignedIdentityArray []ApplicationUserAssignedIdentityInput

func (ApplicationUserAssignedIdentityArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (i ApplicationUserAssignedIdentityArray) ToApplicationUserAssignedIdentityArrayOutput() ApplicationUserAssignedIdentityArrayOutput {
	return i.ToApplicationUserAssignedIdentityArrayOutputWithContext(context.Background())
}

func (i ApplicationUserAssignedIdentityArray) ToApplicationUserAssignedIdentityArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUserAssignedIdentityArrayOutput)
}

type ApplicationUserAssignedIdentityOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityOutput) ToApplicationUserAssignedIdentityOutput() ApplicationUserAssignedIdentityOutput {
	return o
}

func (o ApplicationUserAssignedIdentityOutput) ToApplicationUserAssignedIdentityOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityOutput {
	return o
}

// The friendly name of user assigned identity.
func (o ApplicationUserAssignedIdentityOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentity) string { return v.Name }).(pulumi.StringOutput)
}

// The principal id of user assigned identity.
func (o ApplicationUserAssignedIdentityOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentity) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type ApplicationUserAssignedIdentityArrayOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentity)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityArrayOutput) ToApplicationUserAssignedIdentityArrayOutput() ApplicationUserAssignedIdentityArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityArrayOutput) ToApplicationUserAssignedIdentityArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityArrayOutput) Index(i pulumi.IntInput) ApplicationUserAssignedIdentityOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApplicationUserAssignedIdentity {
		return vs[0].([]ApplicationUserAssignedIdentity)[vs[1].(int)]
	}).(ApplicationUserAssignedIdentityOutput)
}

type ApplicationUserAssignedIdentityResponse struct {
	// The friendly name of user assigned identity.
	Name string `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

// ApplicationUserAssignedIdentityResponseInput is an input type that accepts ApplicationUserAssignedIdentityResponseArgs and ApplicationUserAssignedIdentityResponseOutput values.
// You can construct a concrete instance of `ApplicationUserAssignedIdentityResponseInput` via:
//
//          ApplicationUserAssignedIdentityResponseArgs{...}
type ApplicationUserAssignedIdentityResponseInput interface {
	pulumi.Input

	ToApplicationUserAssignedIdentityResponseOutput() ApplicationUserAssignedIdentityResponseOutput
	ToApplicationUserAssignedIdentityResponseOutputWithContext(context.Context) ApplicationUserAssignedIdentityResponseOutput
}

type ApplicationUserAssignedIdentityResponseArgs struct {
	// The friendly name of user assigned identity.
	Name pulumi.StringInput `pulumi:"name"`
	// The principal id of user assigned identity.
	PrincipalId pulumi.StringInput `pulumi:"principalId"`
}

func (ApplicationUserAssignedIdentityResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentityResponse)(nil)).Elem()
}

func (i ApplicationUserAssignedIdentityResponseArgs) ToApplicationUserAssignedIdentityResponseOutput() ApplicationUserAssignedIdentityResponseOutput {
	return i.ToApplicationUserAssignedIdentityResponseOutputWithContext(context.Background())
}

func (i ApplicationUserAssignedIdentityResponseArgs) ToApplicationUserAssignedIdentityResponseOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUserAssignedIdentityResponseOutput)
}

// ApplicationUserAssignedIdentityResponseArrayInput is an input type that accepts ApplicationUserAssignedIdentityResponseArray and ApplicationUserAssignedIdentityResponseArrayOutput values.
// You can construct a concrete instance of `ApplicationUserAssignedIdentityResponseArrayInput` via:
//
//          ApplicationUserAssignedIdentityResponseArray{ ApplicationUserAssignedIdentityResponseArgs{...} }
type ApplicationUserAssignedIdentityResponseArrayInput interface {
	pulumi.Input

	ToApplicationUserAssignedIdentityResponseArrayOutput() ApplicationUserAssignedIdentityResponseArrayOutput
	ToApplicationUserAssignedIdentityResponseArrayOutputWithContext(context.Context) ApplicationUserAssignedIdentityResponseArrayOutput
}

type ApplicationUserAssignedIdentityResponseArray []ApplicationUserAssignedIdentityResponseInput

func (ApplicationUserAssignedIdentityResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentityResponse)(nil)).Elem()
}

func (i ApplicationUserAssignedIdentityResponseArray) ToApplicationUserAssignedIdentityResponseArrayOutput() ApplicationUserAssignedIdentityResponseArrayOutput {
	return i.ToApplicationUserAssignedIdentityResponseArrayOutputWithContext(context.Background())
}

func (i ApplicationUserAssignedIdentityResponseArray) ToApplicationUserAssignedIdentityResponseArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationUserAssignedIdentityResponseArrayOutput)
}

type ApplicationUserAssignedIdentityResponseOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationUserAssignedIdentityResponse)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityResponseOutput) ToApplicationUserAssignedIdentityResponseOutput() ApplicationUserAssignedIdentityResponseOutput {
	return o
}

func (o ApplicationUserAssignedIdentityResponseOutput) ToApplicationUserAssignedIdentityResponseOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityResponseOutput {
	return o
}

// The friendly name of user assigned identity.
func (o ApplicationUserAssignedIdentityResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentityResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The principal id of user assigned identity.
func (o ApplicationUserAssignedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationUserAssignedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type ApplicationUserAssignedIdentityResponseArrayOutput struct{ *pulumi.OutputState }

func (ApplicationUserAssignedIdentityResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationUserAssignedIdentityResponse)(nil)).Elem()
}

func (o ApplicationUserAssignedIdentityResponseArrayOutput) ToApplicationUserAssignedIdentityResponseArrayOutput() ApplicationUserAssignedIdentityResponseArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityResponseArrayOutput) ToApplicationUserAssignedIdentityResponseArrayOutputWithContext(ctx context.Context) ApplicationUserAssignedIdentityResponseArrayOutput {
	return o
}

func (o ApplicationUserAssignedIdentityResponseArrayOutput) Index(i pulumi.IntInput) ApplicationUserAssignedIdentityResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApplicationUserAssignedIdentityResponse {
		return vs[0].([]ApplicationUserAssignedIdentityResponse)[vs[1].(int)]
	}).(ApplicationUserAssignedIdentityResponseOutput)
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTrigger struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AveragePartitionLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
}

// AveragePartitionLoadScalingTriggerInput is an input type that accepts AveragePartitionLoadScalingTriggerArgs and AveragePartitionLoadScalingTriggerOutput values.
// You can construct a concrete instance of `AveragePartitionLoadScalingTriggerInput` via:
//
//          AveragePartitionLoadScalingTriggerArgs{...}
type AveragePartitionLoadScalingTriggerInput interface {
	pulumi.Input

	ToAveragePartitionLoadScalingTriggerOutput() AveragePartitionLoadScalingTriggerOutput
	ToAveragePartitionLoadScalingTriggerOutputWithContext(context.Context) AveragePartitionLoadScalingTriggerOutput
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AveragePartitionLoadTrigger'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold pulumi.Float64Input `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval pulumi.StringInput `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold pulumi.Float64Input `pulumi:"upperLoadThreshold"`
}

func (AveragePartitionLoadScalingTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AveragePartitionLoadScalingTrigger)(nil)).Elem()
}

func (i AveragePartitionLoadScalingTriggerArgs) ToAveragePartitionLoadScalingTriggerOutput() AveragePartitionLoadScalingTriggerOutput {
	return i.ToAveragePartitionLoadScalingTriggerOutputWithContext(context.Background())
}

func (i AveragePartitionLoadScalingTriggerArgs) ToAveragePartitionLoadScalingTriggerOutputWithContext(ctx context.Context) AveragePartitionLoadScalingTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AveragePartitionLoadScalingTriggerOutput)
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerOutput struct{ *pulumi.OutputState }

func (AveragePartitionLoadScalingTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AveragePartitionLoadScalingTrigger)(nil)).Elem()
}

func (o AveragePartitionLoadScalingTriggerOutput) ToAveragePartitionLoadScalingTriggerOutput() AveragePartitionLoadScalingTriggerOutput {
	return o
}

func (o AveragePartitionLoadScalingTriggerOutput) ToAveragePartitionLoadScalingTriggerOutputWithContext(ctx context.Context) AveragePartitionLoadScalingTriggerOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AveragePartitionLoadTrigger'.
func (o AveragePartitionLoadScalingTriggerOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) string { return v.Kind }).(pulumi.StringOutput)
}

// The lower limit of the load below which a scale in operation should be performed.
func (o AveragePartitionLoadScalingTriggerOutput) LowerLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) float64 { return v.LowerLoadThreshold }).(pulumi.Float64Output)
}

// The name of the metric for which usage should be tracked.
func (o AveragePartitionLoadScalingTriggerOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) string { return v.MetricName }).(pulumi.StringOutput)
}

// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
func (o AveragePartitionLoadScalingTriggerOutput) ScaleInterval() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) string { return v.ScaleInterval }).(pulumi.StringOutput)
}

// The upper limit of the load beyond which a scale out operation should be performed.
func (o AveragePartitionLoadScalingTriggerOutput) UpperLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AveragePartitionLoadScalingTrigger) float64 { return v.UpperLoadThreshold }).(pulumi.Float64Output)
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AveragePartitionLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
}

// AveragePartitionLoadScalingTriggerResponseInput is an input type that accepts AveragePartitionLoadScalingTriggerResponseArgs and AveragePartitionLoadScalingTriggerResponseOutput values.
// You can construct a concrete instance of `AveragePartitionLoadScalingTriggerResponseInput` via:
//
//          AveragePartitionLoadScalingTriggerResponseArgs{...}
type AveragePartitionLoadScalingTriggerResponseInput interface {
	pulumi.Input

	ToAveragePartitionLoadScalingTriggerResponseOutput() AveragePartitionLoadScalingTriggerResponseOutput
	ToAveragePartitionLoadScalingTriggerResponseOutputWithContext(context.Context) AveragePartitionLoadScalingTriggerResponseOutput
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerResponseArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AveragePartitionLoadTrigger'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold pulumi.Float64Input `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval pulumi.StringInput `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold pulumi.Float64Input `pulumi:"upperLoadThreshold"`
}

func (AveragePartitionLoadScalingTriggerResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AveragePartitionLoadScalingTriggerResponse)(nil)).Elem()
}

func (i AveragePartitionLoadScalingTriggerResponseArgs) ToAveragePartitionLoadScalingTriggerResponseOutput() AveragePartitionLoadScalingTriggerResponseOutput {
	return i.ToAveragePartitionLoadScalingTriggerResponseOutputWithContext(context.Background())
}

func (i AveragePartitionLoadScalingTriggerResponseArgs) ToAveragePartitionLoadScalingTriggerResponseOutputWithContext(ctx context.Context) AveragePartitionLoadScalingTriggerResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AveragePartitionLoadScalingTriggerResponseOutput)
}

// Represents a scaling trigger related to an average load of a metric/resource of a partition.
type AveragePartitionLoadScalingTriggerResponseOutput struct{ *pulumi.OutputState }

func (AveragePartitionLoadScalingTriggerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AveragePartitionLoadScalingTriggerResponse)(nil)).Elem()
}

func (o AveragePartitionLoadScalingTriggerResponseOutput) ToAveragePartitionLoadScalingTriggerResponseOutput() AveragePartitionLoadScalingTriggerResponseOutput {
	return o
}

func (o AveragePartitionLoadScalingTriggerResponseOutput) ToAveragePartitionLoadScalingTriggerResponseOutputWithContext(ctx context.Context) AveragePartitionLoadScalingTriggerResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AveragePartitionLoadTrigger'.
func (o AveragePartitionLoadScalingTriggerResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// The lower limit of the load below which a scale in operation should be performed.
func (o AveragePartitionLoadScalingTriggerResponseOutput) LowerLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) float64 { return v.LowerLoadThreshold }).(pulumi.Float64Output)
}

// The name of the metric for which usage should be tracked.
func (o AveragePartitionLoadScalingTriggerResponseOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) string { return v.MetricName }).(pulumi.StringOutput)
}

// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
func (o AveragePartitionLoadScalingTriggerResponseOutput) ScaleInterval() pulumi.StringOutput {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) string { return v.ScaleInterval }).(pulumi.StringOutput)
}

// The upper limit of the load beyond which a scale out operation should be performed.
func (o AveragePartitionLoadScalingTriggerResponseOutput) UpperLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AveragePartitionLoadScalingTriggerResponse) float64 { return v.UpperLoadThreshold }).(pulumi.Float64Output)
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTrigger struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AverageServiceLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
	// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad bool `pulumi:"useOnlyPrimaryLoad"`
}

// AverageServiceLoadScalingTriggerInput is an input type that accepts AverageServiceLoadScalingTriggerArgs and AverageServiceLoadScalingTriggerOutput values.
// You can construct a concrete instance of `AverageServiceLoadScalingTriggerInput` via:
//
//          AverageServiceLoadScalingTriggerArgs{...}
type AverageServiceLoadScalingTriggerInput interface {
	pulumi.Input

	ToAverageServiceLoadScalingTriggerOutput() AverageServiceLoadScalingTriggerOutput
	ToAverageServiceLoadScalingTriggerOutputWithContext(context.Context) AverageServiceLoadScalingTriggerOutput
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AverageServiceLoadTrigger'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold pulumi.Float64Input `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval pulumi.StringInput `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold pulumi.Float64Input `pulumi:"upperLoadThreshold"`
	// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad pulumi.BoolInput `pulumi:"useOnlyPrimaryLoad"`
}

func (AverageServiceLoadScalingTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AverageServiceLoadScalingTrigger)(nil)).Elem()
}

func (i AverageServiceLoadScalingTriggerArgs) ToAverageServiceLoadScalingTriggerOutput() AverageServiceLoadScalingTriggerOutput {
	return i.ToAverageServiceLoadScalingTriggerOutputWithContext(context.Background())
}

func (i AverageServiceLoadScalingTriggerArgs) ToAverageServiceLoadScalingTriggerOutputWithContext(ctx context.Context) AverageServiceLoadScalingTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AverageServiceLoadScalingTriggerOutput)
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerOutput struct{ *pulumi.OutputState }

func (AverageServiceLoadScalingTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AverageServiceLoadScalingTrigger)(nil)).Elem()
}

func (o AverageServiceLoadScalingTriggerOutput) ToAverageServiceLoadScalingTriggerOutput() AverageServiceLoadScalingTriggerOutput {
	return o
}

func (o AverageServiceLoadScalingTriggerOutput) ToAverageServiceLoadScalingTriggerOutputWithContext(ctx context.Context) AverageServiceLoadScalingTriggerOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AverageServiceLoadTrigger'.
func (o AverageServiceLoadScalingTriggerOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) string { return v.Kind }).(pulumi.StringOutput)
}

// The lower limit of the load below which a scale in operation should be performed.
func (o AverageServiceLoadScalingTriggerOutput) LowerLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) float64 { return v.LowerLoadThreshold }).(pulumi.Float64Output)
}

// The name of the metric for which usage should be tracked.
func (o AverageServiceLoadScalingTriggerOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) string { return v.MetricName }).(pulumi.StringOutput)
}

// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
func (o AverageServiceLoadScalingTriggerOutput) ScaleInterval() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) string { return v.ScaleInterval }).(pulumi.StringOutput)
}

// The upper limit of the load beyond which a scale out operation should be performed.
func (o AverageServiceLoadScalingTriggerOutput) UpperLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) float64 { return v.UpperLoadThreshold }).(pulumi.Float64Output)
}

// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
func (o AverageServiceLoadScalingTriggerOutput) UseOnlyPrimaryLoad() pulumi.BoolOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTrigger) bool { return v.UseOnlyPrimaryLoad }).(pulumi.BoolOutput)
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AverageServiceLoadTrigger'.
	Kind string `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold float64 `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName string `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval string `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold float64 `pulumi:"upperLoadThreshold"`
	// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad bool `pulumi:"useOnlyPrimaryLoad"`
}

// AverageServiceLoadScalingTriggerResponseInput is an input type that accepts AverageServiceLoadScalingTriggerResponseArgs and AverageServiceLoadScalingTriggerResponseOutput values.
// You can construct a concrete instance of `AverageServiceLoadScalingTriggerResponseInput` via:
//
//          AverageServiceLoadScalingTriggerResponseArgs{...}
type AverageServiceLoadScalingTriggerResponseInput interface {
	pulumi.Input

	ToAverageServiceLoadScalingTriggerResponseOutput() AverageServiceLoadScalingTriggerResponseOutput
	ToAverageServiceLoadScalingTriggerResponseOutputWithContext(context.Context) AverageServiceLoadScalingTriggerResponseOutput
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerResponseArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'AverageServiceLoadTrigger'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// The lower limit of the load below which a scale in operation should be performed.
	LowerLoadThreshold pulumi.Float64Input `pulumi:"lowerLoadThreshold"`
	// The name of the metric for which usage should be tracked.
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
	ScaleInterval pulumi.StringInput `pulumi:"scaleInterval"`
	// The upper limit of the load beyond which a scale out operation should be performed.
	UpperLoadThreshold pulumi.Float64Input `pulumi:"upperLoadThreshold"`
	// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
	UseOnlyPrimaryLoad pulumi.BoolInput `pulumi:"useOnlyPrimaryLoad"`
}

func (AverageServiceLoadScalingTriggerResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AverageServiceLoadScalingTriggerResponse)(nil)).Elem()
}

func (i AverageServiceLoadScalingTriggerResponseArgs) ToAverageServiceLoadScalingTriggerResponseOutput() AverageServiceLoadScalingTriggerResponseOutput {
	return i.ToAverageServiceLoadScalingTriggerResponseOutputWithContext(context.Background())
}

func (i AverageServiceLoadScalingTriggerResponseArgs) ToAverageServiceLoadScalingTriggerResponseOutputWithContext(ctx context.Context) AverageServiceLoadScalingTriggerResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AverageServiceLoadScalingTriggerResponseOutput)
}

// Represents a scaling policy related to an average load of a metric/resource of a service.
type AverageServiceLoadScalingTriggerResponseOutput struct{ *pulumi.OutputState }

func (AverageServiceLoadScalingTriggerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AverageServiceLoadScalingTriggerResponse)(nil)).Elem()
}

func (o AverageServiceLoadScalingTriggerResponseOutput) ToAverageServiceLoadScalingTriggerResponseOutput() AverageServiceLoadScalingTriggerResponseOutput {
	return o
}

func (o AverageServiceLoadScalingTriggerResponseOutput) ToAverageServiceLoadScalingTriggerResponseOutputWithContext(ctx context.Context) AverageServiceLoadScalingTriggerResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'AverageServiceLoadTrigger'.
func (o AverageServiceLoadScalingTriggerResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// The lower limit of the load below which a scale in operation should be performed.
func (o AverageServiceLoadScalingTriggerResponseOutput) LowerLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) float64 { return v.LowerLoadThreshold }).(pulumi.Float64Output)
}

// The name of the metric for which usage should be tracked.
func (o AverageServiceLoadScalingTriggerResponseOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) string { return v.MetricName }).(pulumi.StringOutput)
}

// The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
func (o AverageServiceLoadScalingTriggerResponseOutput) ScaleInterval() pulumi.StringOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) string { return v.ScaleInterval }).(pulumi.StringOutput)
}

// The upper limit of the load beyond which a scale out operation should be performed.
func (o AverageServiceLoadScalingTriggerResponseOutput) UpperLoadThreshold() pulumi.Float64Output {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) float64 { return v.UpperLoadThreshold }).(pulumi.Float64Output)
}

// Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
func (o AverageServiceLoadScalingTriggerResponseOutput) UseOnlyPrimaryLoad() pulumi.BoolOutput {
	return o.ApplyT(func(v AverageServiceLoadScalingTriggerResponse) bool { return v.UseOnlyPrimaryLoad }).(pulumi.BoolOutput)
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectory struct {
	// Azure active directory client application id.
	ClientApplication *string `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication *string `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId *string `pulumi:"tenantId"`
}

// AzureActiveDirectoryInput is an input type that accepts AzureActiveDirectoryArgs and AzureActiveDirectoryOutput values.
// You can construct a concrete instance of `AzureActiveDirectoryInput` via:
//
//          AzureActiveDirectoryArgs{...}
type AzureActiveDirectoryInput interface {
	pulumi.Input

	ToAzureActiveDirectoryOutput() AzureActiveDirectoryOutput
	ToAzureActiveDirectoryOutputWithContext(context.Context) AzureActiveDirectoryOutput
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryArgs struct {
	// Azure active directory client application id.
	ClientApplication pulumi.StringPtrInput `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication pulumi.StringPtrInput `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId pulumi.StringPtrInput `pulumi:"tenantId"`
}

func (AzureActiveDirectoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectory)(nil)).Elem()
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryOutput() AzureActiveDirectoryOutput {
	return i.ToAzureActiveDirectoryOutputWithContext(context.Background())
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryOutputWithContext(ctx context.Context) AzureActiveDirectoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryOutput)
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return i.ToAzureActiveDirectoryPtrOutputWithContext(context.Background())
}

func (i AzureActiveDirectoryArgs) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryOutput).ToAzureActiveDirectoryPtrOutputWithContext(ctx)
}

// AzureActiveDirectoryPtrInput is an input type that accepts AzureActiveDirectoryArgs, AzureActiveDirectoryPtr and AzureActiveDirectoryPtrOutput values.
// You can construct a concrete instance of `AzureActiveDirectoryPtrInput` via:
//
//          AzureActiveDirectoryArgs{...}
//
//  or:
//
//          nil
type AzureActiveDirectoryPtrInput interface {
	pulumi.Input

	ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput
	ToAzureActiveDirectoryPtrOutputWithContext(context.Context) AzureActiveDirectoryPtrOutput
}

type azureActiveDirectoryPtrType AzureActiveDirectoryArgs

func AzureActiveDirectoryPtr(v *AzureActiveDirectoryArgs) AzureActiveDirectoryPtrInput {
	return (*azureActiveDirectoryPtrType)(v)
}

func (*azureActiveDirectoryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectory)(nil)).Elem()
}

func (i *azureActiveDirectoryPtrType) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return i.ToAzureActiveDirectoryPtrOutputWithContext(context.Background())
}

func (i *azureActiveDirectoryPtrType) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryPtrOutput)
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectory)(nil)).Elem()
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryOutput() AzureActiveDirectoryOutput {
	return o
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryOutputWithContext(ctx context.Context) AzureActiveDirectoryOutput {
	return o
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return o.ToAzureActiveDirectoryPtrOutputWithContext(context.Background())
}

func (o AzureActiveDirectoryOutput) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *AzureActiveDirectory {
		return &v
	}).(AzureActiveDirectoryPtrOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *string { return v.ClientApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *string { return v.ClusterApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectory) *string { return v.TenantId }).(pulumi.StringPtrOutput)
}

type AzureActiveDirectoryPtrOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectory)(nil)).Elem()
}

func (o AzureActiveDirectoryPtrOutput) ToAzureActiveDirectoryPtrOutput() AzureActiveDirectoryPtrOutput {
	return o
}

func (o AzureActiveDirectoryPtrOutput) ToAzureActiveDirectoryPtrOutputWithContext(ctx context.Context) AzureActiveDirectoryPtrOutput {
	return o
}

func (o AzureActiveDirectoryPtrOutput) Elem() AzureActiveDirectoryOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) AzureActiveDirectory { return *v }).(AzureActiveDirectoryOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryPtrOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) *string {
		if v == nil {
			return nil
		}
		return v.ClientApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryPtrOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) *string {
		if v == nil {
			return nil
		}
		return v.ClusterApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryPtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectory) *string {
		if v == nil {
			return nil
		}
		return v.TenantId
	}).(pulumi.StringPtrOutput)
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryResponse struct {
	// Azure active directory client application id.
	ClientApplication *string `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication *string `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId *string `pulumi:"tenantId"`
}

// AzureActiveDirectoryResponseInput is an input type that accepts AzureActiveDirectoryResponseArgs and AzureActiveDirectoryResponseOutput values.
// You can construct a concrete instance of `AzureActiveDirectoryResponseInput` via:
//
//          AzureActiveDirectoryResponseArgs{...}
type AzureActiveDirectoryResponseInput interface {
	pulumi.Input

	ToAzureActiveDirectoryResponseOutput() AzureActiveDirectoryResponseOutput
	ToAzureActiveDirectoryResponseOutputWithContext(context.Context) AzureActiveDirectoryResponseOutput
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryResponseArgs struct {
	// Azure active directory client application id.
	ClientApplication pulumi.StringPtrInput `pulumi:"clientApplication"`
	// Azure active directory cluster application id.
	ClusterApplication pulumi.StringPtrInput `pulumi:"clusterApplication"`
	// Azure active directory tenant id.
	TenantId pulumi.StringPtrInput `pulumi:"tenantId"`
}

func (AzureActiveDirectoryResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectoryResponse)(nil)).Elem()
}

func (i AzureActiveDirectoryResponseArgs) ToAzureActiveDirectoryResponseOutput() AzureActiveDirectoryResponseOutput {
	return i.ToAzureActiveDirectoryResponseOutputWithContext(context.Background())
}

func (i AzureActiveDirectoryResponseArgs) ToAzureActiveDirectoryResponseOutputWithContext(ctx context.Context) AzureActiveDirectoryResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryResponseOutput)
}

func (i AzureActiveDirectoryResponseArgs) ToAzureActiveDirectoryResponsePtrOutput() AzureActiveDirectoryResponsePtrOutput {
	return i.ToAzureActiveDirectoryResponsePtrOutputWithContext(context.Background())
}

func (i AzureActiveDirectoryResponseArgs) ToAzureActiveDirectoryResponsePtrOutputWithContext(ctx context.Context) AzureActiveDirectoryResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryResponseOutput).ToAzureActiveDirectoryResponsePtrOutputWithContext(ctx)
}

// AzureActiveDirectoryResponsePtrInput is an input type that accepts AzureActiveDirectoryResponseArgs, AzureActiveDirectoryResponsePtr and AzureActiveDirectoryResponsePtrOutput values.
// You can construct a concrete instance of `AzureActiveDirectoryResponsePtrInput` via:
//
//          AzureActiveDirectoryResponseArgs{...}
//
//  or:
//
//          nil
type AzureActiveDirectoryResponsePtrInput interface {
	pulumi.Input

	ToAzureActiveDirectoryResponsePtrOutput() AzureActiveDirectoryResponsePtrOutput
	ToAzureActiveDirectoryResponsePtrOutputWithContext(context.Context) AzureActiveDirectoryResponsePtrOutput
}

type azureActiveDirectoryResponsePtrType AzureActiveDirectoryResponseArgs

func AzureActiveDirectoryResponsePtr(v *AzureActiveDirectoryResponseArgs) AzureActiveDirectoryResponsePtrInput {
	return (*azureActiveDirectoryResponsePtrType)(v)
}

func (*azureActiveDirectoryResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectoryResponse)(nil)).Elem()
}

func (i *azureActiveDirectoryResponsePtrType) ToAzureActiveDirectoryResponsePtrOutput() AzureActiveDirectoryResponsePtrOutput {
	return i.ToAzureActiveDirectoryResponsePtrOutputWithContext(context.Background())
}

func (i *azureActiveDirectoryResponsePtrType) ToAzureActiveDirectoryResponsePtrOutputWithContext(ctx context.Context) AzureActiveDirectoryResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AzureActiveDirectoryResponsePtrOutput)
}

// The settings to enable AAD authentication on the cluster.
type AzureActiveDirectoryResponseOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AzureActiveDirectoryResponse)(nil)).Elem()
}

func (o AzureActiveDirectoryResponseOutput) ToAzureActiveDirectoryResponseOutput() AzureActiveDirectoryResponseOutput {
	return o
}

func (o AzureActiveDirectoryResponseOutput) ToAzureActiveDirectoryResponseOutputWithContext(ctx context.Context) AzureActiveDirectoryResponseOutput {
	return o
}

func (o AzureActiveDirectoryResponseOutput) ToAzureActiveDirectoryResponsePtrOutput() AzureActiveDirectoryResponsePtrOutput {
	return o.ToAzureActiveDirectoryResponsePtrOutputWithContext(context.Background())
}

func (o AzureActiveDirectoryResponseOutput) ToAzureActiveDirectoryResponsePtrOutputWithContext(ctx context.Context) AzureActiveDirectoryResponsePtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *AzureActiveDirectoryResponse {
		return &v
	}).(AzureActiveDirectoryResponsePtrOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryResponseOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *string { return v.ClientApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryResponseOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *string { return v.ClusterApplication }).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryResponseOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AzureActiveDirectoryResponse) *string { return v.TenantId }).(pulumi.StringPtrOutput)
}

type AzureActiveDirectoryResponsePtrOutput struct{ *pulumi.OutputState }

func (AzureActiveDirectoryResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AzureActiveDirectoryResponse)(nil)).Elem()
}

func (o AzureActiveDirectoryResponsePtrOutput) ToAzureActiveDirectoryResponsePtrOutput() AzureActiveDirectoryResponsePtrOutput {
	return o
}

func (o AzureActiveDirectoryResponsePtrOutput) ToAzureActiveDirectoryResponsePtrOutputWithContext(ctx context.Context) AzureActiveDirectoryResponsePtrOutput {
	return o
}

func (o AzureActiveDirectoryResponsePtrOutput) Elem() AzureActiveDirectoryResponseOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) AzureActiveDirectoryResponse { return *v }).(AzureActiveDirectoryResponseOutput)
}

// Azure active directory client application id.
func (o AzureActiveDirectoryResponsePtrOutput) ClientApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) *string {
		if v == nil {
			return nil
		}
		return v.ClientApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory cluster application id.
func (o AzureActiveDirectoryResponsePtrOutput) ClusterApplication() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) *string {
		if v == nil {
			return nil
		}
		return v.ClusterApplication
	}).(pulumi.StringPtrOutput)
}

// Azure active directory tenant id.
func (o AzureActiveDirectoryResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AzureActiveDirectoryResponse) *string {
		if v == nil {
			return nil
		}
		return v.TenantId
	}).(pulumi.StringPtrOutput)
}

// Client certificate definition.
type ClientCertificate struct {
	// Certificate common name.
	CommonName *string `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin bool `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint *string `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint *string `pulumi:"thumbprint"`
}

// ClientCertificateInput is an input type that accepts ClientCertificateArgs and ClientCertificateOutput values.
// You can construct a concrete instance of `ClientCertificateInput` via:
//
//          ClientCertificateArgs{...}
type ClientCertificateInput interface {
	pulumi.Input

	ToClientCertificateOutput() ClientCertificateOutput
	ToClientCertificateOutputWithContext(context.Context) ClientCertificateOutput
}

// Client certificate definition.
type ClientCertificateArgs struct {
	// Certificate common name.
	CommonName pulumi.StringPtrInput `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin pulumi.BoolInput `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint pulumi.StringPtrInput `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint pulumi.StringPtrInput `pulumi:"thumbprint"`
}

func (ClientCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificate)(nil)).Elem()
}

func (i ClientCertificateArgs) ToClientCertificateOutput() ClientCertificateOutput {
	return i.ToClientCertificateOutputWithContext(context.Background())
}

func (i ClientCertificateArgs) ToClientCertificateOutputWithContext(ctx context.Context) ClientCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientCertificateOutput)
}

// ClientCertificateArrayInput is an input type that accepts ClientCertificateArray and ClientCertificateArrayOutput values.
// You can construct a concrete instance of `ClientCertificateArrayInput` via:
//
//          ClientCertificateArray{ ClientCertificateArgs{...} }
type ClientCertificateArrayInput interface {
	pulumi.Input

	ToClientCertificateArrayOutput() ClientCertificateArrayOutput
	ToClientCertificateArrayOutputWithContext(context.Context) ClientCertificateArrayOutput
}

type ClientCertificateArray []ClientCertificateInput

func (ClientCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificate)(nil)).Elem()
}

func (i ClientCertificateArray) ToClientCertificateArrayOutput() ClientCertificateArrayOutput {
	return i.ToClientCertificateArrayOutputWithContext(context.Background())
}

func (i ClientCertificateArray) ToClientCertificateArrayOutputWithContext(ctx context.Context) ClientCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientCertificateArrayOutput)
}

// Client certificate definition.
type ClientCertificateOutput struct{ *pulumi.OutputState }

func (ClientCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificate)(nil)).Elem()
}

func (o ClientCertificateOutput) ToClientCertificateOutput() ClientCertificateOutput {
	return o
}

func (o ClientCertificateOutput) ToClientCertificateOutputWithContext(ctx context.Context) ClientCertificateOutput {
	return o
}

// Certificate common name.
func (o ClientCertificateOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificate) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
func (o ClientCertificateOutput) IsAdmin() pulumi.BoolOutput {
	return o.ApplyT(func(v ClientCertificate) bool { return v.IsAdmin }).(pulumi.BoolOutput)
}

// Issuer thumbprint for the certificate. Only used together with CommonName.
func (o ClientCertificateOutput) IssuerThumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificate) *string { return v.IssuerThumbprint }).(pulumi.StringPtrOutput)
}

// Certificate thumbprint.
func (o ClientCertificateOutput) Thumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificate) *string { return v.Thumbprint }).(pulumi.StringPtrOutput)
}

type ClientCertificateArrayOutput struct{ *pulumi.OutputState }

func (ClientCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificate)(nil)).Elem()
}

func (o ClientCertificateArrayOutput) ToClientCertificateArrayOutput() ClientCertificateArrayOutput {
	return o
}

func (o ClientCertificateArrayOutput) ToClientCertificateArrayOutputWithContext(ctx context.Context) ClientCertificateArrayOutput {
	return o
}

func (o ClientCertificateArrayOutput) Index(i pulumi.IntInput) ClientCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClientCertificate {
		return vs[0].([]ClientCertificate)[vs[1].(int)]
	}).(ClientCertificateOutput)
}

// Client certificate definition.
type ClientCertificateResponse struct {
	// Certificate common name.
	CommonName *string `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin bool `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint *string `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint *string `pulumi:"thumbprint"`
}

// ClientCertificateResponseInput is an input type that accepts ClientCertificateResponseArgs and ClientCertificateResponseOutput values.
// You can construct a concrete instance of `ClientCertificateResponseInput` via:
//
//          ClientCertificateResponseArgs{...}
type ClientCertificateResponseInput interface {
	pulumi.Input

	ToClientCertificateResponseOutput() ClientCertificateResponseOutput
	ToClientCertificateResponseOutputWithContext(context.Context) ClientCertificateResponseOutput
}

// Client certificate definition.
type ClientCertificateResponseArgs struct {
	// Certificate common name.
	CommonName pulumi.StringPtrInput `pulumi:"commonName"`
	// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
	IsAdmin pulumi.BoolInput `pulumi:"isAdmin"`
	// Issuer thumbprint for the certificate. Only used together with CommonName.
	IssuerThumbprint pulumi.StringPtrInput `pulumi:"issuerThumbprint"`
	// Certificate thumbprint.
	Thumbprint pulumi.StringPtrInput `pulumi:"thumbprint"`
}

func (ClientCertificateResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificateResponse)(nil)).Elem()
}

func (i ClientCertificateResponseArgs) ToClientCertificateResponseOutput() ClientCertificateResponseOutput {
	return i.ToClientCertificateResponseOutputWithContext(context.Background())
}

func (i ClientCertificateResponseArgs) ToClientCertificateResponseOutputWithContext(ctx context.Context) ClientCertificateResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientCertificateResponseOutput)
}

// ClientCertificateResponseArrayInput is an input type that accepts ClientCertificateResponseArray and ClientCertificateResponseArrayOutput values.
// You can construct a concrete instance of `ClientCertificateResponseArrayInput` via:
//
//          ClientCertificateResponseArray{ ClientCertificateResponseArgs{...} }
type ClientCertificateResponseArrayInput interface {
	pulumi.Input

	ToClientCertificateResponseArrayOutput() ClientCertificateResponseArrayOutput
	ToClientCertificateResponseArrayOutputWithContext(context.Context) ClientCertificateResponseArrayOutput
}

type ClientCertificateResponseArray []ClientCertificateResponseInput

func (ClientCertificateResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificateResponse)(nil)).Elem()
}

func (i ClientCertificateResponseArray) ToClientCertificateResponseArrayOutput() ClientCertificateResponseArrayOutput {
	return i.ToClientCertificateResponseArrayOutputWithContext(context.Background())
}

func (i ClientCertificateResponseArray) ToClientCertificateResponseArrayOutputWithContext(ctx context.Context) ClientCertificateResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientCertificateResponseArrayOutput)
}

// Client certificate definition.
type ClientCertificateResponseOutput struct{ *pulumi.OutputState }

func (ClientCertificateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientCertificateResponse)(nil)).Elem()
}

func (o ClientCertificateResponseOutput) ToClientCertificateResponseOutput() ClientCertificateResponseOutput {
	return o
}

func (o ClientCertificateResponseOutput) ToClientCertificateResponseOutputWithContext(ctx context.Context) ClientCertificateResponseOutput {
	return o
}

// Certificate common name.
func (o ClientCertificateResponseOutput) CommonName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificateResponse) *string { return v.CommonName }).(pulumi.StringPtrOutput)
}

// Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
func (o ClientCertificateResponseOutput) IsAdmin() pulumi.BoolOutput {
	return o.ApplyT(func(v ClientCertificateResponse) bool { return v.IsAdmin }).(pulumi.BoolOutput)
}

// Issuer thumbprint for the certificate. Only used together with CommonName.
func (o ClientCertificateResponseOutput) IssuerThumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificateResponse) *string { return v.IssuerThumbprint }).(pulumi.StringPtrOutput)
}

// Certificate thumbprint.
func (o ClientCertificateResponseOutput) Thumbprint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientCertificateResponse) *string { return v.Thumbprint }).(pulumi.StringPtrOutput)
}

type ClientCertificateResponseArrayOutput struct{ *pulumi.OutputState }

func (ClientCertificateResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClientCertificateResponse)(nil)).Elem()
}

func (o ClientCertificateResponseArrayOutput) ToClientCertificateResponseArrayOutput() ClientCertificateResponseArrayOutput {
	return o
}

func (o ClientCertificateResponseArrayOutput) ToClientCertificateResponseArrayOutputWithContext(ctx context.Context) ClientCertificateResponseArrayOutput {
	return o
}

func (o ClientCertificateResponseArrayOutput) Index(i pulumi.IntInput) ClientCertificateResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClientCertificateResponse {
		return vs[0].([]ClientCertificateResponse)[vs[1].(int)]
	}).(ClientCertificateResponseOutput)
}

// Port range details
type EndpointRangeDescription struct {
	// End port of a range of ports
	EndPort int `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort int `pulumi:"startPort"`
}

// EndpointRangeDescriptionInput is an input type that accepts EndpointRangeDescriptionArgs and EndpointRangeDescriptionOutput values.
// You can construct a concrete instance of `EndpointRangeDescriptionInput` via:
//
//          EndpointRangeDescriptionArgs{...}
type EndpointRangeDescriptionInput interface {
	pulumi.Input

	ToEndpointRangeDescriptionOutput() EndpointRangeDescriptionOutput
	ToEndpointRangeDescriptionOutputWithContext(context.Context) EndpointRangeDescriptionOutput
}

// Port range details
type EndpointRangeDescriptionArgs struct {
	// End port of a range of ports
	EndPort pulumi.IntInput `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort pulumi.IntInput `pulumi:"startPort"`
}

func (EndpointRangeDescriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescription)(nil)).Elem()
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionOutput() EndpointRangeDescriptionOutput {
	return i.ToEndpointRangeDescriptionOutputWithContext(context.Background())
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionOutputWithContext(ctx context.Context) EndpointRangeDescriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionOutput)
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return i.ToEndpointRangeDescriptionPtrOutputWithContext(context.Background())
}

func (i EndpointRangeDescriptionArgs) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionOutput).ToEndpointRangeDescriptionPtrOutputWithContext(ctx)
}

// EndpointRangeDescriptionPtrInput is an input type that accepts EndpointRangeDescriptionArgs, EndpointRangeDescriptionPtr and EndpointRangeDescriptionPtrOutput values.
// You can construct a concrete instance of `EndpointRangeDescriptionPtrInput` via:
//
//          EndpointRangeDescriptionArgs{...}
//
//  or:
//
//          nil
type EndpointRangeDescriptionPtrInput interface {
	pulumi.Input

	ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput
	ToEndpointRangeDescriptionPtrOutputWithContext(context.Context) EndpointRangeDescriptionPtrOutput
}

type endpointRangeDescriptionPtrType EndpointRangeDescriptionArgs

func EndpointRangeDescriptionPtr(v *EndpointRangeDescriptionArgs) EndpointRangeDescriptionPtrInput {
	return (*endpointRangeDescriptionPtrType)(v)
}

func (*endpointRangeDescriptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescription)(nil)).Elem()
}

func (i *endpointRangeDescriptionPtrType) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return i.ToEndpointRangeDescriptionPtrOutputWithContext(context.Background())
}

func (i *endpointRangeDescriptionPtrType) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionPtrOutput)
}

// Port range details
type EndpointRangeDescriptionOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescription)(nil)).Elem()
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionOutput() EndpointRangeDescriptionOutput {
	return o
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionOutputWithContext(ctx context.Context) EndpointRangeDescriptionOutput {
	return o
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return o.ToEndpointRangeDescriptionPtrOutputWithContext(context.Background())
}

func (o EndpointRangeDescriptionOutput) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return o.ApplyT(func(v EndpointRangeDescription) *EndpointRangeDescription {
		return &v
	}).(EndpointRangeDescriptionPtrOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionOutput) EndPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescription) int { return v.EndPort }).(pulumi.IntOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionOutput) StartPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescription) int { return v.StartPort }).(pulumi.IntOutput)
}

type EndpointRangeDescriptionPtrOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescription)(nil)).Elem()
}

func (o EndpointRangeDescriptionPtrOutput) ToEndpointRangeDescriptionPtrOutput() EndpointRangeDescriptionPtrOutput {
	return o
}

func (o EndpointRangeDescriptionPtrOutput) ToEndpointRangeDescriptionPtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionPtrOutput {
	return o
}

func (o EndpointRangeDescriptionPtrOutput) Elem() EndpointRangeDescriptionOutput {
	return o.ApplyT(func(v *EndpointRangeDescription) EndpointRangeDescription { return *v }).(EndpointRangeDescriptionOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionPtrOutput) EndPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescription) *int {
		if v == nil {
			return nil
		}
		return &v.EndPort
	}).(pulumi.IntPtrOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionPtrOutput) StartPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescription) *int {
		if v == nil {
			return nil
		}
		return &v.StartPort
	}).(pulumi.IntPtrOutput)
}

// Port range details
type EndpointRangeDescriptionResponse struct {
	// End port of a range of ports
	EndPort int `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort int `pulumi:"startPort"`
}

// EndpointRangeDescriptionResponseInput is an input type that accepts EndpointRangeDescriptionResponseArgs and EndpointRangeDescriptionResponseOutput values.
// You can construct a concrete instance of `EndpointRangeDescriptionResponseInput` via:
//
//          EndpointRangeDescriptionResponseArgs{...}
type EndpointRangeDescriptionResponseInput interface {
	pulumi.Input

	ToEndpointRangeDescriptionResponseOutput() EndpointRangeDescriptionResponseOutput
	ToEndpointRangeDescriptionResponseOutputWithContext(context.Context) EndpointRangeDescriptionResponseOutput
}

// Port range details
type EndpointRangeDescriptionResponseArgs struct {
	// End port of a range of ports
	EndPort pulumi.IntInput `pulumi:"endPort"`
	// Starting port of a range of ports
	StartPort pulumi.IntInput `pulumi:"startPort"`
}

func (EndpointRangeDescriptionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescriptionResponse)(nil)).Elem()
}

func (i EndpointRangeDescriptionResponseArgs) ToEndpointRangeDescriptionResponseOutput() EndpointRangeDescriptionResponseOutput {
	return i.ToEndpointRangeDescriptionResponseOutputWithContext(context.Background())
}

func (i EndpointRangeDescriptionResponseArgs) ToEndpointRangeDescriptionResponseOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionResponseOutput)
}

func (i EndpointRangeDescriptionResponseArgs) ToEndpointRangeDescriptionResponsePtrOutput() EndpointRangeDescriptionResponsePtrOutput {
	return i.ToEndpointRangeDescriptionResponsePtrOutputWithContext(context.Background())
}

func (i EndpointRangeDescriptionResponseArgs) ToEndpointRangeDescriptionResponsePtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionResponseOutput).ToEndpointRangeDescriptionResponsePtrOutputWithContext(ctx)
}

// EndpointRangeDescriptionResponsePtrInput is an input type that accepts EndpointRangeDescriptionResponseArgs, EndpointRangeDescriptionResponsePtr and EndpointRangeDescriptionResponsePtrOutput values.
// You can construct a concrete instance of `EndpointRangeDescriptionResponsePtrInput` via:
//
//          EndpointRangeDescriptionResponseArgs{...}
//
//  or:
//
//          nil
type EndpointRangeDescriptionResponsePtrInput interface {
	pulumi.Input

	ToEndpointRangeDescriptionResponsePtrOutput() EndpointRangeDescriptionResponsePtrOutput
	ToEndpointRangeDescriptionResponsePtrOutputWithContext(context.Context) EndpointRangeDescriptionResponsePtrOutput
}

type endpointRangeDescriptionResponsePtrType EndpointRangeDescriptionResponseArgs

func EndpointRangeDescriptionResponsePtr(v *EndpointRangeDescriptionResponseArgs) EndpointRangeDescriptionResponsePtrInput {
	return (*endpointRangeDescriptionResponsePtrType)(v)
}

func (*endpointRangeDescriptionResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescriptionResponse)(nil)).Elem()
}

func (i *endpointRangeDescriptionResponsePtrType) ToEndpointRangeDescriptionResponsePtrOutput() EndpointRangeDescriptionResponsePtrOutput {
	return i.ToEndpointRangeDescriptionResponsePtrOutputWithContext(context.Background())
}

func (i *endpointRangeDescriptionResponsePtrType) ToEndpointRangeDescriptionResponsePtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointRangeDescriptionResponsePtrOutput)
}

// Port range details
type EndpointRangeDescriptionResponseOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointRangeDescriptionResponse)(nil)).Elem()
}

func (o EndpointRangeDescriptionResponseOutput) ToEndpointRangeDescriptionResponseOutput() EndpointRangeDescriptionResponseOutput {
	return o
}

func (o EndpointRangeDescriptionResponseOutput) ToEndpointRangeDescriptionResponseOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponseOutput {
	return o
}

func (o EndpointRangeDescriptionResponseOutput) ToEndpointRangeDescriptionResponsePtrOutput() EndpointRangeDescriptionResponsePtrOutput {
	return o.ToEndpointRangeDescriptionResponsePtrOutputWithContext(context.Background())
}

func (o EndpointRangeDescriptionResponseOutput) ToEndpointRangeDescriptionResponsePtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponsePtrOutput {
	return o.ApplyT(func(v EndpointRangeDescriptionResponse) *EndpointRangeDescriptionResponse {
		return &v
	}).(EndpointRangeDescriptionResponsePtrOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionResponseOutput) EndPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescriptionResponse) int { return v.EndPort }).(pulumi.IntOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionResponseOutput) StartPort() pulumi.IntOutput {
	return o.ApplyT(func(v EndpointRangeDescriptionResponse) int { return v.StartPort }).(pulumi.IntOutput)
}

type EndpointRangeDescriptionResponsePtrOutput struct{ *pulumi.OutputState }

func (EndpointRangeDescriptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointRangeDescriptionResponse)(nil)).Elem()
}

func (o EndpointRangeDescriptionResponsePtrOutput) ToEndpointRangeDescriptionResponsePtrOutput() EndpointRangeDescriptionResponsePtrOutput {
	return o
}

func (o EndpointRangeDescriptionResponsePtrOutput) ToEndpointRangeDescriptionResponsePtrOutputWithContext(ctx context.Context) EndpointRangeDescriptionResponsePtrOutput {
	return o
}

func (o EndpointRangeDescriptionResponsePtrOutput) Elem() EndpointRangeDescriptionResponseOutput {
	return o.ApplyT(func(v *EndpointRangeDescriptionResponse) EndpointRangeDescriptionResponse { return *v }).(EndpointRangeDescriptionResponseOutput)
}

// End port of a range of ports
func (o EndpointRangeDescriptionResponsePtrOutput) EndPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescriptionResponse) *int {
		if v == nil {
			return nil
		}
		return &v.EndPort
	}).(pulumi.IntPtrOutput)
}

// Starting port of a range of ports
func (o EndpointRangeDescriptionResponsePtrOutput) StartPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *EndpointRangeDescriptionResponse) *int {
		if v == nil {
			return nil
		}
		return &v.StartPort
	}).(pulumi.IntPtrOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfiguration struct {
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType *string `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId *string `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId *string `pulumi:"loadBalancerInboundNatPoolId"`
}

// FrontendConfigurationInput is an input type that accepts FrontendConfigurationArgs and FrontendConfigurationOutput values.
// You can construct a concrete instance of `FrontendConfigurationInput` via:
//
//          FrontendConfigurationArgs{...}
type FrontendConfigurationInput interface {
	pulumi.Input

	ToFrontendConfigurationOutput() FrontendConfigurationOutput
	ToFrontendConfigurationOutputWithContext(context.Context) FrontendConfigurationOutput
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationArgs struct {
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType pulumi.StringPtrInput `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId pulumi.StringPtrInput `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId pulumi.StringPtrInput `pulumi:"loadBalancerInboundNatPoolId"`
}

func (FrontendConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfiguration)(nil)).Elem()
}

func (i FrontendConfigurationArgs) ToFrontendConfigurationOutput() FrontendConfigurationOutput {
	return i.ToFrontendConfigurationOutputWithContext(context.Background())
}

func (i FrontendConfigurationArgs) ToFrontendConfigurationOutputWithContext(ctx context.Context) FrontendConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FrontendConfigurationOutput)
}

// FrontendConfigurationArrayInput is an input type that accepts FrontendConfigurationArray and FrontendConfigurationArrayOutput values.
// You can construct a concrete instance of `FrontendConfigurationArrayInput` via:
//
//          FrontendConfigurationArray{ FrontendConfigurationArgs{...} }
type FrontendConfigurationArrayInput interface {
	pulumi.Input

	ToFrontendConfigurationArrayOutput() FrontendConfigurationArrayOutput
	ToFrontendConfigurationArrayOutputWithContext(context.Context) FrontendConfigurationArrayOutput
}

type FrontendConfigurationArray []FrontendConfigurationInput

func (FrontendConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfiguration)(nil)).Elem()
}

func (i FrontendConfigurationArray) ToFrontendConfigurationArrayOutput() FrontendConfigurationArrayOutput {
	return i.ToFrontendConfigurationArrayOutputWithContext(context.Background())
}

func (i FrontendConfigurationArray) ToFrontendConfigurationArrayOutputWithContext(ctx context.Context) FrontendConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FrontendConfigurationArrayOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfiguration)(nil)).Elem()
}

func (o FrontendConfigurationOutput) ToFrontendConfigurationOutput() FrontendConfigurationOutput {
	return o
}

func (o FrontendConfigurationOutput) ToFrontendConfigurationOutputWithContext(ctx context.Context) FrontendConfigurationOutput {
	return o
}

// The IP address type of this frontend configuration. If omitted the default value is IPv4.
func (o FrontendConfigurationOutput) IpAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.IpAddressType }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
func (o FrontendConfigurationOutput) LoadBalancerBackendAddressPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.LoadBalancerBackendAddressPoolId }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
func (o FrontendConfigurationOutput) LoadBalancerInboundNatPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfiguration) *string { return v.LoadBalancerInboundNatPoolId }).(pulumi.StringPtrOutput)
}

type FrontendConfigurationArrayOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfiguration)(nil)).Elem()
}

func (o FrontendConfigurationArrayOutput) ToFrontendConfigurationArrayOutput() FrontendConfigurationArrayOutput {
	return o
}

func (o FrontendConfigurationArrayOutput) ToFrontendConfigurationArrayOutputWithContext(ctx context.Context) FrontendConfigurationArrayOutput {
	return o
}

func (o FrontendConfigurationArrayOutput) Index(i pulumi.IntInput) FrontendConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FrontendConfiguration {
		return vs[0].([]FrontendConfiguration)[vs[1].(int)]
	}).(FrontendConfigurationOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationResponse struct {
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType *string `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId *string `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId *string `pulumi:"loadBalancerInboundNatPoolId"`
}

// FrontendConfigurationResponseInput is an input type that accepts FrontendConfigurationResponseArgs and FrontendConfigurationResponseOutput values.
// You can construct a concrete instance of `FrontendConfigurationResponseInput` via:
//
//          FrontendConfigurationResponseArgs{...}
type FrontendConfigurationResponseInput interface {
	pulumi.Input

	ToFrontendConfigurationResponseOutput() FrontendConfigurationResponseOutput
	ToFrontendConfigurationResponseOutputWithContext(context.Context) FrontendConfigurationResponseOutput
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationResponseArgs struct {
	// The IP address type of this frontend configuration. If omitted the default value is IPv4.
	IpAddressType pulumi.StringPtrInput `pulumi:"ipAddressType"`
	// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
	LoadBalancerBackendAddressPoolId pulumi.StringPtrInput `pulumi:"loadBalancerBackendAddressPoolId"`
	// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
	LoadBalancerInboundNatPoolId pulumi.StringPtrInput `pulumi:"loadBalancerInboundNatPoolId"`
}

func (FrontendConfigurationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfigurationResponse)(nil)).Elem()
}

func (i FrontendConfigurationResponseArgs) ToFrontendConfigurationResponseOutput() FrontendConfigurationResponseOutput {
	return i.ToFrontendConfigurationResponseOutputWithContext(context.Background())
}

func (i FrontendConfigurationResponseArgs) ToFrontendConfigurationResponseOutputWithContext(ctx context.Context) FrontendConfigurationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FrontendConfigurationResponseOutput)
}

// FrontendConfigurationResponseArrayInput is an input type that accepts FrontendConfigurationResponseArray and FrontendConfigurationResponseArrayOutput values.
// You can construct a concrete instance of `FrontendConfigurationResponseArrayInput` via:
//
//          FrontendConfigurationResponseArray{ FrontendConfigurationResponseArgs{...} }
type FrontendConfigurationResponseArrayInput interface {
	pulumi.Input

	ToFrontendConfigurationResponseArrayOutput() FrontendConfigurationResponseArrayOutput
	ToFrontendConfigurationResponseArrayOutputWithContext(context.Context) FrontendConfigurationResponseArrayOutput
}

type FrontendConfigurationResponseArray []FrontendConfigurationResponseInput

func (FrontendConfigurationResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfigurationResponse)(nil)).Elem()
}

func (i FrontendConfigurationResponseArray) ToFrontendConfigurationResponseArrayOutput() FrontendConfigurationResponseArrayOutput {
	return i.ToFrontendConfigurationResponseArrayOutputWithContext(context.Background())
}

func (i FrontendConfigurationResponseArray) ToFrontendConfigurationResponseArrayOutputWithContext(ctx context.Context) FrontendConfigurationResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FrontendConfigurationResponseArrayOutput)
}

// Describes the frontend configurations for the node type.
type FrontendConfigurationResponseOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FrontendConfigurationResponse)(nil)).Elem()
}

func (o FrontendConfigurationResponseOutput) ToFrontendConfigurationResponseOutput() FrontendConfigurationResponseOutput {
	return o
}

func (o FrontendConfigurationResponseOutput) ToFrontendConfigurationResponseOutputWithContext(ctx context.Context) FrontendConfigurationResponseOutput {
	return o
}

// The IP address type of this frontend configuration. If omitted the default value is IPv4.
func (o FrontendConfigurationResponseOutput) IpAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.IpAddressType }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
func (o FrontendConfigurationResponseOutput) LoadBalancerBackendAddressPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.LoadBalancerBackendAddressPoolId }).(pulumi.StringPtrOutput)
}

// The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
func (o FrontendConfigurationResponseOutput) LoadBalancerInboundNatPoolId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FrontendConfigurationResponse) *string { return v.LoadBalancerInboundNatPoolId }).(pulumi.StringPtrOutput)
}

type FrontendConfigurationResponseArrayOutput struct{ *pulumi.OutputState }

func (FrontendConfigurationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FrontendConfigurationResponse)(nil)).Elem()
}

func (o FrontendConfigurationResponseArrayOutput) ToFrontendConfigurationResponseArrayOutput() FrontendConfigurationResponseArrayOutput {
	return o
}

func (o FrontendConfigurationResponseArrayOutput) ToFrontendConfigurationResponseArrayOutputWithContext(ctx context.Context) FrontendConfigurationResponseArrayOutput {
	return o
}

func (o FrontendConfigurationResponseArrayOutput) Index(i pulumi.IntInput) FrontendConfigurationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FrontendConfigurationResponse {
		return vs[0].([]FrontendConfigurationResponse)[vs[1].(int)]
	}).(FrontendConfigurationResponseOutput)
}

// IPTag associated with the object.
type IPTag struct {
	// The IP tag type.
	IpTagType string `pulumi:"ipTagType"`
	// The value of the IP tag.
	Tag string `pulumi:"tag"`
}

// IPTagInput is an input type that accepts IPTagArgs and IPTagOutput values.
// You can construct a concrete instance of `IPTagInput` via:
//
//          IPTagArgs{...}
type IPTagInput interface {
	pulumi.Input

	ToIPTagOutput() IPTagOutput
	ToIPTagOutputWithContext(context.Context) IPTagOutput
}

// IPTag associated with the object.
type IPTagArgs struct {
	// The IP tag type.
	IpTagType pulumi.StringInput `pulumi:"ipTagType"`
	// The value of the IP tag.
	Tag pulumi.StringInput `pulumi:"tag"`
}

func (IPTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IPTag)(nil)).Elem()
}

func (i IPTagArgs) ToIPTagOutput() IPTagOutput {
	return i.ToIPTagOutputWithContext(context.Background())
}

func (i IPTagArgs) ToIPTagOutputWithContext(ctx context.Context) IPTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPTagOutput)
}

// IPTagArrayInput is an input type that accepts IPTagArray and IPTagArrayOutput values.
// You can construct a concrete instance of `IPTagArrayInput` via:
//
//          IPTagArray{ IPTagArgs{...} }
type IPTagArrayInput interface {
	pulumi.Input

	ToIPTagArrayOutput() IPTagArrayOutput
	ToIPTagArrayOutputWithContext(context.Context) IPTagArrayOutput
}

type IPTagArray []IPTagInput

func (IPTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPTag)(nil)).Elem()
}

func (i IPTagArray) ToIPTagArrayOutput() IPTagArrayOutput {
	return i.ToIPTagArrayOutputWithContext(context.Background())
}

func (i IPTagArray) ToIPTagArrayOutputWithContext(ctx context.Context) IPTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPTagArrayOutput)
}

// IPTag associated with the object.
type IPTagOutput struct{ *pulumi.OutputState }

func (IPTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPTag)(nil)).Elem()
}

func (o IPTagOutput) ToIPTagOutput() IPTagOutput {
	return o
}

func (o IPTagOutput) ToIPTagOutputWithContext(ctx context.Context) IPTagOutput {
	return o
}

// The IP tag type.
func (o IPTagOutput) IpTagType() pulumi.StringOutput {
	return o.ApplyT(func(v IPTag) string { return v.IpTagType }).(pulumi.StringOutput)
}

// The value of the IP tag.
func (o IPTagOutput) Tag() pulumi.StringOutput {
	return o.ApplyT(func(v IPTag) string { return v.Tag }).(pulumi.StringOutput)
}

type IPTagArrayOutput struct{ *pulumi.OutputState }

func (IPTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPTag)(nil)).Elem()
}

func (o IPTagArrayOutput) ToIPTagArrayOutput() IPTagArrayOutput {
	return o
}

func (o IPTagArrayOutput) ToIPTagArrayOutputWithContext(ctx context.Context) IPTagArrayOutput {
	return o
}

func (o IPTagArrayOutput) Index(i pulumi.IntInput) IPTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IPTag {
		return vs[0].([]IPTag)[vs[1].(int)]
	}).(IPTagOutput)
}

// IPTag associated with the object.
type IPTagResponse struct {
	// The IP tag type.
	IpTagType string `pulumi:"ipTagType"`
	// The value of the IP tag.
	Tag string `pulumi:"tag"`
}

// IPTagResponseInput is an input type that accepts IPTagResponseArgs and IPTagResponseOutput values.
// You can construct a concrete instance of `IPTagResponseInput` via:
//
//          IPTagResponseArgs{...}
type IPTagResponseInput interface {
	pulumi.Input

	ToIPTagResponseOutput() IPTagResponseOutput
	ToIPTagResponseOutputWithContext(context.Context) IPTagResponseOutput
}

// IPTag associated with the object.
type IPTagResponseArgs struct {
	// The IP tag type.
	IpTagType pulumi.StringInput `pulumi:"ipTagType"`
	// The value of the IP tag.
	Tag pulumi.StringInput `pulumi:"tag"`
}

func (IPTagResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IPTagResponse)(nil)).Elem()
}

func (i IPTagResponseArgs) ToIPTagResponseOutput() IPTagResponseOutput {
	return i.ToIPTagResponseOutputWithContext(context.Background())
}

func (i IPTagResponseArgs) ToIPTagResponseOutputWithContext(ctx context.Context) IPTagResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPTagResponseOutput)
}

// IPTagResponseArrayInput is an input type that accepts IPTagResponseArray and IPTagResponseArrayOutput values.
// You can construct a concrete instance of `IPTagResponseArrayInput` via:
//
//          IPTagResponseArray{ IPTagResponseArgs{...} }
type IPTagResponseArrayInput interface {
	pulumi.Input

	ToIPTagResponseArrayOutput() IPTagResponseArrayOutput
	ToIPTagResponseArrayOutputWithContext(context.Context) IPTagResponseArrayOutput
}

type IPTagResponseArray []IPTagResponseInput

func (IPTagResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPTagResponse)(nil)).Elem()
}

func (i IPTagResponseArray) ToIPTagResponseArrayOutput() IPTagResponseArrayOutput {
	return i.ToIPTagResponseArrayOutputWithContext(context.Background())
}

func (i IPTagResponseArray) ToIPTagResponseArrayOutputWithContext(ctx context.Context) IPTagResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPTagResponseArrayOutput)
}

// IPTag associated with the object.
type IPTagResponseOutput struct{ *pulumi.OutputState }

func (IPTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPTagResponse)(nil)).Elem()
}

func (o IPTagResponseOutput) ToIPTagResponseOutput() IPTagResponseOutput {
	return o
}

func (o IPTagResponseOutput) ToIPTagResponseOutputWithContext(ctx context.Context) IPTagResponseOutput {
	return o
}

// The IP tag type.
func (o IPTagResponseOutput) IpTagType() pulumi.StringOutput {
	return o.ApplyT(func(v IPTagResponse) string { return v.IpTagType }).(pulumi.StringOutput)
}

// The value of the IP tag.
func (o IPTagResponseOutput) Tag() pulumi.StringOutput {
	return o.ApplyT(func(v IPTagResponse) string { return v.Tag }).(pulumi.StringOutput)
}

type IPTagResponseArrayOutput struct{ *pulumi.OutputState }

func (IPTagResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPTagResponse)(nil)).Elem()
}

func (o IPTagResponseArrayOutput) ToIPTagResponseArrayOutput() IPTagResponseArrayOutput {
	return o
}

func (o IPTagResponseArrayOutput) ToIPTagResponseArrayOutputWithContext(ctx context.Context) IPTagResponseArrayOutput {
	return o
}

func (o IPTagResponseArrayOutput) Index(i pulumi.IntInput) IPTagResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IPTagResponse {
		return vs[0].([]IPTagResponse)[vs[1].(int)]
	}).(IPTagResponseOutput)
}

// Describes a load balancing rule.
type LoadBalancingRule struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort int `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort int `pulumi:"frontendPort"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort *int `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol string `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath *string `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol string `pulumi:"protocol"`
}

// LoadBalancingRuleInput is an input type that accepts LoadBalancingRuleArgs and LoadBalancingRuleOutput values.
// You can construct a concrete instance of `LoadBalancingRuleInput` via:
//
//          LoadBalancingRuleArgs{...}
type LoadBalancingRuleInput interface {
	pulumi.Input

	ToLoadBalancingRuleOutput() LoadBalancingRuleOutput
	ToLoadBalancingRuleOutputWithContext(context.Context) LoadBalancingRuleOutput
}

// Describes a load balancing rule.
type LoadBalancingRuleArgs struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort pulumi.IntInput `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort pulumi.IntInput `pulumi:"frontendPort"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort pulumi.IntPtrInput `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol pulumi.StringInput `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath pulumi.StringPtrInput `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol pulumi.StringInput `pulumi:"protocol"`
}

func (LoadBalancingRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRule)(nil)).Elem()
}

func (i LoadBalancingRuleArgs) ToLoadBalancingRuleOutput() LoadBalancingRuleOutput {
	return i.ToLoadBalancingRuleOutputWithContext(context.Background())
}

func (i LoadBalancingRuleArgs) ToLoadBalancingRuleOutputWithContext(ctx context.Context) LoadBalancingRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancingRuleOutput)
}

// LoadBalancingRuleArrayInput is an input type that accepts LoadBalancingRuleArray and LoadBalancingRuleArrayOutput values.
// You can construct a concrete instance of `LoadBalancingRuleArrayInput` via:
//
//          LoadBalancingRuleArray{ LoadBalancingRuleArgs{...} }
type LoadBalancingRuleArrayInput interface {
	pulumi.Input

	ToLoadBalancingRuleArrayOutput() LoadBalancingRuleArrayOutput
	ToLoadBalancingRuleArrayOutputWithContext(context.Context) LoadBalancingRuleArrayOutput
}

type LoadBalancingRuleArray []LoadBalancingRuleInput

func (LoadBalancingRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRule)(nil)).Elem()
}

func (i LoadBalancingRuleArray) ToLoadBalancingRuleArrayOutput() LoadBalancingRuleArrayOutput {
	return i.ToLoadBalancingRuleArrayOutputWithContext(context.Background())
}

func (i LoadBalancingRuleArray) ToLoadBalancingRuleArrayOutputWithContext(ctx context.Context) LoadBalancingRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancingRuleArrayOutput)
}

// Describes a load balancing rule.
type LoadBalancingRuleOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRule)(nil)).Elem()
}

func (o LoadBalancingRuleOutput) ToLoadBalancingRuleOutput() LoadBalancingRuleOutput {
	return o
}

func (o LoadBalancingRuleOutput) ToLoadBalancingRuleOutputWithContext(ctx context.Context) LoadBalancingRuleOutput {
	return o
}

// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleOutput) BackendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRule) int { return v.BackendPort }).(pulumi.IntOutput)
}

// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
func (o LoadBalancingRuleOutput) FrontendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRule) int { return v.FrontendPort }).(pulumi.IntOutput)
}

// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleOutput) ProbePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LoadBalancingRule) *int { return v.ProbePort }).(pulumi.IntPtrOutput)
}

// the reference to the load balancer probe used by the load balancing rule.
func (o LoadBalancingRuleOutput) ProbeProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRule) string { return v.ProbeProtocol }).(pulumi.StringOutput)
}

// The probe request path. Only supported for HTTP/HTTPS probes.
func (o LoadBalancingRuleOutput) ProbeRequestPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRule) *string { return v.ProbeRequestPath }).(pulumi.StringPtrOutput)
}

// The reference to the transport protocol used by the load balancing rule.
func (o LoadBalancingRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRule) string { return v.Protocol }).(pulumi.StringOutput)
}

type LoadBalancingRuleArrayOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRule)(nil)).Elem()
}

func (o LoadBalancingRuleArrayOutput) ToLoadBalancingRuleArrayOutput() LoadBalancingRuleArrayOutput {
	return o
}

func (o LoadBalancingRuleArrayOutput) ToLoadBalancingRuleArrayOutputWithContext(ctx context.Context) LoadBalancingRuleArrayOutput {
	return o
}

func (o LoadBalancingRuleArrayOutput) Index(i pulumi.IntInput) LoadBalancingRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoadBalancingRule {
		return vs[0].([]LoadBalancingRule)[vs[1].(int)]
	}).(LoadBalancingRuleOutput)
}

// Describes a load balancing rule.
type LoadBalancingRuleResponse struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort int `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort int `pulumi:"frontendPort"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort *int `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol string `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath *string `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol string `pulumi:"protocol"`
}

// LoadBalancingRuleResponseInput is an input type that accepts LoadBalancingRuleResponseArgs and LoadBalancingRuleResponseOutput values.
// You can construct a concrete instance of `LoadBalancingRuleResponseInput` via:
//
//          LoadBalancingRuleResponseArgs{...}
type LoadBalancingRuleResponseInput interface {
	pulumi.Input

	ToLoadBalancingRuleResponseOutput() LoadBalancingRuleResponseOutput
	ToLoadBalancingRuleResponseOutputWithContext(context.Context) LoadBalancingRuleResponseOutput
}

// Describes a load balancing rule.
type LoadBalancingRuleResponseArgs struct {
	// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort pulumi.IntInput `pulumi:"backendPort"`
	// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
	FrontendPort pulumi.IntInput `pulumi:"frontendPort"`
	// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
	ProbePort pulumi.IntPtrInput `pulumi:"probePort"`
	// the reference to the load balancer probe used by the load balancing rule.
	ProbeProtocol pulumi.StringInput `pulumi:"probeProtocol"`
	// The probe request path. Only supported for HTTP/HTTPS probes.
	ProbeRequestPath pulumi.StringPtrInput `pulumi:"probeRequestPath"`
	// The reference to the transport protocol used by the load balancing rule.
	Protocol pulumi.StringInput `pulumi:"protocol"`
}

func (LoadBalancingRuleResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRuleResponse)(nil)).Elem()
}

func (i LoadBalancingRuleResponseArgs) ToLoadBalancingRuleResponseOutput() LoadBalancingRuleResponseOutput {
	return i.ToLoadBalancingRuleResponseOutputWithContext(context.Background())
}

func (i LoadBalancingRuleResponseArgs) ToLoadBalancingRuleResponseOutputWithContext(ctx context.Context) LoadBalancingRuleResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancingRuleResponseOutput)
}

// LoadBalancingRuleResponseArrayInput is an input type that accepts LoadBalancingRuleResponseArray and LoadBalancingRuleResponseArrayOutput values.
// You can construct a concrete instance of `LoadBalancingRuleResponseArrayInput` via:
//
//          LoadBalancingRuleResponseArray{ LoadBalancingRuleResponseArgs{...} }
type LoadBalancingRuleResponseArrayInput interface {
	pulumi.Input

	ToLoadBalancingRuleResponseArrayOutput() LoadBalancingRuleResponseArrayOutput
	ToLoadBalancingRuleResponseArrayOutputWithContext(context.Context) LoadBalancingRuleResponseArrayOutput
}

type LoadBalancingRuleResponseArray []LoadBalancingRuleResponseInput

func (LoadBalancingRuleResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRuleResponse)(nil)).Elem()
}

func (i LoadBalancingRuleResponseArray) ToLoadBalancingRuleResponseArrayOutput() LoadBalancingRuleResponseArrayOutput {
	return i.ToLoadBalancingRuleResponseArrayOutputWithContext(context.Background())
}

func (i LoadBalancingRuleResponseArray) ToLoadBalancingRuleResponseArrayOutputWithContext(ctx context.Context) LoadBalancingRuleResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancingRuleResponseArrayOutput)
}

// Describes a load balancing rule.
type LoadBalancingRuleResponseOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoadBalancingRuleResponse)(nil)).Elem()
}

func (o LoadBalancingRuleResponseOutput) ToLoadBalancingRuleResponseOutput() LoadBalancingRuleResponseOutput {
	return o
}

func (o LoadBalancingRuleResponseOutput) ToLoadBalancingRuleResponseOutputWithContext(ctx context.Context) LoadBalancingRuleResponseOutput {
	return o
}

// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleResponseOutput) BackendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) int { return v.BackendPort }).(pulumi.IntOutput)
}

// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
func (o LoadBalancingRuleResponseOutput) FrontendPort() pulumi.IntOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) int { return v.FrontendPort }).(pulumi.IntOutput)
}

// The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
func (o LoadBalancingRuleResponseOutput) ProbePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) *int { return v.ProbePort }).(pulumi.IntPtrOutput)
}

// the reference to the load balancer probe used by the load balancing rule.
func (o LoadBalancingRuleResponseOutput) ProbeProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) string { return v.ProbeProtocol }).(pulumi.StringOutput)
}

// The probe request path. Only supported for HTTP/HTTPS probes.
func (o LoadBalancingRuleResponseOutput) ProbeRequestPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) *string { return v.ProbeRequestPath }).(pulumi.StringPtrOutput)
}

// The reference to the transport protocol used by the load balancing rule.
func (o LoadBalancingRuleResponseOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v LoadBalancingRuleResponse) string { return v.Protocol }).(pulumi.StringOutput)
}

type LoadBalancingRuleResponseArrayOutput struct{ *pulumi.OutputState }

func (LoadBalancingRuleResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoadBalancingRuleResponse)(nil)).Elem()
}

func (o LoadBalancingRuleResponseArrayOutput) ToLoadBalancingRuleResponseArrayOutput() LoadBalancingRuleResponseArrayOutput {
	return o
}

func (o LoadBalancingRuleResponseArrayOutput) ToLoadBalancingRuleResponseArrayOutputWithContext(ctx context.Context) LoadBalancingRuleResponseArrayOutput {
	return o
}

func (o LoadBalancingRuleResponseArrayOutput) Index(i pulumi.IntInput) LoadBalancingRuleResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoadBalancingRuleResponse {
		return vs[0].([]LoadBalancingRuleResponse)[vs[1].(int)]
	}).(LoadBalancingRuleResponseOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentity struct {
	// The type of managed identity for the resource.
	Type *string `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]interface{} `pulumi:"userAssignedIdentities"`
}

// ManagedIdentityInput is an input type that accepts ManagedIdentityArgs and ManagedIdentityOutput values.
// You can construct a concrete instance of `ManagedIdentityInput` via:
//
//          ManagedIdentityArgs{...}
type ManagedIdentityInput interface {
	pulumi.Input

	ToManagedIdentityOutput() ManagedIdentityOutput
	ToManagedIdentityOutputWithContext(context.Context) ManagedIdentityOutput
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityArgs struct {
	// The type of managed identity for the resource.
	Type *ManagedIdentityType `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities pulumi.MapInput `pulumi:"userAssignedIdentities"`
}

func (ManagedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentity)(nil)).Elem()
}

func (i ManagedIdentityArgs) ToManagedIdentityOutput() ManagedIdentityOutput {
	return i.ToManagedIdentityOutputWithContext(context.Background())
}

func (i ManagedIdentityArgs) ToManagedIdentityOutputWithContext(ctx context.Context) ManagedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityOutput)
}

func (i ManagedIdentityArgs) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return i.ToManagedIdentityPtrOutputWithContext(context.Background())
}

func (i ManagedIdentityArgs) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityOutput).ToManagedIdentityPtrOutputWithContext(ctx)
}

// ManagedIdentityPtrInput is an input type that accepts ManagedIdentityArgs, ManagedIdentityPtr and ManagedIdentityPtrOutput values.
// You can construct a concrete instance of `ManagedIdentityPtrInput` via:
//
//          ManagedIdentityArgs{...}
//
//  or:
//
//          nil
type ManagedIdentityPtrInput interface {
	pulumi.Input

	ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput
	ToManagedIdentityPtrOutputWithContext(context.Context) ManagedIdentityPtrOutput
}

type managedIdentityPtrType ManagedIdentityArgs

func ManagedIdentityPtr(v *ManagedIdentityArgs) ManagedIdentityPtrInput {
	return (*managedIdentityPtrType)(v)
}

func (*managedIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentity)(nil)).Elem()
}

func (i *managedIdentityPtrType) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return i.ToManagedIdentityPtrOutputWithContext(context.Background())
}

func (i *managedIdentityPtrType) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityPtrOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityOutput struct{ *pulumi.OutputState }

func (ManagedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentity)(nil)).Elem()
}

func (o ManagedIdentityOutput) ToManagedIdentityOutput() ManagedIdentityOutput {
	return o
}

func (o ManagedIdentityOutput) ToManagedIdentityOutputWithContext(ctx context.Context) ManagedIdentityOutput {
	return o
}

func (o ManagedIdentityOutput) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return o.ToManagedIdentityPtrOutputWithContext(context.Background())
}

func (o ManagedIdentityOutput) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return o.ApplyT(func(v ManagedIdentity) *ManagedIdentity {
		return &v
	}).(ManagedIdentityPtrOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagedIdentity) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityOutput) UserAssignedIdentities() pulumi.MapOutput {
	return o.ApplyT(func(v ManagedIdentity) map[string]interface{} { return v.UserAssignedIdentities }).(pulumi.MapOutput)
}

type ManagedIdentityPtrOutput struct{ *pulumi.OutputState }

func (ManagedIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentity)(nil)).Elem()
}

func (o ManagedIdentityPtrOutput) ToManagedIdentityPtrOutput() ManagedIdentityPtrOutput {
	return o
}

func (o ManagedIdentityPtrOutput) ToManagedIdentityPtrOutputWithContext(ctx context.Context) ManagedIdentityPtrOutput {
	return o
}

func (o ManagedIdentityPtrOutput) Elem() ManagedIdentityOutput {
	return o.ApplyT(func(v *ManagedIdentity) ManagedIdentity { return *v }).(ManagedIdentityOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentity) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityPtrOutput) UserAssignedIdentities() pulumi.MapOutput {
	return o.ApplyT(func(v *ManagedIdentity) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.MapOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityResponse struct {
	// The principal id of the managed identity. This property will only be provided for a system assigned identity.
	PrincipalId string `pulumi:"principalId"`
	// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
	TenantId string `pulumi:"tenantId"`
	// The type of managed identity for the resource.
	Type *string `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]UserAssignedIdentityResponse `pulumi:"userAssignedIdentities"`
}

// ManagedIdentityResponseInput is an input type that accepts ManagedIdentityResponseArgs and ManagedIdentityResponseOutput values.
// You can construct a concrete instance of `ManagedIdentityResponseInput` via:
//
//          ManagedIdentityResponseArgs{...}
type ManagedIdentityResponseInput interface {
	pulumi.Input

	ToManagedIdentityResponseOutput() ManagedIdentityResponseOutput
	ToManagedIdentityResponseOutputWithContext(context.Context) ManagedIdentityResponseOutput
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityResponseArgs struct {
	// The principal id of the managed identity. This property will only be provided for a system assigned identity.
	PrincipalId pulumi.StringInput `pulumi:"principalId"`
	// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
	TenantId pulumi.StringInput `pulumi:"tenantId"`
	// The type of managed identity for the resource.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities UserAssignedIdentityResponseMapInput `pulumi:"userAssignedIdentities"`
}

func (ManagedIdentityResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentityResponse)(nil)).Elem()
}

func (i ManagedIdentityResponseArgs) ToManagedIdentityResponseOutput() ManagedIdentityResponseOutput {
	return i.ToManagedIdentityResponseOutputWithContext(context.Background())
}

func (i ManagedIdentityResponseArgs) ToManagedIdentityResponseOutputWithContext(ctx context.Context) ManagedIdentityResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityResponseOutput)
}

func (i ManagedIdentityResponseArgs) ToManagedIdentityResponsePtrOutput() ManagedIdentityResponsePtrOutput {
	return i.ToManagedIdentityResponsePtrOutputWithContext(context.Background())
}

func (i ManagedIdentityResponseArgs) ToManagedIdentityResponsePtrOutputWithContext(ctx context.Context) ManagedIdentityResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityResponseOutput).ToManagedIdentityResponsePtrOutputWithContext(ctx)
}

// ManagedIdentityResponsePtrInput is an input type that accepts ManagedIdentityResponseArgs, ManagedIdentityResponsePtr and ManagedIdentityResponsePtrOutput values.
// You can construct a concrete instance of `ManagedIdentityResponsePtrInput` via:
//
//          ManagedIdentityResponseArgs{...}
//
//  or:
//
//          nil
type ManagedIdentityResponsePtrInput interface {
	pulumi.Input

	ToManagedIdentityResponsePtrOutput() ManagedIdentityResponsePtrOutput
	ToManagedIdentityResponsePtrOutputWithContext(context.Context) ManagedIdentityResponsePtrOutput
}

type managedIdentityResponsePtrType ManagedIdentityResponseArgs

func ManagedIdentityResponsePtr(v *ManagedIdentityResponseArgs) ManagedIdentityResponsePtrInput {
	return (*managedIdentityResponsePtrType)(v)
}

func (*managedIdentityResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentityResponse)(nil)).Elem()
}

func (i *managedIdentityResponsePtrType) ToManagedIdentityResponsePtrOutput() ManagedIdentityResponsePtrOutput {
	return i.ToManagedIdentityResponsePtrOutputWithContext(context.Background())
}

func (i *managedIdentityResponsePtrType) ToManagedIdentityResponsePtrOutputWithContext(ctx context.Context) ManagedIdentityResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedIdentityResponsePtrOutput)
}

// Describes the managed identities for an Azure resource.
type ManagedIdentityResponseOutput struct{ *pulumi.OutputState }

func (ManagedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedIdentityResponse)(nil)).Elem()
}

func (o ManagedIdentityResponseOutput) ToManagedIdentityResponseOutput() ManagedIdentityResponseOutput {
	return o
}

func (o ManagedIdentityResponseOutput) ToManagedIdentityResponseOutputWithContext(ctx context.Context) ManagedIdentityResponseOutput {
	return o
}

func (o ManagedIdentityResponseOutput) ToManagedIdentityResponsePtrOutput() ManagedIdentityResponsePtrOutput {
	return o.ToManagedIdentityResponsePtrOutputWithContext(context.Background())
}

func (o ManagedIdentityResponseOutput) ToManagedIdentityResponsePtrOutputWithContext(ctx context.Context) ManagedIdentityResponsePtrOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) *ManagedIdentityResponse {
		return &v
	}).(ManagedIdentityResponsePtrOutput)
}

// The principal id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponseOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) string { return v.TenantId }).(pulumi.StringOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityResponseOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityResponseOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v ManagedIdentityResponse) map[string]UserAssignedIdentityResponse {
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

type ManagedIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (ManagedIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedIdentityResponse)(nil)).Elem()
}

func (o ManagedIdentityResponsePtrOutput) ToManagedIdentityResponsePtrOutput() ManagedIdentityResponsePtrOutput {
	return o
}

func (o ManagedIdentityResponsePtrOutput) ToManagedIdentityResponsePtrOutputWithContext(ctx context.Context) ManagedIdentityResponsePtrOutput {
	return o
}

func (o ManagedIdentityResponsePtrOutput) Elem() ManagedIdentityResponseOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) ManagedIdentityResponse { return *v }).(ManagedIdentityResponseOutput)
}

// The principal id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponsePtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The tenant id of the managed identity. This property will only be provided for a system assigned identity.
func (o ManagedIdentityResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TenantId
	}).(pulumi.StringPtrOutput)
}

// The type of managed identity for the resource.
func (o ManagedIdentityResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o ManagedIdentityResponsePtrOutput) UserAssignedIdentities() UserAssignedIdentityResponseMapOutput {
	return o.ApplyT(func(v *ManagedIdentityResponse) map[string]UserAssignedIdentityResponse {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(UserAssignedIdentityResponseMapOutput)
}

// Describes the named partition scheme of the service.
type NamedPartitionScheme struct {
	// Array for the names of the partitions.
	Names []string `pulumi:"names"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Named'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// NamedPartitionSchemeInput is an input type that accepts NamedPartitionSchemeArgs and NamedPartitionSchemeOutput values.
// You can construct a concrete instance of `NamedPartitionSchemeInput` via:
//
//          NamedPartitionSchemeArgs{...}
type NamedPartitionSchemeInput interface {
	pulumi.Input

	ToNamedPartitionSchemeOutput() NamedPartitionSchemeOutput
	ToNamedPartitionSchemeOutputWithContext(context.Context) NamedPartitionSchemeOutput
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeArgs struct {
	// Array for the names of the partitions.
	Names pulumi.StringArrayInput `pulumi:"names"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Named'.
	PartitionScheme pulumi.StringInput `pulumi:"partitionScheme"`
}

func (NamedPartitionSchemeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamedPartitionScheme)(nil)).Elem()
}

func (i NamedPartitionSchemeArgs) ToNamedPartitionSchemeOutput() NamedPartitionSchemeOutput {
	return i.ToNamedPartitionSchemeOutputWithContext(context.Background())
}

func (i NamedPartitionSchemeArgs) ToNamedPartitionSchemeOutputWithContext(ctx context.Context) NamedPartitionSchemeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamedPartitionSchemeOutput)
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeOutput struct{ *pulumi.OutputState }

func (NamedPartitionSchemeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamedPartitionScheme)(nil)).Elem()
}

func (o NamedPartitionSchemeOutput) ToNamedPartitionSchemeOutput() NamedPartitionSchemeOutput {
	return o
}

func (o NamedPartitionSchemeOutput) ToNamedPartitionSchemeOutputWithContext(ctx context.Context) NamedPartitionSchemeOutput {
	return o
}

// Array for the names of the partitions.
func (o NamedPartitionSchemeOutput) Names() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamedPartitionScheme) []string { return v.Names }).(pulumi.StringArrayOutput)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Named'.
func (o NamedPartitionSchemeOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v NamedPartitionScheme) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeResponse struct {
	// Array for the names of the partitions.
	Names []string `pulumi:"names"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Named'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// NamedPartitionSchemeResponseInput is an input type that accepts NamedPartitionSchemeResponseArgs and NamedPartitionSchemeResponseOutput values.
// You can construct a concrete instance of `NamedPartitionSchemeResponseInput` via:
//
//          NamedPartitionSchemeResponseArgs{...}
type NamedPartitionSchemeResponseInput interface {
	pulumi.Input

	ToNamedPartitionSchemeResponseOutput() NamedPartitionSchemeResponseOutput
	ToNamedPartitionSchemeResponseOutputWithContext(context.Context) NamedPartitionSchemeResponseOutput
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeResponseArgs struct {
	// Array for the names of the partitions.
	Names pulumi.StringArrayInput `pulumi:"names"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Named'.
	PartitionScheme pulumi.StringInput `pulumi:"partitionScheme"`
}

func (NamedPartitionSchemeResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamedPartitionSchemeResponse)(nil)).Elem()
}

func (i NamedPartitionSchemeResponseArgs) ToNamedPartitionSchemeResponseOutput() NamedPartitionSchemeResponseOutput {
	return i.ToNamedPartitionSchemeResponseOutputWithContext(context.Background())
}

func (i NamedPartitionSchemeResponseArgs) ToNamedPartitionSchemeResponseOutputWithContext(ctx context.Context) NamedPartitionSchemeResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamedPartitionSchemeResponseOutput)
}

// Describes the named partition scheme of the service.
type NamedPartitionSchemeResponseOutput struct{ *pulumi.OutputState }

func (NamedPartitionSchemeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamedPartitionSchemeResponse)(nil)).Elem()
}

func (o NamedPartitionSchemeResponseOutput) ToNamedPartitionSchemeResponseOutput() NamedPartitionSchemeResponseOutput {
	return o
}

func (o NamedPartitionSchemeResponseOutput) ToNamedPartitionSchemeResponseOutputWithContext(ctx context.Context) NamedPartitionSchemeResponseOutput {
	return o
}

// Array for the names of the partitions.
func (o NamedPartitionSchemeResponseOutput) Names() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamedPartitionSchemeResponse) []string { return v.Names }).(pulumi.StringArrayOutput)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Named'.
func (o NamedPartitionSchemeResponseOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v NamedPartitionSchemeResponse) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

// Describes a network security rule.
type NetworkSecurityRule struct {
	// The network traffic is allowed or denied.
	Access string `pulumi:"access"`
	// Network security rule description.
	Description *string `pulumi:"description"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes []string `pulumi:"destinationAddressPrefixes"`
	// The destination port ranges.
	DestinationPortRanges []string `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction string `pulumi:"direction"`
	// Network security rule name.
	Name string `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority int `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol string `pulumi:"protocol"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes []string `pulumi:"sourceAddressPrefixes"`
	// The source port ranges.
	SourcePortRanges []string `pulumi:"sourcePortRanges"`
}

// NetworkSecurityRuleInput is an input type that accepts NetworkSecurityRuleArgs and NetworkSecurityRuleOutput values.
// You can construct a concrete instance of `NetworkSecurityRuleInput` via:
//
//          NetworkSecurityRuleArgs{...}
type NetworkSecurityRuleInput interface {
	pulumi.Input

	ToNetworkSecurityRuleOutput() NetworkSecurityRuleOutput
	ToNetworkSecurityRuleOutputWithContext(context.Context) NetworkSecurityRuleOutput
}

// Describes a network security rule.
type NetworkSecurityRuleArgs struct {
	// The network traffic is allowed or denied.
	Access pulumi.StringInput `pulumi:"access"`
	// Network security rule description.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes pulumi.StringArrayInput `pulumi:"destinationAddressPrefixes"`
	// The destination port ranges.
	DestinationPortRanges pulumi.StringArrayInput `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction pulumi.StringInput `pulumi:"direction"`
	// Network security rule name.
	Name pulumi.StringInput `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority pulumi.IntInput `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol pulumi.StringInput `pulumi:"protocol"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes pulumi.StringArrayInput `pulumi:"sourceAddressPrefixes"`
	// The source port ranges.
	SourcePortRanges pulumi.StringArrayInput `pulumi:"sourcePortRanges"`
}

func (NetworkSecurityRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRule)(nil)).Elem()
}

func (i NetworkSecurityRuleArgs) ToNetworkSecurityRuleOutput() NetworkSecurityRuleOutput {
	return i.ToNetworkSecurityRuleOutputWithContext(context.Background())
}

func (i NetworkSecurityRuleArgs) ToNetworkSecurityRuleOutputWithContext(ctx context.Context) NetworkSecurityRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkSecurityRuleOutput)
}

// NetworkSecurityRuleArrayInput is an input type that accepts NetworkSecurityRuleArray and NetworkSecurityRuleArrayOutput values.
// You can construct a concrete instance of `NetworkSecurityRuleArrayInput` via:
//
//          NetworkSecurityRuleArray{ NetworkSecurityRuleArgs{...} }
type NetworkSecurityRuleArrayInput interface {
	pulumi.Input

	ToNetworkSecurityRuleArrayOutput() NetworkSecurityRuleArrayOutput
	ToNetworkSecurityRuleArrayOutputWithContext(context.Context) NetworkSecurityRuleArrayOutput
}

type NetworkSecurityRuleArray []NetworkSecurityRuleInput

func (NetworkSecurityRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRule)(nil)).Elem()
}

func (i NetworkSecurityRuleArray) ToNetworkSecurityRuleArrayOutput() NetworkSecurityRuleArrayOutput {
	return i.ToNetworkSecurityRuleArrayOutputWithContext(context.Background())
}

func (i NetworkSecurityRuleArray) ToNetworkSecurityRuleArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkSecurityRuleArrayOutput)
}

// Describes a network security rule.
type NetworkSecurityRuleOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRule)(nil)).Elem()
}

func (o NetworkSecurityRuleOutput) ToNetworkSecurityRuleOutput() NetworkSecurityRuleOutput {
	return o
}

func (o NetworkSecurityRuleOutput) ToNetworkSecurityRuleOutputWithContext(ctx context.Context) NetworkSecurityRuleOutput {
	return o
}

// The network traffic is allowed or denied.
func (o NetworkSecurityRuleOutput) Access() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Access }).(pulumi.StringOutput)
}

// Network security rule description.
func (o NetworkSecurityRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRule) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The destination address prefixes. CIDR or destination IP ranges.
func (o NetworkSecurityRuleOutput) DestinationAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.DestinationAddressPrefixes }).(pulumi.StringArrayOutput)
}

// The destination port ranges.
func (o NetworkSecurityRuleOutput) DestinationPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.DestinationPortRanges }).(pulumi.StringArrayOutput)
}

// Network security rule direction.
func (o NetworkSecurityRuleOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Direction }).(pulumi.StringOutput)
}

// Network security rule name.
func (o NetworkSecurityRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Name }).(pulumi.StringOutput)
}

// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
func (o NetworkSecurityRuleOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v NetworkSecurityRule) int { return v.Priority }).(pulumi.IntOutput)
}

// Network protocol this rule applies to.
func (o NetworkSecurityRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRule) string { return v.Protocol }).(pulumi.StringOutput)
}

// The CIDR or source IP ranges.
func (o NetworkSecurityRuleOutput) SourceAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.SourceAddressPrefixes }).(pulumi.StringArrayOutput)
}

// The source port ranges.
func (o NetworkSecurityRuleOutput) SourcePortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRule) []string { return v.SourcePortRanges }).(pulumi.StringArrayOutput)
}

type NetworkSecurityRuleArrayOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRule)(nil)).Elem()
}

func (o NetworkSecurityRuleArrayOutput) ToNetworkSecurityRuleArrayOutput() NetworkSecurityRuleArrayOutput {
	return o
}

func (o NetworkSecurityRuleArrayOutput) ToNetworkSecurityRuleArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleArrayOutput {
	return o
}

func (o NetworkSecurityRuleArrayOutput) Index(i pulumi.IntInput) NetworkSecurityRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkSecurityRule {
		return vs[0].([]NetworkSecurityRule)[vs[1].(int)]
	}).(NetworkSecurityRuleOutput)
}

// Describes a network security rule.
type NetworkSecurityRuleResponse struct {
	// The network traffic is allowed or denied.
	Access string `pulumi:"access"`
	// Network security rule description.
	Description *string `pulumi:"description"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes []string `pulumi:"destinationAddressPrefixes"`
	// The destination port ranges.
	DestinationPortRanges []string `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction string `pulumi:"direction"`
	// Network security rule name.
	Name string `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority int `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol string `pulumi:"protocol"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes []string `pulumi:"sourceAddressPrefixes"`
	// The source port ranges.
	SourcePortRanges []string `pulumi:"sourcePortRanges"`
}

// NetworkSecurityRuleResponseInput is an input type that accepts NetworkSecurityRuleResponseArgs and NetworkSecurityRuleResponseOutput values.
// You can construct a concrete instance of `NetworkSecurityRuleResponseInput` via:
//
//          NetworkSecurityRuleResponseArgs{...}
type NetworkSecurityRuleResponseInput interface {
	pulumi.Input

	ToNetworkSecurityRuleResponseOutput() NetworkSecurityRuleResponseOutput
	ToNetworkSecurityRuleResponseOutputWithContext(context.Context) NetworkSecurityRuleResponseOutput
}

// Describes a network security rule.
type NetworkSecurityRuleResponseArgs struct {
	// The network traffic is allowed or denied.
	Access pulumi.StringInput `pulumi:"access"`
	// Network security rule description.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes pulumi.StringArrayInput `pulumi:"destinationAddressPrefixes"`
	// The destination port ranges.
	DestinationPortRanges pulumi.StringArrayInput `pulumi:"destinationPortRanges"`
	// Network security rule direction.
	Direction pulumi.StringInput `pulumi:"direction"`
	// Network security rule name.
	Name pulumi.StringInput `pulumi:"name"`
	// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority pulumi.IntInput `pulumi:"priority"`
	// Network protocol this rule applies to.
	Protocol pulumi.StringInput `pulumi:"protocol"`
	// The CIDR or source IP ranges.
	SourceAddressPrefixes pulumi.StringArrayInput `pulumi:"sourceAddressPrefixes"`
	// The source port ranges.
	SourcePortRanges pulumi.StringArrayInput `pulumi:"sourcePortRanges"`
}

func (NetworkSecurityRuleResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRuleResponse)(nil)).Elem()
}

func (i NetworkSecurityRuleResponseArgs) ToNetworkSecurityRuleResponseOutput() NetworkSecurityRuleResponseOutput {
	return i.ToNetworkSecurityRuleResponseOutputWithContext(context.Background())
}

func (i NetworkSecurityRuleResponseArgs) ToNetworkSecurityRuleResponseOutputWithContext(ctx context.Context) NetworkSecurityRuleResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkSecurityRuleResponseOutput)
}

// NetworkSecurityRuleResponseArrayInput is an input type that accepts NetworkSecurityRuleResponseArray and NetworkSecurityRuleResponseArrayOutput values.
// You can construct a concrete instance of `NetworkSecurityRuleResponseArrayInput` via:
//
//          NetworkSecurityRuleResponseArray{ NetworkSecurityRuleResponseArgs{...} }
type NetworkSecurityRuleResponseArrayInput interface {
	pulumi.Input

	ToNetworkSecurityRuleResponseArrayOutput() NetworkSecurityRuleResponseArrayOutput
	ToNetworkSecurityRuleResponseArrayOutputWithContext(context.Context) NetworkSecurityRuleResponseArrayOutput
}

type NetworkSecurityRuleResponseArray []NetworkSecurityRuleResponseInput

func (NetworkSecurityRuleResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRuleResponse)(nil)).Elem()
}

func (i NetworkSecurityRuleResponseArray) ToNetworkSecurityRuleResponseArrayOutput() NetworkSecurityRuleResponseArrayOutput {
	return i.ToNetworkSecurityRuleResponseArrayOutputWithContext(context.Background())
}

func (i NetworkSecurityRuleResponseArray) ToNetworkSecurityRuleResponseArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkSecurityRuleResponseArrayOutput)
}

// Describes a network security rule.
type NetworkSecurityRuleResponseOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkSecurityRuleResponse)(nil)).Elem()
}

func (o NetworkSecurityRuleResponseOutput) ToNetworkSecurityRuleResponseOutput() NetworkSecurityRuleResponseOutput {
	return o
}

func (o NetworkSecurityRuleResponseOutput) ToNetworkSecurityRuleResponseOutputWithContext(ctx context.Context) NetworkSecurityRuleResponseOutput {
	return o
}

// The network traffic is allowed or denied.
func (o NetworkSecurityRuleResponseOutput) Access() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Access }).(pulumi.StringOutput)
}

// Network security rule description.
func (o NetworkSecurityRuleResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The destination address prefixes. CIDR or destination IP ranges.
func (o NetworkSecurityRuleResponseOutput) DestinationAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.DestinationAddressPrefixes }).(pulumi.StringArrayOutput)
}

// The destination port ranges.
func (o NetworkSecurityRuleResponseOutput) DestinationPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.DestinationPortRanges }).(pulumi.StringArrayOutput)
}

// Network security rule direction.
func (o NetworkSecurityRuleResponseOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Direction }).(pulumi.StringOutput)
}

// Network security rule name.
func (o NetworkSecurityRuleResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
func (o NetworkSecurityRuleResponseOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) int { return v.Priority }).(pulumi.IntOutput)
}

// Network protocol this rule applies to.
func (o NetworkSecurityRuleResponseOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) string { return v.Protocol }).(pulumi.StringOutput)
}

// The CIDR or source IP ranges.
func (o NetworkSecurityRuleResponseOutput) SourceAddressPrefixes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.SourceAddressPrefixes }).(pulumi.StringArrayOutput)
}

// The source port ranges.
func (o NetworkSecurityRuleResponseOutput) SourcePortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NetworkSecurityRuleResponse) []string { return v.SourcePortRanges }).(pulumi.StringArrayOutput)
}

type NetworkSecurityRuleResponseArrayOutput struct{ *pulumi.OutputState }

func (NetworkSecurityRuleResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkSecurityRuleResponse)(nil)).Elem()
}

func (o NetworkSecurityRuleResponseArrayOutput) ToNetworkSecurityRuleResponseArrayOutput() NetworkSecurityRuleResponseArrayOutput {
	return o
}

func (o NetworkSecurityRuleResponseArrayOutput) ToNetworkSecurityRuleResponseArrayOutputWithContext(ctx context.Context) NetworkSecurityRuleResponseArrayOutput {
	return o
}

func (o NetworkSecurityRuleResponseArrayOutput) Index(i pulumi.IntInput) NetworkSecurityRuleResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkSecurityRuleResponse {
		return vs[0].([]NetworkSecurityRuleResponse)[vs[1].(int)]
	}).(NetworkSecurityRuleResponseOutput)
}

// Describes a node type sku.
type NodeTypeSku struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity int `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name *string `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier *string `pulumi:"tier"`
}

// NodeTypeSkuInput is an input type that accepts NodeTypeSkuArgs and NodeTypeSkuOutput values.
// You can construct a concrete instance of `NodeTypeSkuInput` via:
//
//          NodeTypeSkuArgs{...}
type NodeTypeSkuInput interface {
	pulumi.Input

	ToNodeTypeSkuOutput() NodeTypeSkuOutput
	ToNodeTypeSkuOutputWithContext(context.Context) NodeTypeSkuOutput
}

// Describes a node type sku.
type NodeTypeSkuArgs struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity pulumi.IntInput `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier pulumi.StringPtrInput `pulumi:"tier"`
}

func (NodeTypeSkuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSku)(nil)).Elem()
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuOutput() NodeTypeSkuOutput {
	return i.ToNodeTypeSkuOutputWithContext(context.Background())
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuOutputWithContext(ctx context.Context) NodeTypeSkuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuOutput)
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return i.ToNodeTypeSkuPtrOutputWithContext(context.Background())
}

func (i NodeTypeSkuArgs) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuOutput).ToNodeTypeSkuPtrOutputWithContext(ctx)
}

// NodeTypeSkuPtrInput is an input type that accepts NodeTypeSkuArgs, NodeTypeSkuPtr and NodeTypeSkuPtrOutput values.
// You can construct a concrete instance of `NodeTypeSkuPtrInput` via:
//
//          NodeTypeSkuArgs{...}
//
//  or:
//
//          nil
type NodeTypeSkuPtrInput interface {
	pulumi.Input

	ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput
	ToNodeTypeSkuPtrOutputWithContext(context.Context) NodeTypeSkuPtrOutput
}

type nodeTypeSkuPtrType NodeTypeSkuArgs

func NodeTypeSkuPtr(v *NodeTypeSkuArgs) NodeTypeSkuPtrInput {
	return (*nodeTypeSkuPtrType)(v)
}

func (*nodeTypeSkuPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSku)(nil)).Elem()
}

func (i *nodeTypeSkuPtrType) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return i.ToNodeTypeSkuPtrOutputWithContext(context.Background())
}

func (i *nodeTypeSkuPtrType) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuPtrOutput)
}

// Describes a node type sku.
type NodeTypeSkuOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSku)(nil)).Elem()
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuOutput() NodeTypeSkuOutput {
	return o
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuOutputWithContext(ctx context.Context) NodeTypeSkuOutput {
	return o
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return o.ToNodeTypeSkuPtrOutputWithContext(context.Background())
}

func (o NodeTypeSkuOutput) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return o.ApplyT(func(v NodeTypeSku) *NodeTypeSku {
		return &v
	}).(NodeTypeSkuPtrOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuOutput) Capacity() pulumi.IntOutput {
	return o.ApplyT(func(v NodeTypeSku) int { return v.Capacity }).(pulumi.IntOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSku) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSku) *string { return v.Tier }).(pulumi.StringPtrOutput)
}

type NodeTypeSkuPtrOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSku)(nil)).Elem()
}

func (o NodeTypeSkuPtrOutput) ToNodeTypeSkuPtrOutput() NodeTypeSkuPtrOutput {
	return o
}

func (o NodeTypeSkuPtrOutput) ToNodeTypeSkuPtrOutputWithContext(ctx context.Context) NodeTypeSkuPtrOutput {
	return o
}

func (o NodeTypeSkuPtrOutput) Elem() NodeTypeSkuOutput {
	return o.ApplyT(func(v *NodeTypeSku) NodeTypeSku { return *v }).(NodeTypeSkuOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuPtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NodeTypeSku) *int {
		if v == nil {
			return nil
		}
		return &v.Capacity
	}).(pulumi.IntPtrOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSku) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuPtrOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSku) *string {
		if v == nil {
			return nil
		}
		return v.Tier
	}).(pulumi.StringPtrOutput)
}

// Describes a node type sku.
type NodeTypeSkuResponse struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity int `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name *string `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier *string `pulumi:"tier"`
}

// NodeTypeSkuResponseInput is an input type that accepts NodeTypeSkuResponseArgs and NodeTypeSkuResponseOutput values.
// You can construct a concrete instance of `NodeTypeSkuResponseInput` via:
//
//          NodeTypeSkuResponseArgs{...}
type NodeTypeSkuResponseInput interface {
	pulumi.Input

	ToNodeTypeSkuResponseOutput() NodeTypeSkuResponseOutput
	ToNodeTypeSkuResponseOutputWithContext(context.Context) NodeTypeSkuResponseOutput
}

// Describes a node type sku.
type NodeTypeSkuResponseArgs struct {
	// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
	Capacity pulumi.IntInput `pulumi:"capacity"`
	// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
	Tier pulumi.StringPtrInput `pulumi:"tier"`
}

func (NodeTypeSkuResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSkuResponse)(nil)).Elem()
}

func (i NodeTypeSkuResponseArgs) ToNodeTypeSkuResponseOutput() NodeTypeSkuResponseOutput {
	return i.ToNodeTypeSkuResponseOutputWithContext(context.Background())
}

func (i NodeTypeSkuResponseArgs) ToNodeTypeSkuResponseOutputWithContext(ctx context.Context) NodeTypeSkuResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuResponseOutput)
}

func (i NodeTypeSkuResponseArgs) ToNodeTypeSkuResponsePtrOutput() NodeTypeSkuResponsePtrOutput {
	return i.ToNodeTypeSkuResponsePtrOutputWithContext(context.Background())
}

func (i NodeTypeSkuResponseArgs) ToNodeTypeSkuResponsePtrOutputWithContext(ctx context.Context) NodeTypeSkuResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuResponseOutput).ToNodeTypeSkuResponsePtrOutputWithContext(ctx)
}

// NodeTypeSkuResponsePtrInput is an input type that accepts NodeTypeSkuResponseArgs, NodeTypeSkuResponsePtr and NodeTypeSkuResponsePtrOutput values.
// You can construct a concrete instance of `NodeTypeSkuResponsePtrInput` via:
//
//          NodeTypeSkuResponseArgs{...}
//
//  or:
//
//          nil
type NodeTypeSkuResponsePtrInput interface {
	pulumi.Input

	ToNodeTypeSkuResponsePtrOutput() NodeTypeSkuResponsePtrOutput
	ToNodeTypeSkuResponsePtrOutputWithContext(context.Context) NodeTypeSkuResponsePtrOutput
}

type nodeTypeSkuResponsePtrType NodeTypeSkuResponseArgs

func NodeTypeSkuResponsePtr(v *NodeTypeSkuResponseArgs) NodeTypeSkuResponsePtrInput {
	return (*nodeTypeSkuResponsePtrType)(v)
}

func (*nodeTypeSkuResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSkuResponse)(nil)).Elem()
}

func (i *nodeTypeSkuResponsePtrType) ToNodeTypeSkuResponsePtrOutput() NodeTypeSkuResponsePtrOutput {
	return i.ToNodeTypeSkuResponsePtrOutputWithContext(context.Background())
}

func (i *nodeTypeSkuResponsePtrType) ToNodeTypeSkuResponsePtrOutputWithContext(ctx context.Context) NodeTypeSkuResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeTypeSkuResponsePtrOutput)
}

// Describes a node type sku.
type NodeTypeSkuResponseOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeTypeSkuResponse)(nil)).Elem()
}

func (o NodeTypeSkuResponseOutput) ToNodeTypeSkuResponseOutput() NodeTypeSkuResponseOutput {
	return o
}

func (o NodeTypeSkuResponseOutput) ToNodeTypeSkuResponseOutputWithContext(ctx context.Context) NodeTypeSkuResponseOutput {
	return o
}

func (o NodeTypeSkuResponseOutput) ToNodeTypeSkuResponsePtrOutput() NodeTypeSkuResponsePtrOutput {
	return o.ToNodeTypeSkuResponsePtrOutputWithContext(context.Background())
}

func (o NodeTypeSkuResponseOutput) ToNodeTypeSkuResponsePtrOutputWithContext(ctx context.Context) NodeTypeSkuResponsePtrOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) *NodeTypeSkuResponse {
		return &v
	}).(NodeTypeSkuResponsePtrOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuResponseOutput) Capacity() pulumi.IntOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) int { return v.Capacity }).(pulumi.IntOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuResponseOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NodeTypeSkuResponse) *string { return v.Tier }).(pulumi.StringPtrOutput)
}

type NodeTypeSkuResponsePtrOutput struct{ *pulumi.OutputState }

func (NodeTypeSkuResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodeTypeSkuResponse)(nil)).Elem()
}

func (o NodeTypeSkuResponsePtrOutput) ToNodeTypeSkuResponsePtrOutput() NodeTypeSkuResponsePtrOutput {
	return o
}

func (o NodeTypeSkuResponsePtrOutput) ToNodeTypeSkuResponsePtrOutputWithContext(ctx context.Context) NodeTypeSkuResponsePtrOutput {
	return o
}

func (o NodeTypeSkuResponsePtrOutput) Elem() NodeTypeSkuResponseOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) NodeTypeSkuResponse { return *v }).(NodeTypeSkuResponseOutput)
}

// The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
func (o NodeTypeSkuResponsePtrOutput) Capacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Capacity
	}).(pulumi.IntPtrOutput)
}

// The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
func (o NodeTypeSkuResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
func (o NodeTypeSkuResponsePtrOutput) Tier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodeTypeSkuResponse) *string {
		if v == nil {
			return nil
		}
		return v.Tier
	}).(pulumi.StringPtrOutput)
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanism struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'ScalePartitionInstanceCount'.
	Kind string `pulumi:"kind"`
	// Maximum number of instances of the partition.
	MaxInstanceCount int `pulumi:"maxInstanceCount"`
	// Minimum number of instances of the partition.
	MinInstanceCount int `pulumi:"minInstanceCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// PartitionInstanceCountScaleMechanismInput is an input type that accepts PartitionInstanceCountScaleMechanismArgs and PartitionInstanceCountScaleMechanismOutput values.
// You can construct a concrete instance of `PartitionInstanceCountScaleMechanismInput` via:
//
//          PartitionInstanceCountScaleMechanismArgs{...}
type PartitionInstanceCountScaleMechanismInput interface {
	pulumi.Input

	ToPartitionInstanceCountScaleMechanismOutput() PartitionInstanceCountScaleMechanismOutput
	ToPartitionInstanceCountScaleMechanismOutputWithContext(context.Context) PartitionInstanceCountScaleMechanismOutput
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'ScalePartitionInstanceCount'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// Maximum number of instances of the partition.
	MaxInstanceCount pulumi.IntInput `pulumi:"maxInstanceCount"`
	// Minimum number of instances of the partition.
	MinInstanceCount pulumi.IntInput `pulumi:"minInstanceCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement pulumi.IntInput `pulumi:"scaleIncrement"`
}

func (PartitionInstanceCountScaleMechanismArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PartitionInstanceCountScaleMechanism)(nil)).Elem()
}

func (i PartitionInstanceCountScaleMechanismArgs) ToPartitionInstanceCountScaleMechanismOutput() PartitionInstanceCountScaleMechanismOutput {
	return i.ToPartitionInstanceCountScaleMechanismOutputWithContext(context.Background())
}

func (i PartitionInstanceCountScaleMechanismArgs) ToPartitionInstanceCountScaleMechanismOutputWithContext(ctx context.Context) PartitionInstanceCountScaleMechanismOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PartitionInstanceCountScaleMechanismOutput)
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismOutput struct{ *pulumi.OutputState }

func (PartitionInstanceCountScaleMechanismOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PartitionInstanceCountScaleMechanism)(nil)).Elem()
}

func (o PartitionInstanceCountScaleMechanismOutput) ToPartitionInstanceCountScaleMechanismOutput() PartitionInstanceCountScaleMechanismOutput {
	return o
}

func (o PartitionInstanceCountScaleMechanismOutput) ToPartitionInstanceCountScaleMechanismOutputWithContext(ctx context.Context) PartitionInstanceCountScaleMechanismOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'ScalePartitionInstanceCount'.
func (o PartitionInstanceCountScaleMechanismOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanism) string { return v.Kind }).(pulumi.StringOutput)
}

// Maximum number of instances of the partition.
func (o PartitionInstanceCountScaleMechanismOutput) MaxInstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanism) int { return v.MaxInstanceCount }).(pulumi.IntOutput)
}

// Minimum number of instances of the partition.
func (o PartitionInstanceCountScaleMechanismOutput) MinInstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanism) int { return v.MinInstanceCount }).(pulumi.IntOutput)
}

// The number of instances to add or remove during a scaling operation.
func (o PartitionInstanceCountScaleMechanismOutput) ScaleIncrement() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanism) int { return v.ScaleIncrement }).(pulumi.IntOutput)
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'ScalePartitionInstanceCount'.
	Kind string `pulumi:"kind"`
	// Maximum number of instances of the partition.
	MaxInstanceCount int `pulumi:"maxInstanceCount"`
	// Minimum number of instances of the partition.
	MinInstanceCount int `pulumi:"minInstanceCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement int `pulumi:"scaleIncrement"`
}

// PartitionInstanceCountScaleMechanismResponseInput is an input type that accepts PartitionInstanceCountScaleMechanismResponseArgs and PartitionInstanceCountScaleMechanismResponseOutput values.
// You can construct a concrete instance of `PartitionInstanceCountScaleMechanismResponseInput` via:
//
//          PartitionInstanceCountScaleMechanismResponseArgs{...}
type PartitionInstanceCountScaleMechanismResponseInput interface {
	pulumi.Input

	ToPartitionInstanceCountScaleMechanismResponseOutput() PartitionInstanceCountScaleMechanismResponseOutput
	ToPartitionInstanceCountScaleMechanismResponseOutputWithContext(context.Context) PartitionInstanceCountScaleMechanismResponseOutput
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismResponseArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'ScalePartitionInstanceCount'.
	Kind pulumi.StringInput `pulumi:"kind"`
	// Maximum number of instances of the partition.
	MaxInstanceCount pulumi.IntInput `pulumi:"maxInstanceCount"`
	// Minimum number of instances of the partition.
	MinInstanceCount pulumi.IntInput `pulumi:"minInstanceCount"`
	// The number of instances to add or remove during a scaling operation.
	ScaleIncrement pulumi.IntInput `pulumi:"scaleIncrement"`
}

func (PartitionInstanceCountScaleMechanismResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PartitionInstanceCountScaleMechanismResponse)(nil)).Elem()
}

func (i PartitionInstanceCountScaleMechanismResponseArgs) ToPartitionInstanceCountScaleMechanismResponseOutput() PartitionInstanceCountScaleMechanismResponseOutput {
	return i.ToPartitionInstanceCountScaleMechanismResponseOutputWithContext(context.Background())
}

func (i PartitionInstanceCountScaleMechanismResponseArgs) ToPartitionInstanceCountScaleMechanismResponseOutputWithContext(ctx context.Context) PartitionInstanceCountScaleMechanismResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PartitionInstanceCountScaleMechanismResponseOutput)
}

// Represents a scaling mechanism for adding or removing instances of stateless service partition.
type PartitionInstanceCountScaleMechanismResponseOutput struct{ *pulumi.OutputState }

func (PartitionInstanceCountScaleMechanismResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PartitionInstanceCountScaleMechanismResponse)(nil)).Elem()
}

func (o PartitionInstanceCountScaleMechanismResponseOutput) ToPartitionInstanceCountScaleMechanismResponseOutput() PartitionInstanceCountScaleMechanismResponseOutput {
	return o
}

func (o PartitionInstanceCountScaleMechanismResponseOutput) ToPartitionInstanceCountScaleMechanismResponseOutputWithContext(ctx context.Context) PartitionInstanceCountScaleMechanismResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'ScalePartitionInstanceCount'.
func (o PartitionInstanceCountScaleMechanismResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanismResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// Maximum number of instances of the partition.
func (o PartitionInstanceCountScaleMechanismResponseOutput) MaxInstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanismResponse) int { return v.MaxInstanceCount }).(pulumi.IntOutput)
}

// Minimum number of instances of the partition.
func (o PartitionInstanceCountScaleMechanismResponseOutput) MinInstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanismResponse) int { return v.MinInstanceCount }).(pulumi.IntOutput)
}

// The number of instances to add or remove during a scaling operation.
func (o PartitionInstanceCountScaleMechanismResponseOutput) ScaleIncrement() pulumi.IntOutput {
	return o.ApplyT(func(v PartitionInstanceCountScaleMechanismResponse) int { return v.ScaleIncrement }).(pulumi.IntOutput)
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicy struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction string `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout string `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration string `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration string `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout string `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout string `pulumi:"upgradeTimeout"`
}

// RollingUpgradeMonitoringPolicyInput is an input type that accepts RollingUpgradeMonitoringPolicyArgs and RollingUpgradeMonitoringPolicyOutput values.
// You can construct a concrete instance of `RollingUpgradeMonitoringPolicyInput` via:
//
//          RollingUpgradeMonitoringPolicyArgs{...}
type RollingUpgradeMonitoringPolicyInput interface {
	pulumi.Input

	ToRollingUpgradeMonitoringPolicyOutput() RollingUpgradeMonitoringPolicyOutput
	ToRollingUpgradeMonitoringPolicyOutputWithContext(context.Context) RollingUpgradeMonitoringPolicyOutput
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyArgs struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction pulumi.StringInput `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout pulumi.StringInput `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration pulumi.StringInput `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration pulumi.StringInput `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout pulumi.StringInput `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout pulumi.StringInput `pulumi:"upgradeTimeout"`
}

func (RollingUpgradeMonitoringPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyOutput() RollingUpgradeMonitoringPolicyOutput {
	return i.ToRollingUpgradeMonitoringPolicyOutputWithContext(context.Background())
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyOutput)
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return i.ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (i RollingUpgradeMonitoringPolicyArgs) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyOutput).ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx)
}

// RollingUpgradeMonitoringPolicyPtrInput is an input type that accepts RollingUpgradeMonitoringPolicyArgs, RollingUpgradeMonitoringPolicyPtr and RollingUpgradeMonitoringPolicyPtrOutput values.
// You can construct a concrete instance of `RollingUpgradeMonitoringPolicyPtrInput` via:
//
//          RollingUpgradeMonitoringPolicyArgs{...}
//
//  or:
//
//          nil
type RollingUpgradeMonitoringPolicyPtrInput interface {
	pulumi.Input

	ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput
	ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Context) RollingUpgradeMonitoringPolicyPtrOutput
}

type rollingUpgradeMonitoringPolicyPtrType RollingUpgradeMonitoringPolicyArgs

func RollingUpgradeMonitoringPolicyPtr(v *RollingUpgradeMonitoringPolicyArgs) RollingUpgradeMonitoringPolicyPtrInput {
	return (*rollingUpgradeMonitoringPolicyPtrType)(v)
}

func (*rollingUpgradeMonitoringPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (i *rollingUpgradeMonitoringPolicyPtrType) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return i.ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (i *rollingUpgradeMonitoringPolicyPtrType) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyOutput() RollingUpgradeMonitoringPolicyOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(context.Background())
}

func (o RollingUpgradeMonitoringPolicyOutput) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) *RollingUpgradeMonitoringPolicy {
		return &v
	}).(RollingUpgradeMonitoringPolicyPtrOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyOutput) FailureAction() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.FailureAction }).(pulumi.StringOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) HealthCheckRetryTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.HealthCheckRetryTimeout }).(pulumi.StringOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) HealthCheckStableDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.HealthCheckStableDuration }).(pulumi.StringOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) HealthCheckWaitDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.HealthCheckWaitDuration }).(pulumi.StringOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) UpgradeDomainTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.UpgradeDomainTimeout }).(pulumi.StringOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyOutput) UpgradeTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicy) string { return v.UpgradeTimeout }).(pulumi.StringOutput)
}

type RollingUpgradeMonitoringPolicyPtrOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicy)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyPtrOutput) ToRollingUpgradeMonitoringPolicyPtrOutput() RollingUpgradeMonitoringPolicyPtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyPtrOutput) ToRollingUpgradeMonitoringPolicyPtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyPtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyPtrOutput) Elem() RollingUpgradeMonitoringPolicyOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) RollingUpgradeMonitoringPolicy { return *v }).(RollingUpgradeMonitoringPolicyOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyPtrOutput) FailureAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.FailureAction
	}).(pulumi.StringPtrOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) HealthCheckRetryTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckRetryTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) HealthCheckStableDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckStableDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) HealthCheckWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckWaitDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) UpgradeDomainTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeDomainTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyPtrOutput) UpgradeTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicy) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeTimeout
	}).(pulumi.StringPtrOutput)
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyResponse struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction string `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout string `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration string `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration string `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout string `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout string `pulumi:"upgradeTimeout"`
}

// RollingUpgradeMonitoringPolicyResponseInput is an input type that accepts RollingUpgradeMonitoringPolicyResponseArgs and RollingUpgradeMonitoringPolicyResponseOutput values.
// You can construct a concrete instance of `RollingUpgradeMonitoringPolicyResponseInput` via:
//
//          RollingUpgradeMonitoringPolicyResponseArgs{...}
type RollingUpgradeMonitoringPolicyResponseInput interface {
	pulumi.Input

	ToRollingUpgradeMonitoringPolicyResponseOutput() RollingUpgradeMonitoringPolicyResponseOutput
	ToRollingUpgradeMonitoringPolicyResponseOutputWithContext(context.Context) RollingUpgradeMonitoringPolicyResponseOutput
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyResponseArgs struct {
	// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
	FailureAction pulumi.StringInput `pulumi:"failureAction"`
	// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckRetryTimeout pulumi.StringInput `pulumi:"healthCheckRetryTimeout"`
	// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckStableDuration pulumi.StringInput `pulumi:"healthCheckStableDuration"`
	// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	HealthCheckWaitDuration pulumi.StringInput `pulumi:"healthCheckWaitDuration"`
	// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeDomainTimeout pulumi.StringInput `pulumi:"upgradeDomainTimeout"`
	// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
	UpgradeTimeout pulumi.StringInput `pulumi:"upgradeTimeout"`
}

func (RollingUpgradeMonitoringPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicyResponse)(nil)).Elem()
}

func (i RollingUpgradeMonitoringPolicyResponseArgs) ToRollingUpgradeMonitoringPolicyResponseOutput() RollingUpgradeMonitoringPolicyResponseOutput {
	return i.ToRollingUpgradeMonitoringPolicyResponseOutputWithContext(context.Background())
}

func (i RollingUpgradeMonitoringPolicyResponseArgs) ToRollingUpgradeMonitoringPolicyResponseOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyResponseOutput)
}

func (i RollingUpgradeMonitoringPolicyResponseArgs) ToRollingUpgradeMonitoringPolicyResponsePtrOutput() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return i.ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(context.Background())
}

func (i RollingUpgradeMonitoringPolicyResponseArgs) ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyResponseOutput).ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(ctx)
}

// RollingUpgradeMonitoringPolicyResponsePtrInput is an input type that accepts RollingUpgradeMonitoringPolicyResponseArgs, RollingUpgradeMonitoringPolicyResponsePtr and RollingUpgradeMonitoringPolicyResponsePtrOutput values.
// You can construct a concrete instance of `RollingUpgradeMonitoringPolicyResponsePtrInput` via:
//
//          RollingUpgradeMonitoringPolicyResponseArgs{...}
//
//  or:
//
//          nil
type RollingUpgradeMonitoringPolicyResponsePtrInput interface {
	pulumi.Input

	ToRollingUpgradeMonitoringPolicyResponsePtrOutput() RollingUpgradeMonitoringPolicyResponsePtrOutput
	ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(context.Context) RollingUpgradeMonitoringPolicyResponsePtrOutput
}

type rollingUpgradeMonitoringPolicyResponsePtrType RollingUpgradeMonitoringPolicyResponseArgs

func RollingUpgradeMonitoringPolicyResponsePtr(v *RollingUpgradeMonitoringPolicyResponseArgs) RollingUpgradeMonitoringPolicyResponsePtrInput {
	return (*rollingUpgradeMonitoringPolicyResponsePtrType)(v)
}

func (*rollingUpgradeMonitoringPolicyResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicyResponse)(nil)).Elem()
}

func (i *rollingUpgradeMonitoringPolicyResponsePtrType) ToRollingUpgradeMonitoringPolicyResponsePtrOutput() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return i.ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(context.Background())
}

func (i *rollingUpgradeMonitoringPolicyResponsePtrType) ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RollingUpgradeMonitoringPolicyResponsePtrOutput)
}

// The policy used for monitoring the application upgrade
type RollingUpgradeMonitoringPolicyResponseOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RollingUpgradeMonitoringPolicyResponse)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyResponseOutput) ToRollingUpgradeMonitoringPolicyResponseOutput() RollingUpgradeMonitoringPolicyResponseOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponseOutput) ToRollingUpgradeMonitoringPolicyResponseOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponseOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponseOutput) ToRollingUpgradeMonitoringPolicyResponsePtrOutput() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o.ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(context.Background())
}

func (o RollingUpgradeMonitoringPolicyResponseOutput) ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) *RollingUpgradeMonitoringPolicyResponse {
		return &v
	}).(RollingUpgradeMonitoringPolicyResponsePtrOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyResponseOutput) FailureAction() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.FailureAction }).(pulumi.StringOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) HealthCheckRetryTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.HealthCheckRetryTimeout }).(pulumi.StringOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) HealthCheckStableDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.HealthCheckStableDuration }).(pulumi.StringOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) HealthCheckWaitDuration() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.HealthCheckWaitDuration }).(pulumi.StringOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) UpgradeDomainTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.UpgradeDomainTimeout }).(pulumi.StringOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponseOutput) UpgradeTimeout() pulumi.StringOutput {
	return o.ApplyT(func(v RollingUpgradeMonitoringPolicyResponse) string { return v.UpgradeTimeout }).(pulumi.StringOutput)
}

type RollingUpgradeMonitoringPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (RollingUpgradeMonitoringPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RollingUpgradeMonitoringPolicyResponse)(nil)).Elem()
}

func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) ToRollingUpgradeMonitoringPolicyResponsePtrOutput() RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) ToRollingUpgradeMonitoringPolicyResponsePtrOutputWithContext(ctx context.Context) RollingUpgradeMonitoringPolicyResponsePtrOutput {
	return o
}

func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) Elem() RollingUpgradeMonitoringPolicyResponseOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) RollingUpgradeMonitoringPolicyResponse { return *v }).(RollingUpgradeMonitoringPolicyResponseOutput)
}

// The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) FailureAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.FailureAction
	}).(pulumi.StringPtrOutput)
}

// The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) HealthCheckRetryTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckRetryTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) HealthCheckStableDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckStableDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) HealthCheckWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HealthCheckWaitDuration
	}).(pulumi.StringPtrOutput)
}

// The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) UpgradeDomainTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeDomainTimeout
	}).(pulumi.StringPtrOutput)
}

// The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
func (o RollingUpgradeMonitoringPolicyResponsePtrOutput) UpgradeTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RollingUpgradeMonitoringPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UpgradeTimeout
	}).(pulumi.StringPtrOutput)
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicy struct {
	// Specifies the mechanism associated with this scaling policy
	ScalingMechanism interface{} `pulumi:"scalingMechanism"`
	// Specifies the trigger associated with this scaling policy.
	ScalingTrigger interface{} `pulumi:"scalingTrigger"`
}

// ScalingPolicyInput is an input type that accepts ScalingPolicyArgs and ScalingPolicyOutput values.
// You can construct a concrete instance of `ScalingPolicyInput` via:
//
//          ScalingPolicyArgs{...}
type ScalingPolicyInput interface {
	pulumi.Input

	ToScalingPolicyOutput() ScalingPolicyOutput
	ToScalingPolicyOutputWithContext(context.Context) ScalingPolicyOutput
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyArgs struct {
	// Specifies the mechanism associated with this scaling policy
	ScalingMechanism pulumi.Input `pulumi:"scalingMechanism"`
	// Specifies the trigger associated with this scaling policy.
	ScalingTrigger pulumi.Input `pulumi:"scalingTrigger"`
}

func (ScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScalingPolicy)(nil)).Elem()
}

func (i ScalingPolicyArgs) ToScalingPolicyOutput() ScalingPolicyOutput {
	return i.ToScalingPolicyOutputWithContext(context.Background())
}

func (i ScalingPolicyArgs) ToScalingPolicyOutputWithContext(ctx context.Context) ScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScalingPolicyOutput)
}

// ScalingPolicyArrayInput is an input type that accepts ScalingPolicyArray and ScalingPolicyArrayOutput values.
// You can construct a concrete instance of `ScalingPolicyArrayInput` via:
//
//          ScalingPolicyArray{ ScalingPolicyArgs{...} }
type ScalingPolicyArrayInput interface {
	pulumi.Input

	ToScalingPolicyArrayOutput() ScalingPolicyArrayOutput
	ToScalingPolicyArrayOutputWithContext(context.Context) ScalingPolicyArrayOutput
}

type ScalingPolicyArray []ScalingPolicyInput

func (ScalingPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScalingPolicy)(nil)).Elem()
}

func (i ScalingPolicyArray) ToScalingPolicyArrayOutput() ScalingPolicyArrayOutput {
	return i.ToScalingPolicyArrayOutputWithContext(context.Background())
}

func (i ScalingPolicyArray) ToScalingPolicyArrayOutputWithContext(ctx context.Context) ScalingPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScalingPolicyArrayOutput)
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyOutput struct{ *pulumi.OutputState }

func (ScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScalingPolicy)(nil)).Elem()
}

func (o ScalingPolicyOutput) ToScalingPolicyOutput() ScalingPolicyOutput {
	return o
}

func (o ScalingPolicyOutput) ToScalingPolicyOutputWithContext(ctx context.Context) ScalingPolicyOutput {
	return o
}

// Specifies the mechanism associated with this scaling policy
func (o ScalingPolicyOutput) ScalingMechanism() pulumi.AnyOutput {
	return o.ApplyT(func(v ScalingPolicy) interface{} { return v.ScalingMechanism }).(pulumi.AnyOutput)
}

// Specifies the trigger associated with this scaling policy.
func (o ScalingPolicyOutput) ScalingTrigger() pulumi.AnyOutput {
	return o.ApplyT(func(v ScalingPolicy) interface{} { return v.ScalingTrigger }).(pulumi.AnyOutput)
}

type ScalingPolicyArrayOutput struct{ *pulumi.OutputState }

func (ScalingPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScalingPolicy)(nil)).Elem()
}

func (o ScalingPolicyArrayOutput) ToScalingPolicyArrayOutput() ScalingPolicyArrayOutput {
	return o
}

func (o ScalingPolicyArrayOutput) ToScalingPolicyArrayOutputWithContext(ctx context.Context) ScalingPolicyArrayOutput {
	return o
}

func (o ScalingPolicyArrayOutput) Index(i pulumi.IntInput) ScalingPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ScalingPolicy {
		return vs[0].([]ScalingPolicy)[vs[1].(int)]
	}).(ScalingPolicyOutput)
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyResponse struct {
	// Specifies the mechanism associated with this scaling policy
	ScalingMechanism interface{} `pulumi:"scalingMechanism"`
	// Specifies the trigger associated with this scaling policy.
	ScalingTrigger interface{} `pulumi:"scalingTrigger"`
}

// ScalingPolicyResponseInput is an input type that accepts ScalingPolicyResponseArgs and ScalingPolicyResponseOutput values.
// You can construct a concrete instance of `ScalingPolicyResponseInput` via:
//
//          ScalingPolicyResponseArgs{...}
type ScalingPolicyResponseInput interface {
	pulumi.Input

	ToScalingPolicyResponseOutput() ScalingPolicyResponseOutput
	ToScalingPolicyResponseOutputWithContext(context.Context) ScalingPolicyResponseOutput
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyResponseArgs struct {
	// Specifies the mechanism associated with this scaling policy
	ScalingMechanism pulumi.Input `pulumi:"scalingMechanism"`
	// Specifies the trigger associated with this scaling policy.
	ScalingTrigger pulumi.Input `pulumi:"scalingTrigger"`
}

func (ScalingPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScalingPolicyResponse)(nil)).Elem()
}

func (i ScalingPolicyResponseArgs) ToScalingPolicyResponseOutput() ScalingPolicyResponseOutput {
	return i.ToScalingPolicyResponseOutputWithContext(context.Background())
}

func (i ScalingPolicyResponseArgs) ToScalingPolicyResponseOutputWithContext(ctx context.Context) ScalingPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScalingPolicyResponseOutput)
}

// ScalingPolicyResponseArrayInput is an input type that accepts ScalingPolicyResponseArray and ScalingPolicyResponseArrayOutput values.
// You can construct a concrete instance of `ScalingPolicyResponseArrayInput` via:
//
//          ScalingPolicyResponseArray{ ScalingPolicyResponseArgs{...} }
type ScalingPolicyResponseArrayInput interface {
	pulumi.Input

	ToScalingPolicyResponseArrayOutput() ScalingPolicyResponseArrayOutput
	ToScalingPolicyResponseArrayOutputWithContext(context.Context) ScalingPolicyResponseArrayOutput
}

type ScalingPolicyResponseArray []ScalingPolicyResponseInput

func (ScalingPolicyResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScalingPolicyResponse)(nil)).Elem()
}

func (i ScalingPolicyResponseArray) ToScalingPolicyResponseArrayOutput() ScalingPolicyResponseArrayOutput {
	return i.ToScalingPolicyResponseArrayOutputWithContext(context.Background())
}

func (i ScalingPolicyResponseArray) ToScalingPolicyResponseArrayOutputWithContext(ctx context.Context) ScalingPolicyResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScalingPolicyResponseArrayOutput)
}

// Specifies a metric to load balance a service during runtime.
type ScalingPolicyResponseOutput struct{ *pulumi.OutputState }

func (ScalingPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScalingPolicyResponse)(nil)).Elem()
}

func (o ScalingPolicyResponseOutput) ToScalingPolicyResponseOutput() ScalingPolicyResponseOutput {
	return o
}

func (o ScalingPolicyResponseOutput) ToScalingPolicyResponseOutputWithContext(ctx context.Context) ScalingPolicyResponseOutput {
	return o
}

// Specifies the mechanism associated with this scaling policy
func (o ScalingPolicyResponseOutput) ScalingMechanism() pulumi.AnyOutput {
	return o.ApplyT(func(v ScalingPolicyResponse) interface{} { return v.ScalingMechanism }).(pulumi.AnyOutput)
}

// Specifies the trigger associated with this scaling policy.
func (o ScalingPolicyResponseOutput) ScalingTrigger() pulumi.AnyOutput {
	return o.ApplyT(func(v ScalingPolicyResponse) interface{} { return v.ScalingTrigger }).(pulumi.AnyOutput)
}

type ScalingPolicyResponseArrayOutput struct{ *pulumi.OutputState }

func (ScalingPolicyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScalingPolicyResponse)(nil)).Elem()
}

func (o ScalingPolicyResponseArrayOutput) ToScalingPolicyResponseArrayOutput() ScalingPolicyResponseArrayOutput {
	return o
}

func (o ScalingPolicyResponseArrayOutput) ToScalingPolicyResponseArrayOutputWithContext(ctx context.Context) ScalingPolicyResponseArrayOutput {
	return o
}

func (o ScalingPolicyResponseArrayOutput) Index(i pulumi.IntInput) ScalingPolicyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ScalingPolicyResponse {
		return vs[0].([]ScalingPolicyResponse)[vs[1].(int)]
	}).(ScalingPolicyResponseOutput)
}

// Creates a particular correlation between services.
type ServiceCorrelation struct {
	// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme string `pulumi:"scheme"`
	// The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName string `pulumi:"serviceName"`
}

// ServiceCorrelationInput is an input type that accepts ServiceCorrelationArgs and ServiceCorrelationOutput values.
// You can construct a concrete instance of `ServiceCorrelationInput` via:
//
//          ServiceCorrelationArgs{...}
type ServiceCorrelationInput interface {
	pulumi.Input

	ToServiceCorrelationOutput() ServiceCorrelationOutput
	ToServiceCorrelationOutputWithContext(context.Context) ServiceCorrelationOutput
}

// Creates a particular correlation between services.
type ServiceCorrelationArgs struct {
	// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme pulumi.StringInput `pulumi:"scheme"`
	// The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName pulumi.StringInput `pulumi:"serviceName"`
}

func (ServiceCorrelationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceCorrelation)(nil)).Elem()
}

func (i ServiceCorrelationArgs) ToServiceCorrelationOutput() ServiceCorrelationOutput {
	return i.ToServiceCorrelationOutputWithContext(context.Background())
}

func (i ServiceCorrelationArgs) ToServiceCorrelationOutputWithContext(ctx context.Context) ServiceCorrelationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceCorrelationOutput)
}

// ServiceCorrelationArrayInput is an input type that accepts ServiceCorrelationArray and ServiceCorrelationArrayOutput values.
// You can construct a concrete instance of `ServiceCorrelationArrayInput` via:
//
//          ServiceCorrelationArray{ ServiceCorrelationArgs{...} }
type ServiceCorrelationArrayInput interface {
	pulumi.Input

	ToServiceCorrelationArrayOutput() ServiceCorrelationArrayOutput
	ToServiceCorrelationArrayOutputWithContext(context.Context) ServiceCorrelationArrayOutput
}

type ServiceCorrelationArray []ServiceCorrelationInput

func (ServiceCorrelationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceCorrelation)(nil)).Elem()
}

func (i ServiceCorrelationArray) ToServiceCorrelationArrayOutput() ServiceCorrelationArrayOutput {
	return i.ToServiceCorrelationArrayOutputWithContext(context.Background())
}

func (i ServiceCorrelationArray) ToServiceCorrelationArrayOutputWithContext(ctx context.Context) ServiceCorrelationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceCorrelationArrayOutput)
}

// Creates a particular correlation between services.
type ServiceCorrelationOutput struct{ *pulumi.OutputState }

func (ServiceCorrelationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceCorrelation)(nil)).Elem()
}

func (o ServiceCorrelationOutput) ToServiceCorrelationOutput() ServiceCorrelationOutput {
	return o
}

func (o ServiceCorrelationOutput) ToServiceCorrelationOutputWithContext(ctx context.Context) ServiceCorrelationOutput {
	return o
}

// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
func (o ServiceCorrelationOutput) Scheme() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceCorrelation) string { return v.Scheme }).(pulumi.StringOutput)
}

// The Arm Resource ID of the service that the correlation relationship is established with.
func (o ServiceCorrelationOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceCorrelation) string { return v.ServiceName }).(pulumi.StringOutput)
}

type ServiceCorrelationArrayOutput struct{ *pulumi.OutputState }

func (ServiceCorrelationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceCorrelation)(nil)).Elem()
}

func (o ServiceCorrelationArrayOutput) ToServiceCorrelationArrayOutput() ServiceCorrelationArrayOutput {
	return o
}

func (o ServiceCorrelationArrayOutput) ToServiceCorrelationArrayOutputWithContext(ctx context.Context) ServiceCorrelationArrayOutput {
	return o
}

func (o ServiceCorrelationArrayOutput) Index(i pulumi.IntInput) ServiceCorrelationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceCorrelation {
		return vs[0].([]ServiceCorrelation)[vs[1].(int)]
	}).(ServiceCorrelationOutput)
}

// Creates a particular correlation between services.
type ServiceCorrelationResponse struct {
	// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme string `pulumi:"scheme"`
	// The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName string `pulumi:"serviceName"`
}

// ServiceCorrelationResponseInput is an input type that accepts ServiceCorrelationResponseArgs and ServiceCorrelationResponseOutput values.
// You can construct a concrete instance of `ServiceCorrelationResponseInput` via:
//
//          ServiceCorrelationResponseArgs{...}
type ServiceCorrelationResponseInput interface {
	pulumi.Input

	ToServiceCorrelationResponseOutput() ServiceCorrelationResponseOutput
	ToServiceCorrelationResponseOutputWithContext(context.Context) ServiceCorrelationResponseOutput
}

// Creates a particular correlation between services.
type ServiceCorrelationResponseArgs struct {
	// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
	Scheme pulumi.StringInput `pulumi:"scheme"`
	// The Arm Resource ID of the service that the correlation relationship is established with.
	ServiceName pulumi.StringInput `pulumi:"serviceName"`
}

func (ServiceCorrelationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceCorrelationResponse)(nil)).Elem()
}

func (i ServiceCorrelationResponseArgs) ToServiceCorrelationResponseOutput() ServiceCorrelationResponseOutput {
	return i.ToServiceCorrelationResponseOutputWithContext(context.Background())
}

func (i ServiceCorrelationResponseArgs) ToServiceCorrelationResponseOutputWithContext(ctx context.Context) ServiceCorrelationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceCorrelationResponseOutput)
}

// ServiceCorrelationResponseArrayInput is an input type that accepts ServiceCorrelationResponseArray and ServiceCorrelationResponseArrayOutput values.
// You can construct a concrete instance of `ServiceCorrelationResponseArrayInput` via:
//
//          ServiceCorrelationResponseArray{ ServiceCorrelationResponseArgs{...} }
type ServiceCorrelationResponseArrayInput interface {
	pulumi.Input

	ToServiceCorrelationResponseArrayOutput() ServiceCorrelationResponseArrayOutput
	ToServiceCorrelationResponseArrayOutputWithContext(context.Context) ServiceCorrelationResponseArrayOutput
}

type ServiceCorrelationResponseArray []ServiceCorrelationResponseInput

func (ServiceCorrelationResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceCorrelationResponse)(nil)).Elem()
}

func (i ServiceCorrelationResponseArray) ToServiceCorrelationResponseArrayOutput() ServiceCorrelationResponseArrayOutput {
	return i.ToServiceCorrelationResponseArrayOutputWithContext(context.Background())
}

func (i ServiceCorrelationResponseArray) ToServiceCorrelationResponseArrayOutputWithContext(ctx context.Context) ServiceCorrelationResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceCorrelationResponseArrayOutput)
}

// Creates a particular correlation between services.
type ServiceCorrelationResponseOutput struct{ *pulumi.OutputState }

func (ServiceCorrelationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceCorrelationResponse)(nil)).Elem()
}

func (o ServiceCorrelationResponseOutput) ToServiceCorrelationResponseOutput() ServiceCorrelationResponseOutput {
	return o
}

func (o ServiceCorrelationResponseOutput) ToServiceCorrelationResponseOutputWithContext(ctx context.Context) ServiceCorrelationResponseOutput {
	return o
}

// The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
func (o ServiceCorrelationResponseOutput) Scheme() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceCorrelationResponse) string { return v.Scheme }).(pulumi.StringOutput)
}

// The Arm Resource ID of the service that the correlation relationship is established with.
func (o ServiceCorrelationResponseOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceCorrelationResponse) string { return v.ServiceName }).(pulumi.StringOutput)
}

type ServiceCorrelationResponseArrayOutput struct{ *pulumi.OutputState }

func (ServiceCorrelationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceCorrelationResponse)(nil)).Elem()
}

func (o ServiceCorrelationResponseArrayOutput) ToServiceCorrelationResponseArrayOutput() ServiceCorrelationResponseArrayOutput {
	return o
}

func (o ServiceCorrelationResponseArrayOutput) ToServiceCorrelationResponseArrayOutputWithContext(ctx context.Context) ServiceCorrelationResponseArrayOutput {
	return o
}

func (o ServiceCorrelationResponseArrayOutput) Index(i pulumi.IntInput) ServiceCorrelationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceCorrelationResponse {
		return vs[0].([]ServiceCorrelationResponse)[vs[1].(int)]
	}).(ServiceCorrelationResponseOutput)
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetric struct {
	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad *int `pulumi:"defaultLoad"`
	// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name string `pulumi:"name"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad *int `pulumi:"primaryDefaultLoad"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad *int `pulumi:"secondaryDefaultLoad"`
	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight *string `pulumi:"weight"`
}

// ServiceLoadMetricInput is an input type that accepts ServiceLoadMetricArgs and ServiceLoadMetricOutput values.
// You can construct a concrete instance of `ServiceLoadMetricInput` via:
//
//          ServiceLoadMetricArgs{...}
type ServiceLoadMetricInput interface {
	pulumi.Input

	ToServiceLoadMetricOutput() ServiceLoadMetricOutput
	ToServiceLoadMetricOutputWithContext(context.Context) ServiceLoadMetricOutput
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricArgs struct {
	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad pulumi.IntPtrInput `pulumi:"defaultLoad"`
	// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name pulumi.StringInput `pulumi:"name"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad pulumi.IntPtrInput `pulumi:"primaryDefaultLoad"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad pulumi.IntPtrInput `pulumi:"secondaryDefaultLoad"`
	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight pulumi.StringPtrInput `pulumi:"weight"`
}

func (ServiceLoadMetricArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLoadMetric)(nil)).Elem()
}

func (i ServiceLoadMetricArgs) ToServiceLoadMetricOutput() ServiceLoadMetricOutput {
	return i.ToServiceLoadMetricOutputWithContext(context.Background())
}

func (i ServiceLoadMetricArgs) ToServiceLoadMetricOutputWithContext(ctx context.Context) ServiceLoadMetricOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLoadMetricOutput)
}

// ServiceLoadMetricArrayInput is an input type that accepts ServiceLoadMetricArray and ServiceLoadMetricArrayOutput values.
// You can construct a concrete instance of `ServiceLoadMetricArrayInput` via:
//
//          ServiceLoadMetricArray{ ServiceLoadMetricArgs{...} }
type ServiceLoadMetricArrayInput interface {
	pulumi.Input

	ToServiceLoadMetricArrayOutput() ServiceLoadMetricArrayOutput
	ToServiceLoadMetricArrayOutputWithContext(context.Context) ServiceLoadMetricArrayOutput
}

type ServiceLoadMetricArray []ServiceLoadMetricInput

func (ServiceLoadMetricArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceLoadMetric)(nil)).Elem()
}

func (i ServiceLoadMetricArray) ToServiceLoadMetricArrayOutput() ServiceLoadMetricArrayOutput {
	return i.ToServiceLoadMetricArrayOutputWithContext(context.Background())
}

func (i ServiceLoadMetricArray) ToServiceLoadMetricArrayOutputWithContext(ctx context.Context) ServiceLoadMetricArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLoadMetricArrayOutput)
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricOutput struct{ *pulumi.OutputState }

func (ServiceLoadMetricOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLoadMetric)(nil)).Elem()
}

func (o ServiceLoadMetricOutput) ToServiceLoadMetricOutput() ServiceLoadMetricOutput {
	return o
}

func (o ServiceLoadMetricOutput) ToServiceLoadMetricOutputWithContext(ctx context.Context) ServiceLoadMetricOutput {
	return o
}

// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
func (o ServiceLoadMetricOutput) DefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetric) *int { return v.DefaultLoad }).(pulumi.IntPtrOutput)
}

// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
func (o ServiceLoadMetricOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceLoadMetric) string { return v.Name }).(pulumi.StringOutput)
}

// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
func (o ServiceLoadMetricOutput) PrimaryDefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetric) *int { return v.PrimaryDefaultLoad }).(pulumi.IntPtrOutput)
}

// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
func (o ServiceLoadMetricOutput) SecondaryDefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetric) *int { return v.SecondaryDefaultLoad }).(pulumi.IntPtrOutput)
}

// The service load metric relative weight, compared to other metrics configured for this service, as a number.
func (o ServiceLoadMetricOutput) Weight() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetric) *string { return v.Weight }).(pulumi.StringPtrOutput)
}

type ServiceLoadMetricArrayOutput struct{ *pulumi.OutputState }

func (ServiceLoadMetricArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceLoadMetric)(nil)).Elem()
}

func (o ServiceLoadMetricArrayOutput) ToServiceLoadMetricArrayOutput() ServiceLoadMetricArrayOutput {
	return o
}

func (o ServiceLoadMetricArrayOutput) ToServiceLoadMetricArrayOutputWithContext(ctx context.Context) ServiceLoadMetricArrayOutput {
	return o
}

func (o ServiceLoadMetricArrayOutput) Index(i pulumi.IntInput) ServiceLoadMetricOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceLoadMetric {
		return vs[0].([]ServiceLoadMetric)[vs[1].(int)]
	}).(ServiceLoadMetricOutput)
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricResponse struct {
	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad *int `pulumi:"defaultLoad"`
	// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name string `pulumi:"name"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad *int `pulumi:"primaryDefaultLoad"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad *int `pulumi:"secondaryDefaultLoad"`
	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight *string `pulumi:"weight"`
}

// ServiceLoadMetricResponseInput is an input type that accepts ServiceLoadMetricResponseArgs and ServiceLoadMetricResponseOutput values.
// You can construct a concrete instance of `ServiceLoadMetricResponseInput` via:
//
//          ServiceLoadMetricResponseArgs{...}
type ServiceLoadMetricResponseInput interface {
	pulumi.Input

	ToServiceLoadMetricResponseOutput() ServiceLoadMetricResponseOutput
	ToServiceLoadMetricResponseOutputWithContext(context.Context) ServiceLoadMetricResponseOutput
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricResponseArgs struct {
	// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
	DefaultLoad pulumi.IntPtrInput `pulumi:"defaultLoad"`
	// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
	Name pulumi.StringInput `pulumi:"name"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
	PrimaryDefaultLoad pulumi.IntPtrInput `pulumi:"primaryDefaultLoad"`
	// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
	SecondaryDefaultLoad pulumi.IntPtrInput `pulumi:"secondaryDefaultLoad"`
	// The service load metric relative weight, compared to other metrics configured for this service, as a number.
	Weight pulumi.StringPtrInput `pulumi:"weight"`
}

func (ServiceLoadMetricResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLoadMetricResponse)(nil)).Elem()
}

func (i ServiceLoadMetricResponseArgs) ToServiceLoadMetricResponseOutput() ServiceLoadMetricResponseOutput {
	return i.ToServiceLoadMetricResponseOutputWithContext(context.Background())
}

func (i ServiceLoadMetricResponseArgs) ToServiceLoadMetricResponseOutputWithContext(ctx context.Context) ServiceLoadMetricResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLoadMetricResponseOutput)
}

// ServiceLoadMetricResponseArrayInput is an input type that accepts ServiceLoadMetricResponseArray and ServiceLoadMetricResponseArrayOutput values.
// You can construct a concrete instance of `ServiceLoadMetricResponseArrayInput` via:
//
//          ServiceLoadMetricResponseArray{ ServiceLoadMetricResponseArgs{...} }
type ServiceLoadMetricResponseArrayInput interface {
	pulumi.Input

	ToServiceLoadMetricResponseArrayOutput() ServiceLoadMetricResponseArrayOutput
	ToServiceLoadMetricResponseArrayOutputWithContext(context.Context) ServiceLoadMetricResponseArrayOutput
}

type ServiceLoadMetricResponseArray []ServiceLoadMetricResponseInput

func (ServiceLoadMetricResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceLoadMetricResponse)(nil)).Elem()
}

func (i ServiceLoadMetricResponseArray) ToServiceLoadMetricResponseArrayOutput() ServiceLoadMetricResponseArrayOutput {
	return i.ToServiceLoadMetricResponseArrayOutputWithContext(context.Background())
}

func (i ServiceLoadMetricResponseArray) ToServiceLoadMetricResponseArrayOutputWithContext(ctx context.Context) ServiceLoadMetricResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLoadMetricResponseArrayOutput)
}

// Specifies a metric to load balance a service during runtime.
type ServiceLoadMetricResponseOutput struct{ *pulumi.OutputState }

func (ServiceLoadMetricResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLoadMetricResponse)(nil)).Elem()
}

func (o ServiceLoadMetricResponseOutput) ToServiceLoadMetricResponseOutput() ServiceLoadMetricResponseOutput {
	return o
}

func (o ServiceLoadMetricResponseOutput) ToServiceLoadMetricResponseOutputWithContext(ctx context.Context) ServiceLoadMetricResponseOutput {
	return o
}

// Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
func (o ServiceLoadMetricResponseOutput) DefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) *int { return v.DefaultLoad }).(pulumi.IntPtrOutput)
}

// The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
func (o ServiceLoadMetricResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
func (o ServiceLoadMetricResponseOutput) PrimaryDefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) *int { return v.PrimaryDefaultLoad }).(pulumi.IntPtrOutput)
}

// Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
func (o ServiceLoadMetricResponseOutput) SecondaryDefaultLoad() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) *int { return v.SecondaryDefaultLoad }).(pulumi.IntPtrOutput)
}

// The service load metric relative weight, compared to other metrics configured for this service, as a number.
func (o ServiceLoadMetricResponseOutput) Weight() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceLoadMetricResponse) *string { return v.Weight }).(pulumi.StringPtrOutput)
}

type ServiceLoadMetricResponseArrayOutput struct{ *pulumi.OutputState }

func (ServiceLoadMetricResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceLoadMetricResponse)(nil)).Elem()
}

func (o ServiceLoadMetricResponseArrayOutput) ToServiceLoadMetricResponseArrayOutput() ServiceLoadMetricResponseArrayOutput {
	return o
}

func (o ServiceLoadMetricResponseArrayOutput) ToServiceLoadMetricResponseArrayOutputWithContext(ctx context.Context) ServiceLoadMetricResponseArrayOutput {
	return o
}

func (o ServiceLoadMetricResponseArrayOutput) Index(i pulumi.IntInput) ServiceLoadMetricResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceLoadMetricResponse {
		return vs[0].([]ServiceLoadMetricResponse)[vs[1].(int)]
	}).(ServiceLoadMetricResponseOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicy struct {
	// The name of the domain that should not be used for placement.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'InvalidDomain'.
	Type string `pulumi:"type"`
}

// ServicePlacementInvalidDomainPolicyInput is an input type that accepts ServicePlacementInvalidDomainPolicyArgs and ServicePlacementInvalidDomainPolicyOutput values.
// You can construct a concrete instance of `ServicePlacementInvalidDomainPolicyInput` via:
//
//          ServicePlacementInvalidDomainPolicyArgs{...}
type ServicePlacementInvalidDomainPolicyInput interface {
	pulumi.Input

	ToServicePlacementInvalidDomainPolicyOutput() ServicePlacementInvalidDomainPolicyOutput
	ToServicePlacementInvalidDomainPolicyOutputWithContext(context.Context) ServicePlacementInvalidDomainPolicyOutput
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyArgs struct {
	// The name of the domain that should not be used for placement.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'InvalidDomain'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementInvalidDomainPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementInvalidDomainPolicy)(nil)).Elem()
}

func (i ServicePlacementInvalidDomainPolicyArgs) ToServicePlacementInvalidDomainPolicyOutput() ServicePlacementInvalidDomainPolicyOutput {
	return i.ToServicePlacementInvalidDomainPolicyOutputWithContext(context.Background())
}

func (i ServicePlacementInvalidDomainPolicyArgs) ToServicePlacementInvalidDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementInvalidDomainPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementInvalidDomainPolicyOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementInvalidDomainPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementInvalidDomainPolicy)(nil)).Elem()
}

func (o ServicePlacementInvalidDomainPolicyOutput) ToServicePlacementInvalidDomainPolicyOutput() ServicePlacementInvalidDomainPolicyOutput {
	return o
}

func (o ServicePlacementInvalidDomainPolicyOutput) ToServicePlacementInvalidDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementInvalidDomainPolicyOutput {
	return o
}

// The name of the domain that should not be used for placement.
func (o ServicePlacementInvalidDomainPolicyOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementInvalidDomainPolicy) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'InvalidDomain'.
func (o ServicePlacementInvalidDomainPolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementInvalidDomainPolicy) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyResponse struct {
	// The name of the domain that should not be used for placement.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'InvalidDomain'.
	Type string `pulumi:"type"`
}

// ServicePlacementInvalidDomainPolicyResponseInput is an input type that accepts ServicePlacementInvalidDomainPolicyResponseArgs and ServicePlacementInvalidDomainPolicyResponseOutput values.
// You can construct a concrete instance of `ServicePlacementInvalidDomainPolicyResponseInput` via:
//
//          ServicePlacementInvalidDomainPolicyResponseArgs{...}
type ServicePlacementInvalidDomainPolicyResponseInput interface {
	pulumi.Input

	ToServicePlacementInvalidDomainPolicyResponseOutput() ServicePlacementInvalidDomainPolicyResponseOutput
	ToServicePlacementInvalidDomainPolicyResponseOutputWithContext(context.Context) ServicePlacementInvalidDomainPolicyResponseOutput
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyResponseArgs struct {
	// The name of the domain that should not be used for placement.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'InvalidDomain'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementInvalidDomainPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementInvalidDomainPolicyResponse)(nil)).Elem()
}

func (i ServicePlacementInvalidDomainPolicyResponseArgs) ToServicePlacementInvalidDomainPolicyResponseOutput() ServicePlacementInvalidDomainPolicyResponseOutput {
	return i.ToServicePlacementInvalidDomainPolicyResponseOutputWithContext(context.Background())
}

func (i ServicePlacementInvalidDomainPolicyResponseArgs) ToServicePlacementInvalidDomainPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementInvalidDomainPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementInvalidDomainPolicyResponseOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
type ServicePlacementInvalidDomainPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementInvalidDomainPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementInvalidDomainPolicyResponse)(nil)).Elem()
}

func (o ServicePlacementInvalidDomainPolicyResponseOutput) ToServicePlacementInvalidDomainPolicyResponseOutput() ServicePlacementInvalidDomainPolicyResponseOutput {
	return o
}

func (o ServicePlacementInvalidDomainPolicyResponseOutput) ToServicePlacementInvalidDomainPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementInvalidDomainPolicyResponseOutput {
	return o
}

// The name of the domain that should not be used for placement.
func (o ServicePlacementInvalidDomainPolicyResponseOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementInvalidDomainPolicyResponse) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'InvalidDomain'.
func (o ServicePlacementInvalidDomainPolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementInvalidDomainPolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicy struct {
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'NonPartiallyPlaceService'.
	Type string `pulumi:"type"`
}

// ServicePlacementNonPartiallyPlaceServicePolicyInput is an input type that accepts ServicePlacementNonPartiallyPlaceServicePolicyArgs and ServicePlacementNonPartiallyPlaceServicePolicyOutput values.
// You can construct a concrete instance of `ServicePlacementNonPartiallyPlaceServicePolicyInput` via:
//
//          ServicePlacementNonPartiallyPlaceServicePolicyArgs{...}
type ServicePlacementNonPartiallyPlaceServicePolicyInput interface {
	pulumi.Input

	ToServicePlacementNonPartiallyPlaceServicePolicyOutput() ServicePlacementNonPartiallyPlaceServicePolicyOutput
	ToServicePlacementNonPartiallyPlaceServicePolicyOutputWithContext(context.Context) ServicePlacementNonPartiallyPlaceServicePolicyOutput
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyArgs struct {
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'NonPartiallyPlaceService'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementNonPartiallyPlaceServicePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementNonPartiallyPlaceServicePolicy)(nil)).Elem()
}

func (i ServicePlacementNonPartiallyPlaceServicePolicyArgs) ToServicePlacementNonPartiallyPlaceServicePolicyOutput() ServicePlacementNonPartiallyPlaceServicePolicyOutput {
	return i.ToServicePlacementNonPartiallyPlaceServicePolicyOutputWithContext(context.Background())
}

func (i ServicePlacementNonPartiallyPlaceServicePolicyArgs) ToServicePlacementNonPartiallyPlaceServicePolicyOutputWithContext(ctx context.Context) ServicePlacementNonPartiallyPlaceServicePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementNonPartiallyPlaceServicePolicyOutput)
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementNonPartiallyPlaceServicePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementNonPartiallyPlaceServicePolicy)(nil)).Elem()
}

func (o ServicePlacementNonPartiallyPlaceServicePolicyOutput) ToServicePlacementNonPartiallyPlaceServicePolicyOutput() ServicePlacementNonPartiallyPlaceServicePolicyOutput {
	return o
}

func (o ServicePlacementNonPartiallyPlaceServicePolicyOutput) ToServicePlacementNonPartiallyPlaceServicePolicyOutputWithContext(ctx context.Context) ServicePlacementNonPartiallyPlaceServicePolicyOutput {
	return o
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'NonPartiallyPlaceService'.
func (o ServicePlacementNonPartiallyPlaceServicePolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementNonPartiallyPlaceServicePolicy) string { return v.Type }).(pulumi.StringOutput)
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyResponse struct {
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'NonPartiallyPlaceService'.
	Type string `pulumi:"type"`
}

// ServicePlacementNonPartiallyPlaceServicePolicyResponseInput is an input type that accepts ServicePlacementNonPartiallyPlaceServicePolicyResponseArgs and ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput values.
// You can construct a concrete instance of `ServicePlacementNonPartiallyPlaceServicePolicyResponseInput` via:
//
//          ServicePlacementNonPartiallyPlaceServicePolicyResponseArgs{...}
type ServicePlacementNonPartiallyPlaceServicePolicyResponseInput interface {
	pulumi.Input

	ToServicePlacementNonPartiallyPlaceServicePolicyResponseOutput() ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput
	ToServicePlacementNonPartiallyPlaceServicePolicyResponseOutputWithContext(context.Context) ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyResponseArgs struct {
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'NonPartiallyPlaceService'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementNonPartiallyPlaceServicePolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementNonPartiallyPlaceServicePolicyResponse)(nil)).Elem()
}

func (i ServicePlacementNonPartiallyPlaceServicePolicyResponseArgs) ToServicePlacementNonPartiallyPlaceServicePolicyResponseOutput() ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput {
	return i.ToServicePlacementNonPartiallyPlaceServicePolicyResponseOutputWithContext(context.Background())
}

func (i ServicePlacementNonPartiallyPlaceServicePolicyResponseArgs) ToServicePlacementNonPartiallyPlaceServicePolicyResponseOutputWithContext(ctx context.Context) ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput)
}

// The name of the domain that should used for placement as per this policy.
type ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementNonPartiallyPlaceServicePolicyResponse)(nil)).Elem()
}

func (o ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput) ToServicePlacementNonPartiallyPlaceServicePolicyResponseOutput() ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput {
	return o
}

func (o ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput) ToServicePlacementNonPartiallyPlaceServicePolicyResponseOutputWithContext(ctx context.Context) ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput {
	return o
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'NonPartiallyPlaceService'.
func (o ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementNonPartiallyPlaceServicePolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicy struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'PreferredPrimaryDomain'.
	Type string `pulumi:"type"`
}

// ServicePlacementPreferPrimaryDomainPolicyInput is an input type that accepts ServicePlacementPreferPrimaryDomainPolicyArgs and ServicePlacementPreferPrimaryDomainPolicyOutput values.
// You can construct a concrete instance of `ServicePlacementPreferPrimaryDomainPolicyInput` via:
//
//          ServicePlacementPreferPrimaryDomainPolicyArgs{...}
type ServicePlacementPreferPrimaryDomainPolicyInput interface {
	pulumi.Input

	ToServicePlacementPreferPrimaryDomainPolicyOutput() ServicePlacementPreferPrimaryDomainPolicyOutput
	ToServicePlacementPreferPrimaryDomainPolicyOutputWithContext(context.Context) ServicePlacementPreferPrimaryDomainPolicyOutput
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyArgs struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'PreferredPrimaryDomain'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementPreferPrimaryDomainPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementPreferPrimaryDomainPolicy)(nil)).Elem()
}

func (i ServicePlacementPreferPrimaryDomainPolicyArgs) ToServicePlacementPreferPrimaryDomainPolicyOutput() ServicePlacementPreferPrimaryDomainPolicyOutput {
	return i.ToServicePlacementPreferPrimaryDomainPolicyOutputWithContext(context.Background())
}

func (i ServicePlacementPreferPrimaryDomainPolicyArgs) ToServicePlacementPreferPrimaryDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementPreferPrimaryDomainPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementPreferPrimaryDomainPolicyOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementPreferPrimaryDomainPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementPreferPrimaryDomainPolicy)(nil)).Elem()
}

func (o ServicePlacementPreferPrimaryDomainPolicyOutput) ToServicePlacementPreferPrimaryDomainPolicyOutput() ServicePlacementPreferPrimaryDomainPolicyOutput {
	return o
}

func (o ServicePlacementPreferPrimaryDomainPolicyOutput) ToServicePlacementPreferPrimaryDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementPreferPrimaryDomainPolicyOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementPreferPrimaryDomainPolicyOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementPreferPrimaryDomainPolicy) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'PreferredPrimaryDomain'.
func (o ServicePlacementPreferPrimaryDomainPolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementPreferPrimaryDomainPolicy) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyResponse struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'PreferredPrimaryDomain'.
	Type string `pulumi:"type"`
}

// ServicePlacementPreferPrimaryDomainPolicyResponseInput is an input type that accepts ServicePlacementPreferPrimaryDomainPolicyResponseArgs and ServicePlacementPreferPrimaryDomainPolicyResponseOutput values.
// You can construct a concrete instance of `ServicePlacementPreferPrimaryDomainPolicyResponseInput` via:
//
//          ServicePlacementPreferPrimaryDomainPolicyResponseArgs{...}
type ServicePlacementPreferPrimaryDomainPolicyResponseInput interface {
	pulumi.Input

	ToServicePlacementPreferPrimaryDomainPolicyResponseOutput() ServicePlacementPreferPrimaryDomainPolicyResponseOutput
	ToServicePlacementPreferPrimaryDomainPolicyResponseOutputWithContext(context.Context) ServicePlacementPreferPrimaryDomainPolicyResponseOutput
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyResponseArgs struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'PreferredPrimaryDomain'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementPreferPrimaryDomainPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementPreferPrimaryDomainPolicyResponse)(nil)).Elem()
}

func (i ServicePlacementPreferPrimaryDomainPolicyResponseArgs) ToServicePlacementPreferPrimaryDomainPolicyResponseOutput() ServicePlacementPreferPrimaryDomainPolicyResponseOutput {
	return i.ToServicePlacementPreferPrimaryDomainPolicyResponseOutputWithContext(context.Background())
}

func (i ServicePlacementPreferPrimaryDomainPolicyResponseArgs) ToServicePlacementPreferPrimaryDomainPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementPreferPrimaryDomainPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementPreferPrimaryDomainPolicyResponseOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the service's
// Primary replicas should optimally be placed in a particular domain.
//
// This placement policy is usually used with fault domains in scenarios where the Service Fabric
// cluster is geographically distributed in order to indicate that a service's primary replica should
// be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
// or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
// may not end up located in this domain due to failures, capacity limits, or other constraints.
type ServicePlacementPreferPrimaryDomainPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementPreferPrimaryDomainPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementPreferPrimaryDomainPolicyResponse)(nil)).Elem()
}

func (o ServicePlacementPreferPrimaryDomainPolicyResponseOutput) ToServicePlacementPreferPrimaryDomainPolicyResponseOutput() ServicePlacementPreferPrimaryDomainPolicyResponseOutput {
	return o
}

func (o ServicePlacementPreferPrimaryDomainPolicyResponseOutput) ToServicePlacementPreferPrimaryDomainPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementPreferPrimaryDomainPolicyResponseOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementPreferPrimaryDomainPolicyResponseOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementPreferPrimaryDomainPolicyResponse) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'PreferredPrimaryDomain'.
func (o ServicePlacementPreferPrimaryDomainPolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementPreferPrimaryDomainPolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicy struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomainDistribution'.
	Type string `pulumi:"type"`
}

// ServicePlacementRequireDomainDistributionPolicyInput is an input type that accepts ServicePlacementRequireDomainDistributionPolicyArgs and ServicePlacementRequireDomainDistributionPolicyOutput values.
// You can construct a concrete instance of `ServicePlacementRequireDomainDistributionPolicyInput` via:
//
//          ServicePlacementRequireDomainDistributionPolicyArgs{...}
type ServicePlacementRequireDomainDistributionPolicyInput interface {
	pulumi.Input

	ToServicePlacementRequireDomainDistributionPolicyOutput() ServicePlacementRequireDomainDistributionPolicyOutput
	ToServicePlacementRequireDomainDistributionPolicyOutputWithContext(context.Context) ServicePlacementRequireDomainDistributionPolicyOutput
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyArgs struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomainDistribution'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementRequireDomainDistributionPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequireDomainDistributionPolicy)(nil)).Elem()
}

func (i ServicePlacementRequireDomainDistributionPolicyArgs) ToServicePlacementRequireDomainDistributionPolicyOutput() ServicePlacementRequireDomainDistributionPolicyOutput {
	return i.ToServicePlacementRequireDomainDistributionPolicyOutputWithContext(context.Background())
}

func (i ServicePlacementRequireDomainDistributionPolicyArgs) ToServicePlacementRequireDomainDistributionPolicyOutputWithContext(ctx context.Context) ServicePlacementRequireDomainDistributionPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementRequireDomainDistributionPolicyOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementRequireDomainDistributionPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequireDomainDistributionPolicy)(nil)).Elem()
}

func (o ServicePlacementRequireDomainDistributionPolicyOutput) ToServicePlacementRequireDomainDistributionPolicyOutput() ServicePlacementRequireDomainDistributionPolicyOutput {
	return o
}

func (o ServicePlacementRequireDomainDistributionPolicyOutput) ToServicePlacementRequireDomainDistributionPolicyOutputWithContext(ctx context.Context) ServicePlacementRequireDomainDistributionPolicyOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementRequireDomainDistributionPolicyOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequireDomainDistributionPolicy) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'RequiredDomainDistribution'.
func (o ServicePlacementRequireDomainDistributionPolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequireDomainDistributionPolicy) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyResponse struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomainDistribution'.
	Type string `pulumi:"type"`
}

// ServicePlacementRequireDomainDistributionPolicyResponseInput is an input type that accepts ServicePlacementRequireDomainDistributionPolicyResponseArgs and ServicePlacementRequireDomainDistributionPolicyResponseOutput values.
// You can construct a concrete instance of `ServicePlacementRequireDomainDistributionPolicyResponseInput` via:
//
//          ServicePlacementRequireDomainDistributionPolicyResponseArgs{...}
type ServicePlacementRequireDomainDistributionPolicyResponseInput interface {
	pulumi.Input

	ToServicePlacementRequireDomainDistributionPolicyResponseOutput() ServicePlacementRequireDomainDistributionPolicyResponseOutput
	ToServicePlacementRequireDomainDistributionPolicyResponseOutputWithContext(context.Context) ServicePlacementRequireDomainDistributionPolicyResponseOutput
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyResponseArgs struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomainDistribution'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementRequireDomainDistributionPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequireDomainDistributionPolicyResponse)(nil)).Elem()
}

func (i ServicePlacementRequireDomainDistributionPolicyResponseArgs) ToServicePlacementRequireDomainDistributionPolicyResponseOutput() ServicePlacementRequireDomainDistributionPolicyResponseOutput {
	return i.ToServicePlacementRequireDomainDistributionPolicyResponseOutputWithContext(context.Background())
}

func (i ServicePlacementRequireDomainDistributionPolicyResponseArgs) ToServicePlacementRequireDomainDistributionPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementRequireDomainDistributionPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementRequireDomainDistributionPolicyResponseOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where two replicas
// from the same partition should never be placed in the same fault or upgrade domain.
//
// While this is not common it can expose the service to an increased risk of concurrent failures
// due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
// a case where replicas are deployed across different data center, with one replica per location.
// In the event that one of the datacenters goes offline, normally the replica that was placed in that
// datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
// policy should be set.
type ServicePlacementRequireDomainDistributionPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementRequireDomainDistributionPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequireDomainDistributionPolicyResponse)(nil)).Elem()
}

func (o ServicePlacementRequireDomainDistributionPolicyResponseOutput) ToServicePlacementRequireDomainDistributionPolicyResponseOutput() ServicePlacementRequireDomainDistributionPolicyResponseOutput {
	return o
}

func (o ServicePlacementRequireDomainDistributionPolicyResponseOutput) ToServicePlacementRequireDomainDistributionPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementRequireDomainDistributionPolicyResponseOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementRequireDomainDistributionPolicyResponseOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequireDomainDistributionPolicyResponse) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'RequiredDomainDistribution'.
func (o ServicePlacementRequireDomainDistributionPolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequireDomainDistributionPolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicy struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomain'.
	Type string `pulumi:"type"`
}

// ServicePlacementRequiredDomainPolicyInput is an input type that accepts ServicePlacementRequiredDomainPolicyArgs and ServicePlacementRequiredDomainPolicyOutput values.
// You can construct a concrete instance of `ServicePlacementRequiredDomainPolicyInput` via:
//
//          ServicePlacementRequiredDomainPolicyArgs{...}
type ServicePlacementRequiredDomainPolicyInput interface {
	pulumi.Input

	ToServicePlacementRequiredDomainPolicyOutput() ServicePlacementRequiredDomainPolicyOutput
	ToServicePlacementRequiredDomainPolicyOutputWithContext(context.Context) ServicePlacementRequiredDomainPolicyOutput
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyArgs struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomain'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementRequiredDomainPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequiredDomainPolicy)(nil)).Elem()
}

func (i ServicePlacementRequiredDomainPolicyArgs) ToServicePlacementRequiredDomainPolicyOutput() ServicePlacementRequiredDomainPolicyOutput {
	return i.ToServicePlacementRequiredDomainPolicyOutputWithContext(context.Background())
}

func (i ServicePlacementRequiredDomainPolicyArgs) ToServicePlacementRequiredDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementRequiredDomainPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementRequiredDomainPolicyOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyOutput struct{ *pulumi.OutputState }

func (ServicePlacementRequiredDomainPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequiredDomainPolicy)(nil)).Elem()
}

func (o ServicePlacementRequiredDomainPolicyOutput) ToServicePlacementRequiredDomainPolicyOutput() ServicePlacementRequiredDomainPolicyOutput {
	return o
}

func (o ServicePlacementRequiredDomainPolicyOutput) ToServicePlacementRequiredDomainPolicyOutputWithContext(ctx context.Context) ServicePlacementRequiredDomainPolicyOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementRequiredDomainPolicyOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequiredDomainPolicy) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'RequiredDomain'.
func (o ServicePlacementRequiredDomainPolicyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequiredDomainPolicy) string { return v.Type }).(pulumi.StringOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyResponse struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName string `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomain'.
	Type string `pulumi:"type"`
}

// ServicePlacementRequiredDomainPolicyResponseInput is an input type that accepts ServicePlacementRequiredDomainPolicyResponseArgs and ServicePlacementRequiredDomainPolicyResponseOutput values.
// You can construct a concrete instance of `ServicePlacementRequiredDomainPolicyResponseInput` via:
//
//          ServicePlacementRequiredDomainPolicyResponseArgs{...}
type ServicePlacementRequiredDomainPolicyResponseInput interface {
	pulumi.Input

	ToServicePlacementRequiredDomainPolicyResponseOutput() ServicePlacementRequiredDomainPolicyResponseOutput
	ToServicePlacementRequiredDomainPolicyResponseOutputWithContext(context.Context) ServicePlacementRequiredDomainPolicyResponseOutput
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyResponseArgs struct {
	// The name of the domain that should used for placement as per this policy.
	DomainName pulumi.StringInput `pulumi:"domainName"`
	// The type of placement policy for a service fabric service. Following are the possible values.
	// Expected value is 'RequiredDomain'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ServicePlacementRequiredDomainPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequiredDomainPolicyResponse)(nil)).Elem()
}

func (i ServicePlacementRequiredDomainPolicyResponseArgs) ToServicePlacementRequiredDomainPolicyResponseOutput() ServicePlacementRequiredDomainPolicyResponseOutput {
	return i.ToServicePlacementRequiredDomainPolicyResponseOutputWithContext(context.Background())
}

func (i ServicePlacementRequiredDomainPolicyResponseArgs) ToServicePlacementRequiredDomainPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementRequiredDomainPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePlacementRequiredDomainPolicyResponseOutput)
}

// Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
type ServicePlacementRequiredDomainPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServicePlacementRequiredDomainPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePlacementRequiredDomainPolicyResponse)(nil)).Elem()
}

func (o ServicePlacementRequiredDomainPolicyResponseOutput) ToServicePlacementRequiredDomainPolicyResponseOutput() ServicePlacementRequiredDomainPolicyResponseOutput {
	return o
}

func (o ServicePlacementRequiredDomainPolicyResponseOutput) ToServicePlacementRequiredDomainPolicyResponseOutputWithContext(ctx context.Context) ServicePlacementRequiredDomainPolicyResponseOutput {
	return o
}

// The name of the domain that should used for placement as per this policy.
func (o ServicePlacementRequiredDomainPolicyResponseOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequiredDomainPolicyResponse) string { return v.DomainName }).(pulumi.StringOutput)
}

// The type of placement policy for a service fabric service. Following are the possible values.
// Expected value is 'RequiredDomain'.
func (o ServicePlacementRequiredDomainPolicyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ServicePlacementRequiredDomainPolicyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicy struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService int `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition int `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices int `pulumi:"maxPercentUnhealthyServices"`
}

// ServiceTypeHealthPolicyInput is an input type that accepts ServiceTypeHealthPolicyArgs and ServiceTypeHealthPolicyOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyInput` via:
//
//          ServiceTypeHealthPolicyArgs{...}
type ServiceTypeHealthPolicyInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyOutput() ServiceTypeHealthPolicyOutput
	ToServiceTypeHealthPolicyOutputWithContext(context.Context) ServiceTypeHealthPolicyOutput
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyArgs struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService pulumi.IntInput `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition pulumi.IntInput `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices pulumi.IntInput `pulumi:"maxPercentUnhealthyServices"`
}

func (ServiceTypeHealthPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicy)(nil)).Elem()
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyOutput() ServiceTypeHealthPolicyOutput {
	return i.ToServiceTypeHealthPolicyOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyOutput)
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return i.ToServiceTypeHealthPolicyPtrOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyArgs) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyOutput).ToServiceTypeHealthPolicyPtrOutputWithContext(ctx)
}

// ServiceTypeHealthPolicyPtrInput is an input type that accepts ServiceTypeHealthPolicyArgs, ServiceTypeHealthPolicyPtr and ServiceTypeHealthPolicyPtrOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyPtrInput` via:
//
//          ServiceTypeHealthPolicyArgs{...}
//
//  or:
//
//          nil
type ServiceTypeHealthPolicyPtrInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput
	ToServiceTypeHealthPolicyPtrOutputWithContext(context.Context) ServiceTypeHealthPolicyPtrOutput
}

type serviceTypeHealthPolicyPtrType ServiceTypeHealthPolicyArgs

func ServiceTypeHealthPolicyPtr(v *ServiceTypeHealthPolicyArgs) ServiceTypeHealthPolicyPtrInput {
	return (*serviceTypeHealthPolicyPtrType)(v)
}

func (*serviceTypeHealthPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicy)(nil)).Elem()
}

func (i *serviceTypeHealthPolicyPtrType) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return i.ToServiceTypeHealthPolicyPtrOutputWithContext(context.Background())
}

func (i *serviceTypeHealthPolicyPtrType) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyPtrOutput)
}

// ServiceTypeHealthPolicyMapInput is an input type that accepts ServiceTypeHealthPolicyMap and ServiceTypeHealthPolicyMapOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyMapInput` via:
//
//          ServiceTypeHealthPolicyMap{ "key": ServiceTypeHealthPolicyArgs{...} }
type ServiceTypeHealthPolicyMapInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyMapOutput() ServiceTypeHealthPolicyMapOutput
	ToServiceTypeHealthPolicyMapOutputWithContext(context.Context) ServiceTypeHealthPolicyMapOutput
}

type ServiceTypeHealthPolicyMap map[string]ServiceTypeHealthPolicyInput

func (ServiceTypeHealthPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicy)(nil)).Elem()
}

func (i ServiceTypeHealthPolicyMap) ToServiceTypeHealthPolicyMapOutput() ServiceTypeHealthPolicyMapOutput {
	return i.ToServiceTypeHealthPolicyMapOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyMap) ToServiceTypeHealthPolicyMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyMapOutput)
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicy)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyOutput() ServiceTypeHealthPolicyOutput {
	return o
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyOutput {
	return o
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return o.ToServiceTypeHealthPolicyPtrOutputWithContext(context.Background())
}

func (o ServiceTypeHealthPolicyOutput) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) *ServiceTypeHealthPolicy {
		return &v
	}).(ServiceTypeHealthPolicyPtrOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) int { return v.MaxPercentUnhealthyPartitionsPerService }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) int { return v.MaxPercentUnhealthyReplicasPerPartition }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyOutput) MaxPercentUnhealthyServices() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicy) int { return v.MaxPercentUnhealthyServices }).(pulumi.IntOutput)
}

type ServiceTypeHealthPolicyPtrOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicy)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyPtrOutput) ToServiceTypeHealthPolicyPtrOutput() ServiceTypeHealthPolicyPtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyPtrOutput) ToServiceTypeHealthPolicyPtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyPtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyPtrOutput) Elem() ServiceTypeHealthPolicyOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) ServiceTypeHealthPolicy { return *v }).(ServiceTypeHealthPolicyOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyPtrOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyPartitionsPerService
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyPtrOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyReplicasPerPartition
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyPtrOutput) MaxPercentUnhealthyServices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicy) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyServices
	}).(pulumi.IntPtrOutput)
}

type ServiceTypeHealthPolicyMapOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicy)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyMapOutput) ToServiceTypeHealthPolicyMapOutput() ServiceTypeHealthPolicyMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyMapOutput) ToServiceTypeHealthPolicyMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyMapOutput) MapIndex(k pulumi.StringInput) ServiceTypeHealthPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ServiceTypeHealthPolicy {
		return vs[0].(map[string]ServiceTypeHealthPolicy)[vs[1].(string)]
	}).(ServiceTypeHealthPolicyOutput)
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyResponse struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService int `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition int `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices int `pulumi:"maxPercentUnhealthyServices"`
}

// ServiceTypeHealthPolicyResponseInput is an input type that accepts ServiceTypeHealthPolicyResponseArgs and ServiceTypeHealthPolicyResponseOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyResponseInput` via:
//
//          ServiceTypeHealthPolicyResponseArgs{...}
type ServiceTypeHealthPolicyResponseInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyResponseOutput() ServiceTypeHealthPolicyResponseOutput
	ToServiceTypeHealthPolicyResponseOutputWithContext(context.Context) ServiceTypeHealthPolicyResponseOutput
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyResponseArgs struct {
	// The maximum allowed percentage of unhealthy partitions per service.
	//
	// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
	// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
	// The computation rounds up to tolerate one failure on small numbers of partitions.
	MaxPercentUnhealthyPartitionsPerService pulumi.IntInput `pulumi:"maxPercentUnhealthyPartitionsPerService"`
	// The maximum allowed percentage of unhealthy replicas per partition.
	//
	// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
	// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
	// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
	// The computation rounds up to tolerate one failure on small numbers of replicas.
	MaxPercentUnhealthyReplicasPerPartition pulumi.IntInput `pulumi:"maxPercentUnhealthyReplicasPerPartition"`
	// The maximum allowed percentage of unhealthy services.
	//
	// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
	// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
	// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
	// The computation rounds up to tolerate one failure on small numbers of services.
	MaxPercentUnhealthyServices pulumi.IntInput `pulumi:"maxPercentUnhealthyServices"`
}

func (ServiceTypeHealthPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (i ServiceTypeHealthPolicyResponseArgs) ToServiceTypeHealthPolicyResponseOutput() ServiceTypeHealthPolicyResponseOutput {
	return i.ToServiceTypeHealthPolicyResponseOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyResponseArgs) ToServiceTypeHealthPolicyResponseOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyResponseOutput)
}

func (i ServiceTypeHealthPolicyResponseArgs) ToServiceTypeHealthPolicyResponsePtrOutput() ServiceTypeHealthPolicyResponsePtrOutput {
	return i.ToServiceTypeHealthPolicyResponsePtrOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyResponseArgs) ToServiceTypeHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyResponseOutput).ToServiceTypeHealthPolicyResponsePtrOutputWithContext(ctx)
}

// ServiceTypeHealthPolicyResponsePtrInput is an input type that accepts ServiceTypeHealthPolicyResponseArgs, ServiceTypeHealthPolicyResponsePtr and ServiceTypeHealthPolicyResponsePtrOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyResponsePtrInput` via:
//
//          ServiceTypeHealthPolicyResponseArgs{...}
//
//  or:
//
//          nil
type ServiceTypeHealthPolicyResponsePtrInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyResponsePtrOutput() ServiceTypeHealthPolicyResponsePtrOutput
	ToServiceTypeHealthPolicyResponsePtrOutputWithContext(context.Context) ServiceTypeHealthPolicyResponsePtrOutput
}

type serviceTypeHealthPolicyResponsePtrType ServiceTypeHealthPolicyResponseArgs

func ServiceTypeHealthPolicyResponsePtr(v *ServiceTypeHealthPolicyResponseArgs) ServiceTypeHealthPolicyResponsePtrInput {
	return (*serviceTypeHealthPolicyResponsePtrType)(v)
}

func (*serviceTypeHealthPolicyResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (i *serviceTypeHealthPolicyResponsePtrType) ToServiceTypeHealthPolicyResponsePtrOutput() ServiceTypeHealthPolicyResponsePtrOutput {
	return i.ToServiceTypeHealthPolicyResponsePtrOutputWithContext(context.Background())
}

func (i *serviceTypeHealthPolicyResponsePtrType) ToServiceTypeHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyResponsePtrOutput)
}

// ServiceTypeHealthPolicyResponseMapInput is an input type that accepts ServiceTypeHealthPolicyResponseMap and ServiceTypeHealthPolicyResponseMapOutput values.
// You can construct a concrete instance of `ServiceTypeHealthPolicyResponseMapInput` via:
//
//          ServiceTypeHealthPolicyResponseMap{ "key": ServiceTypeHealthPolicyResponseArgs{...} }
type ServiceTypeHealthPolicyResponseMapInput interface {
	pulumi.Input

	ToServiceTypeHealthPolicyResponseMapOutput() ServiceTypeHealthPolicyResponseMapOutput
	ToServiceTypeHealthPolicyResponseMapOutputWithContext(context.Context) ServiceTypeHealthPolicyResponseMapOutput
}

type ServiceTypeHealthPolicyResponseMap map[string]ServiceTypeHealthPolicyResponseInput

func (ServiceTypeHealthPolicyResponseMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (i ServiceTypeHealthPolicyResponseMap) ToServiceTypeHealthPolicyResponseMapOutput() ServiceTypeHealthPolicyResponseMapOutput {
	return i.ToServiceTypeHealthPolicyResponseMapOutputWithContext(context.Background())
}

func (i ServiceTypeHealthPolicyResponseMap) ToServiceTypeHealthPolicyResponseMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponseMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceTypeHealthPolicyResponseMapOutput)
}

// Represents the health policy used to evaluate the health of services belonging to a service type.
type ServiceTypeHealthPolicyResponseOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyResponseOutput) ToServiceTypeHealthPolicyResponseOutput() ServiceTypeHealthPolicyResponseOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseOutput) ToServiceTypeHealthPolicyResponseOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponseOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseOutput) ToServiceTypeHealthPolicyResponsePtrOutput() ServiceTypeHealthPolicyResponsePtrOutput {
	return o.ToServiceTypeHealthPolicyResponsePtrOutputWithContext(context.Background())
}

func (o ServiceTypeHealthPolicyResponseOutput) ToServiceTypeHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponsePtrOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) *ServiceTypeHealthPolicyResponse {
		return &v
	}).(ServiceTypeHealthPolicyResponsePtrOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyResponseOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) int { return v.MaxPercentUnhealthyPartitionsPerService }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyResponseOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) int { return v.MaxPercentUnhealthyReplicasPerPartition }).(pulumi.IntOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyResponseOutput) MaxPercentUnhealthyServices() pulumi.IntOutput {
	return o.ApplyT(func(v ServiceTypeHealthPolicyResponse) int { return v.MaxPercentUnhealthyServices }).(pulumi.IntOutput)
}

type ServiceTypeHealthPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyResponsePtrOutput) ToServiceTypeHealthPolicyResponsePtrOutput() ServiceTypeHealthPolicyResponsePtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponsePtrOutput) ToServiceTypeHealthPolicyResponsePtrOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponsePtrOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponsePtrOutput) Elem() ServiceTypeHealthPolicyResponseOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) ServiceTypeHealthPolicyResponse { return *v }).(ServiceTypeHealthPolicyResponseOutput)
}

// The maximum allowed percentage of unhealthy partitions per service.
//
// The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
// If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
// The computation rounds up to tolerate one failure on small numbers of partitions.
func (o ServiceTypeHealthPolicyResponsePtrOutput) MaxPercentUnhealthyPartitionsPerService() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyPartitionsPerService
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy replicas per partition.
//
// The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
// If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
// The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
// The computation rounds up to tolerate one failure on small numbers of replicas.
func (o ServiceTypeHealthPolicyResponsePtrOutput) MaxPercentUnhealthyReplicasPerPartition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyReplicasPerPartition
	}).(pulumi.IntPtrOutput)
}

// The maximum allowed percentage of unhealthy services.
//
// The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
// If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
// This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
// The computation rounds up to tolerate one failure on small numbers of services.
func (o ServiceTypeHealthPolicyResponsePtrOutput) MaxPercentUnhealthyServices() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceTypeHealthPolicyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.MaxPercentUnhealthyServices
	}).(pulumi.IntPtrOutput)
}

type ServiceTypeHealthPolicyResponseMapOutput struct{ *pulumi.OutputState }

func (ServiceTypeHealthPolicyResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceTypeHealthPolicyResponse)(nil)).Elem()
}

func (o ServiceTypeHealthPolicyResponseMapOutput) ToServiceTypeHealthPolicyResponseMapOutput() ServiceTypeHealthPolicyResponseMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseMapOutput) ToServiceTypeHealthPolicyResponseMapOutputWithContext(ctx context.Context) ServiceTypeHealthPolicyResponseMapOutput {
	return o
}

func (o ServiceTypeHealthPolicyResponseMapOutput) MapIndex(k pulumi.StringInput) ServiceTypeHealthPolicyResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ServiceTypeHealthPolicyResponse {
		return vs[0].(map[string]ServiceTypeHealthPolicyResponse)[vs[1].(string)]
	}).(ServiceTypeHealthPolicyResponseOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescription struct {
	// The parameter name of fabric setting.
	Name string `pulumi:"name"`
	// The parameter value of fabric setting.
	Value string `pulumi:"value"`
}

// SettingsParameterDescriptionInput is an input type that accepts SettingsParameterDescriptionArgs and SettingsParameterDescriptionOutput values.
// You can construct a concrete instance of `SettingsParameterDescriptionInput` via:
//
//          SettingsParameterDescriptionArgs{...}
type SettingsParameterDescriptionInput interface {
	pulumi.Input

	ToSettingsParameterDescriptionOutput() SettingsParameterDescriptionOutput
	ToSettingsParameterDescriptionOutputWithContext(context.Context) SettingsParameterDescriptionOutput
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionArgs struct {
	// The parameter name of fabric setting.
	Name pulumi.StringInput `pulumi:"name"`
	// The parameter value of fabric setting.
	Value pulumi.StringInput `pulumi:"value"`
}

func (SettingsParameterDescriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescription)(nil)).Elem()
}

func (i SettingsParameterDescriptionArgs) ToSettingsParameterDescriptionOutput() SettingsParameterDescriptionOutput {
	return i.ToSettingsParameterDescriptionOutputWithContext(context.Background())
}

func (i SettingsParameterDescriptionArgs) ToSettingsParameterDescriptionOutputWithContext(ctx context.Context) SettingsParameterDescriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsParameterDescriptionOutput)
}

// SettingsParameterDescriptionArrayInput is an input type that accepts SettingsParameterDescriptionArray and SettingsParameterDescriptionArrayOutput values.
// You can construct a concrete instance of `SettingsParameterDescriptionArrayInput` via:
//
//          SettingsParameterDescriptionArray{ SettingsParameterDescriptionArgs{...} }
type SettingsParameterDescriptionArrayInput interface {
	pulumi.Input

	ToSettingsParameterDescriptionArrayOutput() SettingsParameterDescriptionArrayOutput
	ToSettingsParameterDescriptionArrayOutputWithContext(context.Context) SettingsParameterDescriptionArrayOutput
}

type SettingsParameterDescriptionArray []SettingsParameterDescriptionInput

func (SettingsParameterDescriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescription)(nil)).Elem()
}

func (i SettingsParameterDescriptionArray) ToSettingsParameterDescriptionArrayOutput() SettingsParameterDescriptionArrayOutput {
	return i.ToSettingsParameterDescriptionArrayOutputWithContext(context.Background())
}

func (i SettingsParameterDescriptionArray) ToSettingsParameterDescriptionArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsParameterDescriptionArrayOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescription)(nil)).Elem()
}

func (o SettingsParameterDescriptionOutput) ToSettingsParameterDescriptionOutput() SettingsParameterDescriptionOutput {
	return o
}

func (o SettingsParameterDescriptionOutput) ToSettingsParameterDescriptionOutputWithContext(ctx context.Context) SettingsParameterDescriptionOutput {
	return o
}

// The parameter name of fabric setting.
func (o SettingsParameterDescriptionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescription) string { return v.Name }).(pulumi.StringOutput)
}

// The parameter value of fabric setting.
func (o SettingsParameterDescriptionOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescription) string { return v.Value }).(pulumi.StringOutput)
}

type SettingsParameterDescriptionArrayOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescription)(nil)).Elem()
}

func (o SettingsParameterDescriptionArrayOutput) ToSettingsParameterDescriptionArrayOutput() SettingsParameterDescriptionArrayOutput {
	return o
}

func (o SettingsParameterDescriptionArrayOutput) ToSettingsParameterDescriptionArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionArrayOutput {
	return o
}

func (o SettingsParameterDescriptionArrayOutput) Index(i pulumi.IntInput) SettingsParameterDescriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsParameterDescription {
		return vs[0].([]SettingsParameterDescription)[vs[1].(int)]
	}).(SettingsParameterDescriptionOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionResponse struct {
	// The parameter name of fabric setting.
	Name string `pulumi:"name"`
	// The parameter value of fabric setting.
	Value string `pulumi:"value"`
}

// SettingsParameterDescriptionResponseInput is an input type that accepts SettingsParameterDescriptionResponseArgs and SettingsParameterDescriptionResponseOutput values.
// You can construct a concrete instance of `SettingsParameterDescriptionResponseInput` via:
//
//          SettingsParameterDescriptionResponseArgs{...}
type SettingsParameterDescriptionResponseInput interface {
	pulumi.Input

	ToSettingsParameterDescriptionResponseOutput() SettingsParameterDescriptionResponseOutput
	ToSettingsParameterDescriptionResponseOutputWithContext(context.Context) SettingsParameterDescriptionResponseOutput
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionResponseArgs struct {
	// The parameter name of fabric setting.
	Name pulumi.StringInput `pulumi:"name"`
	// The parameter value of fabric setting.
	Value pulumi.StringInput `pulumi:"value"`
}

func (SettingsParameterDescriptionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescriptionResponse)(nil)).Elem()
}

func (i SettingsParameterDescriptionResponseArgs) ToSettingsParameterDescriptionResponseOutput() SettingsParameterDescriptionResponseOutput {
	return i.ToSettingsParameterDescriptionResponseOutputWithContext(context.Background())
}

func (i SettingsParameterDescriptionResponseArgs) ToSettingsParameterDescriptionResponseOutputWithContext(ctx context.Context) SettingsParameterDescriptionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsParameterDescriptionResponseOutput)
}

// SettingsParameterDescriptionResponseArrayInput is an input type that accepts SettingsParameterDescriptionResponseArray and SettingsParameterDescriptionResponseArrayOutput values.
// You can construct a concrete instance of `SettingsParameterDescriptionResponseArrayInput` via:
//
//          SettingsParameterDescriptionResponseArray{ SettingsParameterDescriptionResponseArgs{...} }
type SettingsParameterDescriptionResponseArrayInput interface {
	pulumi.Input

	ToSettingsParameterDescriptionResponseArrayOutput() SettingsParameterDescriptionResponseArrayOutput
	ToSettingsParameterDescriptionResponseArrayOutputWithContext(context.Context) SettingsParameterDescriptionResponseArrayOutput
}

type SettingsParameterDescriptionResponseArray []SettingsParameterDescriptionResponseInput

func (SettingsParameterDescriptionResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescriptionResponse)(nil)).Elem()
}

func (i SettingsParameterDescriptionResponseArray) ToSettingsParameterDescriptionResponseArrayOutput() SettingsParameterDescriptionResponseArrayOutput {
	return i.ToSettingsParameterDescriptionResponseArrayOutputWithContext(context.Background())
}

func (i SettingsParameterDescriptionResponseArray) ToSettingsParameterDescriptionResponseArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsParameterDescriptionResponseArrayOutput)
}

// Describes a parameter in fabric settings of the cluster.
type SettingsParameterDescriptionResponseOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsParameterDescriptionResponse)(nil)).Elem()
}

func (o SettingsParameterDescriptionResponseOutput) ToSettingsParameterDescriptionResponseOutput() SettingsParameterDescriptionResponseOutput {
	return o
}

func (o SettingsParameterDescriptionResponseOutput) ToSettingsParameterDescriptionResponseOutputWithContext(ctx context.Context) SettingsParameterDescriptionResponseOutput {
	return o
}

// The parameter name of fabric setting.
func (o SettingsParameterDescriptionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescriptionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The parameter value of fabric setting.
func (o SettingsParameterDescriptionResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsParameterDescriptionResponse) string { return v.Value }).(pulumi.StringOutput)
}

type SettingsParameterDescriptionResponseArrayOutput struct{ *pulumi.OutputState }

func (SettingsParameterDescriptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsParameterDescriptionResponse)(nil)).Elem()
}

func (o SettingsParameterDescriptionResponseArrayOutput) ToSettingsParameterDescriptionResponseArrayOutput() SettingsParameterDescriptionResponseArrayOutput {
	return o
}

func (o SettingsParameterDescriptionResponseArrayOutput) ToSettingsParameterDescriptionResponseArrayOutputWithContext(ctx context.Context) SettingsParameterDescriptionResponseArrayOutput {
	return o
}

func (o SettingsParameterDescriptionResponseArrayOutput) Index(i pulumi.IntInput) SettingsParameterDescriptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsParameterDescriptionResponse {
		return vs[0].([]SettingsParameterDescriptionResponse)[vs[1].(int)]
	}).(SettingsParameterDescriptionResponseOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescription struct {
	// The section name of the fabric settings.
	Name string `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters []SettingsParameterDescription `pulumi:"parameters"`
}

// SettingsSectionDescriptionInput is an input type that accepts SettingsSectionDescriptionArgs and SettingsSectionDescriptionOutput values.
// You can construct a concrete instance of `SettingsSectionDescriptionInput` via:
//
//          SettingsSectionDescriptionArgs{...}
type SettingsSectionDescriptionInput interface {
	pulumi.Input

	ToSettingsSectionDescriptionOutput() SettingsSectionDescriptionOutput
	ToSettingsSectionDescriptionOutputWithContext(context.Context) SettingsSectionDescriptionOutput
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionArgs struct {
	// The section name of the fabric settings.
	Name pulumi.StringInput `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters SettingsParameterDescriptionArrayInput `pulumi:"parameters"`
}

func (SettingsSectionDescriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescription)(nil)).Elem()
}

func (i SettingsSectionDescriptionArgs) ToSettingsSectionDescriptionOutput() SettingsSectionDescriptionOutput {
	return i.ToSettingsSectionDescriptionOutputWithContext(context.Background())
}

func (i SettingsSectionDescriptionArgs) ToSettingsSectionDescriptionOutputWithContext(ctx context.Context) SettingsSectionDescriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsSectionDescriptionOutput)
}

// SettingsSectionDescriptionArrayInput is an input type that accepts SettingsSectionDescriptionArray and SettingsSectionDescriptionArrayOutput values.
// You can construct a concrete instance of `SettingsSectionDescriptionArrayInput` via:
//
//          SettingsSectionDescriptionArray{ SettingsSectionDescriptionArgs{...} }
type SettingsSectionDescriptionArrayInput interface {
	pulumi.Input

	ToSettingsSectionDescriptionArrayOutput() SettingsSectionDescriptionArrayOutput
	ToSettingsSectionDescriptionArrayOutputWithContext(context.Context) SettingsSectionDescriptionArrayOutput
}

type SettingsSectionDescriptionArray []SettingsSectionDescriptionInput

func (SettingsSectionDescriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescription)(nil)).Elem()
}

func (i SettingsSectionDescriptionArray) ToSettingsSectionDescriptionArrayOutput() SettingsSectionDescriptionArrayOutput {
	return i.ToSettingsSectionDescriptionArrayOutputWithContext(context.Background())
}

func (i SettingsSectionDescriptionArray) ToSettingsSectionDescriptionArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsSectionDescriptionArrayOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescription)(nil)).Elem()
}

func (o SettingsSectionDescriptionOutput) ToSettingsSectionDescriptionOutput() SettingsSectionDescriptionOutput {
	return o
}

func (o SettingsSectionDescriptionOutput) ToSettingsSectionDescriptionOutputWithContext(ctx context.Context) SettingsSectionDescriptionOutput {
	return o
}

// The section name of the fabric settings.
func (o SettingsSectionDescriptionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsSectionDescription) string { return v.Name }).(pulumi.StringOutput)
}

// The collection of parameters in the section.
func (o SettingsSectionDescriptionOutput) Parameters() SettingsParameterDescriptionArrayOutput {
	return o.ApplyT(func(v SettingsSectionDescription) []SettingsParameterDescription { return v.Parameters }).(SettingsParameterDescriptionArrayOutput)
}

type SettingsSectionDescriptionArrayOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescription)(nil)).Elem()
}

func (o SettingsSectionDescriptionArrayOutput) ToSettingsSectionDescriptionArrayOutput() SettingsSectionDescriptionArrayOutput {
	return o
}

func (o SettingsSectionDescriptionArrayOutput) ToSettingsSectionDescriptionArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionArrayOutput {
	return o
}

func (o SettingsSectionDescriptionArrayOutput) Index(i pulumi.IntInput) SettingsSectionDescriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsSectionDescription {
		return vs[0].([]SettingsSectionDescription)[vs[1].(int)]
	}).(SettingsSectionDescriptionOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionResponse struct {
	// The section name of the fabric settings.
	Name string `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters []SettingsParameterDescriptionResponse `pulumi:"parameters"`
}

// SettingsSectionDescriptionResponseInput is an input type that accepts SettingsSectionDescriptionResponseArgs and SettingsSectionDescriptionResponseOutput values.
// You can construct a concrete instance of `SettingsSectionDescriptionResponseInput` via:
//
//          SettingsSectionDescriptionResponseArgs{...}
type SettingsSectionDescriptionResponseInput interface {
	pulumi.Input

	ToSettingsSectionDescriptionResponseOutput() SettingsSectionDescriptionResponseOutput
	ToSettingsSectionDescriptionResponseOutputWithContext(context.Context) SettingsSectionDescriptionResponseOutput
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionResponseArgs struct {
	// The section name of the fabric settings.
	Name pulumi.StringInput `pulumi:"name"`
	// The collection of parameters in the section.
	Parameters SettingsParameterDescriptionResponseArrayInput `pulumi:"parameters"`
}

func (SettingsSectionDescriptionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescriptionResponse)(nil)).Elem()
}

func (i SettingsSectionDescriptionResponseArgs) ToSettingsSectionDescriptionResponseOutput() SettingsSectionDescriptionResponseOutput {
	return i.ToSettingsSectionDescriptionResponseOutputWithContext(context.Background())
}

func (i SettingsSectionDescriptionResponseArgs) ToSettingsSectionDescriptionResponseOutputWithContext(ctx context.Context) SettingsSectionDescriptionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsSectionDescriptionResponseOutput)
}

// SettingsSectionDescriptionResponseArrayInput is an input type that accepts SettingsSectionDescriptionResponseArray and SettingsSectionDescriptionResponseArrayOutput values.
// You can construct a concrete instance of `SettingsSectionDescriptionResponseArrayInput` via:
//
//          SettingsSectionDescriptionResponseArray{ SettingsSectionDescriptionResponseArgs{...} }
type SettingsSectionDescriptionResponseArrayInput interface {
	pulumi.Input

	ToSettingsSectionDescriptionResponseArrayOutput() SettingsSectionDescriptionResponseArrayOutput
	ToSettingsSectionDescriptionResponseArrayOutputWithContext(context.Context) SettingsSectionDescriptionResponseArrayOutput
}

type SettingsSectionDescriptionResponseArray []SettingsSectionDescriptionResponseInput

func (SettingsSectionDescriptionResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescriptionResponse)(nil)).Elem()
}

func (i SettingsSectionDescriptionResponseArray) ToSettingsSectionDescriptionResponseArrayOutput() SettingsSectionDescriptionResponseArrayOutput {
	return i.ToSettingsSectionDescriptionResponseArrayOutputWithContext(context.Background())
}

func (i SettingsSectionDescriptionResponseArray) ToSettingsSectionDescriptionResponseArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SettingsSectionDescriptionResponseArrayOutput)
}

// Describes a section in the fabric settings of the cluster.
type SettingsSectionDescriptionResponseOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SettingsSectionDescriptionResponse)(nil)).Elem()
}

func (o SettingsSectionDescriptionResponseOutput) ToSettingsSectionDescriptionResponseOutput() SettingsSectionDescriptionResponseOutput {
	return o
}

func (o SettingsSectionDescriptionResponseOutput) ToSettingsSectionDescriptionResponseOutputWithContext(ctx context.Context) SettingsSectionDescriptionResponseOutput {
	return o
}

// The section name of the fabric settings.
func (o SettingsSectionDescriptionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SettingsSectionDescriptionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The collection of parameters in the section.
func (o SettingsSectionDescriptionResponseOutput) Parameters() SettingsParameterDescriptionResponseArrayOutput {
	return o.ApplyT(func(v SettingsSectionDescriptionResponse) []SettingsParameterDescriptionResponse { return v.Parameters }).(SettingsParameterDescriptionResponseArrayOutput)
}

type SettingsSectionDescriptionResponseArrayOutput struct{ *pulumi.OutputState }

func (SettingsSectionDescriptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SettingsSectionDescriptionResponse)(nil)).Elem()
}

func (o SettingsSectionDescriptionResponseArrayOutput) ToSettingsSectionDescriptionResponseArrayOutput() SettingsSectionDescriptionResponseArrayOutput {
	return o
}

func (o SettingsSectionDescriptionResponseArrayOutput) ToSettingsSectionDescriptionResponseArrayOutputWithContext(ctx context.Context) SettingsSectionDescriptionResponseArrayOutput {
	return o
}

func (o SettingsSectionDescriptionResponseArrayOutput) Index(i pulumi.IntInput) SettingsSectionDescriptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SettingsSectionDescriptionResponse {
		return vs[0].([]SettingsSectionDescriptionResponse)[vs[1].(int)]
	}).(SettingsSectionDescriptionResponseOutput)
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionScheme struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Singleton'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// SingletonPartitionSchemeInput is an input type that accepts SingletonPartitionSchemeArgs and SingletonPartitionSchemeOutput values.
// You can construct a concrete instance of `SingletonPartitionSchemeInput` via:
//
//          SingletonPartitionSchemeArgs{...}
type SingletonPartitionSchemeInput interface {
	pulumi.Input

	ToSingletonPartitionSchemeOutput() SingletonPartitionSchemeOutput
	ToSingletonPartitionSchemeOutputWithContext(context.Context) SingletonPartitionSchemeOutput
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Singleton'.
	PartitionScheme pulumi.StringInput `pulumi:"partitionScheme"`
}

func (SingletonPartitionSchemeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SingletonPartitionScheme)(nil)).Elem()
}

func (i SingletonPartitionSchemeArgs) ToSingletonPartitionSchemeOutput() SingletonPartitionSchemeOutput {
	return i.ToSingletonPartitionSchemeOutputWithContext(context.Background())
}

func (i SingletonPartitionSchemeArgs) ToSingletonPartitionSchemeOutputWithContext(ctx context.Context) SingletonPartitionSchemeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SingletonPartitionSchemeOutput)
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeOutput struct{ *pulumi.OutputState }

func (SingletonPartitionSchemeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SingletonPartitionScheme)(nil)).Elem()
}

func (o SingletonPartitionSchemeOutput) ToSingletonPartitionSchemeOutput() SingletonPartitionSchemeOutput {
	return o
}

func (o SingletonPartitionSchemeOutput) ToSingletonPartitionSchemeOutputWithContext(ctx context.Context) SingletonPartitionSchemeOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Singleton'.
func (o SingletonPartitionSchemeOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v SingletonPartitionScheme) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeResponse struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Singleton'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// SingletonPartitionSchemeResponseInput is an input type that accepts SingletonPartitionSchemeResponseArgs and SingletonPartitionSchemeResponseOutput values.
// You can construct a concrete instance of `SingletonPartitionSchemeResponseInput` via:
//
//          SingletonPartitionSchemeResponseArgs{...}
type SingletonPartitionSchemeResponseInput interface {
	pulumi.Input

	ToSingletonPartitionSchemeResponseOutput() SingletonPartitionSchemeResponseOutput
	ToSingletonPartitionSchemeResponseOutputWithContext(context.Context) SingletonPartitionSchemeResponseOutput
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeResponseArgs struct {
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'Singleton'.
	PartitionScheme pulumi.StringInput `pulumi:"partitionScheme"`
}

func (SingletonPartitionSchemeResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SingletonPartitionSchemeResponse)(nil)).Elem()
}

func (i SingletonPartitionSchemeResponseArgs) ToSingletonPartitionSchemeResponseOutput() SingletonPartitionSchemeResponseOutput {
	return i.ToSingletonPartitionSchemeResponseOutputWithContext(context.Background())
}

func (i SingletonPartitionSchemeResponseArgs) ToSingletonPartitionSchemeResponseOutputWithContext(ctx context.Context) SingletonPartitionSchemeResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SingletonPartitionSchemeResponseOutput)
}

// Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
type SingletonPartitionSchemeResponseOutput struct{ *pulumi.OutputState }

func (SingletonPartitionSchemeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SingletonPartitionSchemeResponse)(nil)).Elem()
}

func (o SingletonPartitionSchemeResponseOutput) ToSingletonPartitionSchemeResponseOutput() SingletonPartitionSchemeResponseOutput {
	return o
}

func (o SingletonPartitionSchemeResponseOutput) ToSingletonPartitionSchemeResponseOutputWithContext(ctx context.Context) SingletonPartitionSchemeResponseOutput {
	return o
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'Singleton'.
func (o SingletonPartitionSchemeResponseOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v SingletonPartitionSchemeResponse) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

// Service Fabric managed cluster Sku definition
type Sku struct {
	// Sku Name.
	Name string `pulumi:"name"`
}

// SkuInput is an input type that accepts SkuArgs and SkuOutput values.
// You can construct a concrete instance of `SkuInput` via:
//
//          SkuArgs{...}
type SkuInput interface {
	pulumi.Input

	ToSkuOutput() SkuOutput
	ToSkuOutputWithContext(context.Context) SkuOutput
}

// Service Fabric managed cluster Sku definition
type SkuArgs struct {
	// Sku Name.
	Name pulumi.StringInput `pulumi:"name"`
}

func (SkuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (i SkuArgs) ToSkuOutput() SkuOutput {
	return i.ToSkuOutputWithContext(context.Background())
}

func (i SkuArgs) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuOutput)
}

func (i SkuArgs) ToSkuPtrOutput() SkuPtrOutput {
	return i.ToSkuPtrOutputWithContext(context.Background())
}

func (i SkuArgs) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuOutput).ToSkuPtrOutputWithContext(ctx)
}

// SkuPtrInput is an input type that accepts SkuArgs, SkuPtr and SkuPtrOutput values.
// You can construct a concrete instance of `SkuPtrInput` via:
//
//          SkuArgs{...}
//
//  or:
//
//          nil
type SkuPtrInput interface {
	pulumi.Input

	ToSkuPtrOutput() SkuPtrOutput
	ToSkuPtrOutputWithContext(context.Context) SkuPtrOutput
}

type skuPtrType SkuArgs

func SkuPtr(v *SkuArgs) SkuPtrInput {
	return (*skuPtrType)(v)
}

func (*skuPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Sku)(nil)).Elem()
}

func (i *skuPtrType) ToSkuPtrOutput() SkuPtrOutput {
	return i.ToSkuPtrOutputWithContext(context.Background())
}

func (i *skuPtrType) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuPtrOutput)
}

// Service Fabric managed cluster Sku definition
type SkuOutput struct{ *pulumi.OutputState }

func (SkuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (o SkuOutput) ToSkuOutput() SkuOutput {
	return o
}

func (o SkuOutput) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return o
}

func (o SkuOutput) ToSkuPtrOutput() SkuPtrOutput {
	return o.ToSkuPtrOutputWithContext(context.Background())
}

func (o SkuOutput) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return o.ApplyT(func(v Sku) *Sku {
		return &v
	}).(SkuPtrOutput)
}

// Sku Name.
func (o SkuOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Sku) string { return v.Name }).(pulumi.StringOutput)
}

type SkuPtrOutput struct{ *pulumi.OutputState }

func (SkuPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Sku)(nil)).Elem()
}

func (o SkuPtrOutput) ToSkuPtrOutput() SkuPtrOutput {
	return o
}

func (o SkuPtrOutput) ToSkuPtrOutputWithContext(ctx context.Context) SkuPtrOutput {
	return o
}

func (o SkuPtrOutput) Elem() SkuOutput {
	return o.ApplyT(func(v *Sku) Sku { return *v }).(SkuOutput)
}

// Sku Name.
func (o SkuPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Sku) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Service Fabric managed cluster Sku definition
type SkuResponse struct {
	// Sku Name.
	Name string `pulumi:"name"`
}

// SkuResponseInput is an input type that accepts SkuResponseArgs and SkuResponseOutput values.
// You can construct a concrete instance of `SkuResponseInput` via:
//
//          SkuResponseArgs{...}
type SkuResponseInput interface {
	pulumi.Input

	ToSkuResponseOutput() SkuResponseOutput
	ToSkuResponseOutputWithContext(context.Context) SkuResponseOutput
}

// Service Fabric managed cluster Sku definition
type SkuResponseArgs struct {
	// Sku Name.
	Name pulumi.StringInput `pulumi:"name"`
}

func (SkuResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SkuResponse)(nil)).Elem()
}

func (i SkuResponseArgs) ToSkuResponseOutput() SkuResponseOutput {
	return i.ToSkuResponseOutputWithContext(context.Background())
}

func (i SkuResponseArgs) ToSkuResponseOutputWithContext(ctx context.Context) SkuResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuResponseOutput)
}

func (i SkuResponseArgs) ToSkuResponsePtrOutput() SkuResponsePtrOutput {
	return i.ToSkuResponsePtrOutputWithContext(context.Background())
}

func (i SkuResponseArgs) ToSkuResponsePtrOutputWithContext(ctx context.Context) SkuResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuResponseOutput).ToSkuResponsePtrOutputWithContext(ctx)
}

// SkuResponsePtrInput is an input type that accepts SkuResponseArgs, SkuResponsePtr and SkuResponsePtrOutput values.
// You can construct a concrete instance of `SkuResponsePtrInput` via:
//
//          SkuResponseArgs{...}
//
//  or:
//
//          nil
type SkuResponsePtrInput interface {
	pulumi.Input

	ToSkuResponsePtrOutput() SkuResponsePtrOutput
	ToSkuResponsePtrOutputWithContext(context.Context) SkuResponsePtrOutput
}

type skuResponsePtrType SkuResponseArgs

func SkuResponsePtr(v *SkuResponseArgs) SkuResponsePtrInput {
	return (*skuResponsePtrType)(v)
}

func (*skuResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SkuResponse)(nil)).Elem()
}

func (i *skuResponsePtrType) ToSkuResponsePtrOutput() SkuResponsePtrOutput {
	return i.ToSkuResponsePtrOutputWithContext(context.Background())
}

func (i *skuResponsePtrType) ToSkuResponsePtrOutputWithContext(ctx context.Context) SkuResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuResponsePtrOutput)
}

// Service Fabric managed cluster Sku definition
type SkuResponseOutput struct{ *pulumi.OutputState }

func (SkuResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SkuResponse)(nil)).Elem()
}

func (o SkuResponseOutput) ToSkuResponseOutput() SkuResponseOutput {
	return o
}

func (o SkuResponseOutput) ToSkuResponseOutputWithContext(ctx context.Context) SkuResponseOutput {
	return o
}

func (o SkuResponseOutput) ToSkuResponsePtrOutput() SkuResponsePtrOutput {
	return o.ToSkuResponsePtrOutputWithContext(context.Background())
}

func (o SkuResponseOutput) ToSkuResponsePtrOutputWithContext(ctx context.Context) SkuResponsePtrOutput {
	return o.ApplyT(func(v SkuResponse) *SkuResponse {
		return &v
	}).(SkuResponsePtrOutput)
}

// Sku Name.
func (o SkuResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SkuResponse) string { return v.Name }).(pulumi.StringOutput)
}

type SkuResponsePtrOutput struct{ *pulumi.OutputState }

func (SkuResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SkuResponse)(nil)).Elem()
}

func (o SkuResponsePtrOutput) ToSkuResponsePtrOutput() SkuResponsePtrOutput {
	return o
}

func (o SkuResponsePtrOutput) ToSkuResponsePtrOutputWithContext(ctx context.Context) SkuResponsePtrOutput {
	return o
}

func (o SkuResponsePtrOutput) Elem() SkuResponseOutput {
	return o.ApplyT(func(v *SkuResponse) SkuResponse { return *v }).(SkuResponseOutput)
}

// Sku Name.
func (o SkuResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SkuResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// The properties of a stateful service resource.
type StatefulServiceProperties struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelation `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
	HasPersistedState *bool `pulumi:"hasPersistedState"`
	// The minimum replica set size as a number.
	MinReplicaSetSize *int `pulumi:"minReplicaSetSize"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration *string `pulumi:"quorumLossWaitDuration"`
	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration *string `pulumi:"replicaRestartWaitDuration"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicy `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateful'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetric `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit *string `pulumi:"servicePlacementTimeLimit"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration *string `pulumi:"standByReplicaKeepDuration"`
	// The target replica set size as a number.
	TargetReplicaSetSize *int `pulumi:"targetReplicaSetSize"`
}

// StatefulServicePropertiesInput is an input type that accepts StatefulServicePropertiesArgs and StatefulServicePropertiesOutput values.
// You can construct a concrete instance of `StatefulServicePropertiesInput` via:
//
//          StatefulServicePropertiesArgs{...}
type StatefulServicePropertiesInput interface {
	pulumi.Input

	ToStatefulServicePropertiesOutput() StatefulServicePropertiesOutput
	ToStatefulServicePropertiesOutputWithContext(context.Context) StatefulServicePropertiesOutput
}

// The properties of a stateful service resource.
type StatefulServicePropertiesArgs struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme ServiceCorrelationArrayInput `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost pulumi.StringPtrInput `pulumi:"defaultMoveCost"`
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
	HasPersistedState pulumi.BoolPtrInput `pulumi:"hasPersistedState"`
	// The minimum replica set size as a number.
	MinReplicaSetSize pulumi.IntPtrInput `pulumi:"minReplicaSetSize"`
	// Describes how the service is partitioned.
	PartitionDescription pulumi.Input `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints pulumi.StringPtrInput `pulumi:"placementConstraints"`
	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration pulumi.StringPtrInput `pulumi:"quorumLossWaitDuration"`
	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration pulumi.StringPtrInput `pulumi:"replicaRestartWaitDuration"`
	// Scaling policies for this service.
	ScalingPolicies ScalingPolicyArrayInput `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateful'.
	ServiceKind pulumi.StringInput `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics ServiceLoadMetricArrayInput `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode pulumi.StringPtrInput `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies pulumi.ArrayInput `pulumi:"servicePlacementPolicies"`
	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit pulumi.StringPtrInput `pulumi:"servicePlacementTimeLimit"`
	// The name of the service type
	ServiceTypeName pulumi.StringInput `pulumi:"serviceTypeName"`
	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration pulumi.StringPtrInput `pulumi:"standByReplicaKeepDuration"`
	// The target replica set size as a number.
	TargetReplicaSetSize pulumi.IntPtrInput `pulumi:"targetReplicaSetSize"`
}

func (StatefulServicePropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulServiceProperties)(nil)).Elem()
}

func (i StatefulServicePropertiesArgs) ToStatefulServicePropertiesOutput() StatefulServicePropertiesOutput {
	return i.ToStatefulServicePropertiesOutputWithContext(context.Background())
}

func (i StatefulServicePropertiesArgs) ToStatefulServicePropertiesOutputWithContext(ctx context.Context) StatefulServicePropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulServicePropertiesOutput)
}

// The properties of a stateful service resource.
type StatefulServicePropertiesOutput struct{ *pulumi.OutputState }

func (StatefulServicePropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulServiceProperties)(nil)).Elem()
}

func (o StatefulServicePropertiesOutput) ToStatefulServicePropertiesOutput() StatefulServicePropertiesOutput {
	return o
}

func (o StatefulServicePropertiesOutput) ToStatefulServicePropertiesOutputWithContext(ctx context.Context) StatefulServicePropertiesOutput {
	return o
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesOutput) CorrelationScheme() ServiceCorrelationArrayOutput {
	return o.ApplyT(func(v StatefulServiceProperties) []ServiceCorrelation { return v.CorrelationScheme }).(ServiceCorrelationArrayOutput)
}

// Specifies the move cost for the service.
func (o StatefulServicePropertiesOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.DefaultMoveCost }).(pulumi.StringPtrOutput)
}

// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
func (o StatefulServicePropertiesOutput) HasPersistedState() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *bool { return v.HasPersistedState }).(pulumi.BoolPtrOutput)
}

// The minimum replica set size as a number.
func (o StatefulServicePropertiesOutput) MinReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *int { return v.MinReplicaSetSize }).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatefulServicePropertiesOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v StatefulServiceProperties) interface{} { return v.PartitionDescription }).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatefulServicePropertiesOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.PlacementConstraints }).(pulumi.StringPtrOutput)
}

// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesOutput) QuorumLossWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.QuorumLossWaitDuration }).(pulumi.StringPtrOutput)
}

// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesOutput) ReplicaRestartWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.ReplicaRestartWaitDuration }).(pulumi.StringPtrOutput)
}

// Scaling policies for this service.
func (o StatefulServicePropertiesOutput) ScalingPolicies() ScalingPolicyArrayOutput {
	return o.ApplyT(func(v StatefulServiceProperties) []ScalingPolicy { return v.ScalingPolicies }).(ScalingPolicyArrayOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateful'.
func (o StatefulServicePropertiesOutput) ServiceKind() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServiceProperties) string { return v.ServiceKind }).(pulumi.StringOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatefulServicePropertiesOutput) ServiceLoadMetrics() ServiceLoadMetricArrayOutput {
	return o.ApplyT(func(v StatefulServiceProperties) []ServiceLoadMetric { return v.ServiceLoadMetrics }).(ServiceLoadMetricArrayOutput)
}

// The activation Mode of the service package
func (o StatefulServicePropertiesOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.ServicePackageActivationMode }).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v StatefulServiceProperties) []interface{} { return v.ServicePlacementPolicies }).(pulumi.ArrayOutput)
}

// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesOutput) ServicePlacementTimeLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.ServicePlacementTimeLimit }).(pulumi.StringPtrOutput)
}

// The name of the service type
func (o StatefulServicePropertiesOutput) ServiceTypeName() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServiceProperties) string { return v.ServiceTypeName }).(pulumi.StringOutput)
}

// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesOutput) StandByReplicaKeepDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *string { return v.StandByReplicaKeepDuration }).(pulumi.StringPtrOutput)
}

// The target replica set size as a number.
func (o StatefulServicePropertiesOutput) TargetReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulServiceProperties) *int { return v.TargetReplicaSetSize }).(pulumi.IntPtrOutput)
}

// The properties of a stateful service resource.
type StatefulServicePropertiesResponse struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelationResponse `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
	HasPersistedState *bool `pulumi:"hasPersistedState"`
	// The minimum replica set size as a number.
	MinReplicaSetSize *int `pulumi:"minReplicaSetSize"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// The current deployment or provisioning state, which only appears in the response
	ProvisioningState string `pulumi:"provisioningState"`
	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration *string `pulumi:"quorumLossWaitDuration"`
	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration *string `pulumi:"replicaRestartWaitDuration"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicyResponse `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateful'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetricResponse `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit *string `pulumi:"servicePlacementTimeLimit"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration *string `pulumi:"standByReplicaKeepDuration"`
	// The target replica set size as a number.
	TargetReplicaSetSize *int `pulumi:"targetReplicaSetSize"`
}

// StatefulServicePropertiesResponseInput is an input type that accepts StatefulServicePropertiesResponseArgs and StatefulServicePropertiesResponseOutput values.
// You can construct a concrete instance of `StatefulServicePropertiesResponseInput` via:
//
//          StatefulServicePropertiesResponseArgs{...}
type StatefulServicePropertiesResponseInput interface {
	pulumi.Input

	ToStatefulServicePropertiesResponseOutput() StatefulServicePropertiesResponseOutput
	ToStatefulServicePropertiesResponseOutputWithContext(context.Context) StatefulServicePropertiesResponseOutput
}

// The properties of a stateful service resource.
type StatefulServicePropertiesResponseArgs struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme ServiceCorrelationResponseArrayInput `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost pulumi.StringPtrInput `pulumi:"defaultMoveCost"`
	// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
	HasPersistedState pulumi.BoolPtrInput `pulumi:"hasPersistedState"`
	// The minimum replica set size as a number.
	MinReplicaSetSize pulumi.IntPtrInput `pulumi:"minReplicaSetSize"`
	// Describes how the service is partitioned.
	PartitionDescription pulumi.Input `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints pulumi.StringPtrInput `pulumi:"placementConstraints"`
	// The current deployment or provisioning state, which only appears in the response
	ProvisioningState pulumi.StringInput `pulumi:"provisioningState"`
	// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
	QuorumLossWaitDuration pulumi.StringPtrInput `pulumi:"quorumLossWaitDuration"`
	// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
	ReplicaRestartWaitDuration pulumi.StringPtrInput `pulumi:"replicaRestartWaitDuration"`
	// Scaling policies for this service.
	ScalingPolicies ScalingPolicyResponseArrayInput `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateful'.
	ServiceKind pulumi.StringInput `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics ServiceLoadMetricResponseArrayInput `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode pulumi.StringPtrInput `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies pulumi.ArrayInput `pulumi:"servicePlacementPolicies"`
	// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
	ServicePlacementTimeLimit pulumi.StringPtrInput `pulumi:"servicePlacementTimeLimit"`
	// The name of the service type
	ServiceTypeName pulumi.StringInput `pulumi:"serviceTypeName"`
	// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
	StandByReplicaKeepDuration pulumi.StringPtrInput `pulumi:"standByReplicaKeepDuration"`
	// The target replica set size as a number.
	TargetReplicaSetSize pulumi.IntPtrInput `pulumi:"targetReplicaSetSize"`
}

func (StatefulServicePropertiesResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulServicePropertiesResponse)(nil)).Elem()
}

func (i StatefulServicePropertiesResponseArgs) ToStatefulServicePropertiesResponseOutput() StatefulServicePropertiesResponseOutput {
	return i.ToStatefulServicePropertiesResponseOutputWithContext(context.Background())
}

func (i StatefulServicePropertiesResponseArgs) ToStatefulServicePropertiesResponseOutputWithContext(ctx context.Context) StatefulServicePropertiesResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatefulServicePropertiesResponseOutput)
}

// The properties of a stateful service resource.
type StatefulServicePropertiesResponseOutput struct{ *pulumi.OutputState }

func (StatefulServicePropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulServicePropertiesResponse)(nil)).Elem()
}

func (o StatefulServicePropertiesResponseOutput) ToStatefulServicePropertiesResponseOutput() StatefulServicePropertiesResponseOutput {
	return o
}

func (o StatefulServicePropertiesResponseOutput) ToStatefulServicePropertiesResponseOutputWithContext(ctx context.Context) StatefulServicePropertiesResponseOutput {
	return o
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesResponseOutput) CorrelationScheme() ServiceCorrelationResponseArrayOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) []ServiceCorrelationResponse { return v.CorrelationScheme }).(ServiceCorrelationResponseArrayOutput)
}

// Specifies the move cost for the service.
func (o StatefulServicePropertiesResponseOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.DefaultMoveCost }).(pulumi.StringPtrOutput)
}

// A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
func (o StatefulServicePropertiesResponseOutput) HasPersistedState() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *bool { return v.HasPersistedState }).(pulumi.BoolPtrOutput)
}

// The minimum replica set size as a number.
func (o StatefulServicePropertiesResponseOutput) MinReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *int { return v.MinReplicaSetSize }).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatefulServicePropertiesResponseOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) interface{} { return v.PartitionDescription }).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatefulServicePropertiesResponseOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.PlacementConstraints }).(pulumi.StringPtrOutput)
}

// The current deployment or provisioning state, which only appears in the response
func (o StatefulServicePropertiesResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesResponseOutput) QuorumLossWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.QuorumLossWaitDuration }).(pulumi.StringPtrOutput)
}

// The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesResponseOutput) ReplicaRestartWaitDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.ReplicaRestartWaitDuration }).(pulumi.StringPtrOutput)
}

// Scaling policies for this service.
func (o StatefulServicePropertiesResponseOutput) ScalingPolicies() ScalingPolicyResponseArrayOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) []ScalingPolicyResponse { return v.ScalingPolicies }).(ScalingPolicyResponseArrayOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateful'.
func (o StatefulServicePropertiesResponseOutput) ServiceKind() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) string { return v.ServiceKind }).(pulumi.StringOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatefulServicePropertiesResponseOutput) ServiceLoadMetrics() ServiceLoadMetricResponseArrayOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) []ServiceLoadMetricResponse { return v.ServiceLoadMetrics }).(ServiceLoadMetricResponseArrayOutput)
}

// The activation Mode of the service package
func (o StatefulServicePropertiesResponseOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.ServicePackageActivationMode }).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatefulServicePropertiesResponseOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) []interface{} { return v.ServicePlacementPolicies }).(pulumi.ArrayOutput)
}

// The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesResponseOutput) ServicePlacementTimeLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.ServicePlacementTimeLimit }).(pulumi.StringPtrOutput)
}

// The name of the service type
func (o StatefulServicePropertiesResponseOutput) ServiceTypeName() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) string { return v.ServiceTypeName }).(pulumi.StringOutput)
}

// The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
func (o StatefulServicePropertiesResponseOutput) StandByReplicaKeepDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *string { return v.StandByReplicaKeepDuration }).(pulumi.StringPtrOutput)
}

// The target replica set size as a number.
func (o StatefulServicePropertiesResponseOutput) TargetReplicaSetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatefulServicePropertiesResponse) *int { return v.TargetReplicaSetSize }).(pulumi.IntPtrOutput)
}

// The properties of a stateless service resource.
type StatelessServiceProperties struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelation `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// The instance count.
	InstanceCount int `pulumi:"instanceCount"`
	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount *int `pulumi:"minInstanceCount"`
	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage *int `pulumi:"minInstancePercentage"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicy `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateless'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetric `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
}

// StatelessServicePropertiesInput is an input type that accepts StatelessServicePropertiesArgs and StatelessServicePropertiesOutput values.
// You can construct a concrete instance of `StatelessServicePropertiesInput` via:
//
//          StatelessServicePropertiesArgs{...}
type StatelessServicePropertiesInput interface {
	pulumi.Input

	ToStatelessServicePropertiesOutput() StatelessServicePropertiesOutput
	ToStatelessServicePropertiesOutputWithContext(context.Context) StatelessServicePropertiesOutput
}

// The properties of a stateless service resource.
type StatelessServicePropertiesArgs struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme ServiceCorrelationArrayInput `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost pulumi.StringPtrInput `pulumi:"defaultMoveCost"`
	// The instance count.
	InstanceCount pulumi.IntInput `pulumi:"instanceCount"`
	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount pulumi.IntPtrInput `pulumi:"minInstanceCount"`
	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage pulumi.IntPtrInput `pulumi:"minInstancePercentage"`
	// Describes how the service is partitioned.
	PartitionDescription pulumi.Input `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints pulumi.StringPtrInput `pulumi:"placementConstraints"`
	// Scaling policies for this service.
	ScalingPolicies ScalingPolicyArrayInput `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateless'.
	ServiceKind pulumi.StringInput `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics ServiceLoadMetricArrayInput `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode pulumi.StringPtrInput `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies pulumi.ArrayInput `pulumi:"servicePlacementPolicies"`
	// The name of the service type
	ServiceTypeName pulumi.StringInput `pulumi:"serviceTypeName"`
}

func (StatelessServicePropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatelessServiceProperties)(nil)).Elem()
}

func (i StatelessServicePropertiesArgs) ToStatelessServicePropertiesOutput() StatelessServicePropertiesOutput {
	return i.ToStatelessServicePropertiesOutputWithContext(context.Background())
}

func (i StatelessServicePropertiesArgs) ToStatelessServicePropertiesOutputWithContext(ctx context.Context) StatelessServicePropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatelessServicePropertiesOutput)
}

// The properties of a stateless service resource.
type StatelessServicePropertiesOutput struct{ *pulumi.OutputState }

func (StatelessServicePropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatelessServiceProperties)(nil)).Elem()
}

func (o StatelessServicePropertiesOutput) ToStatelessServicePropertiesOutput() StatelessServicePropertiesOutput {
	return o
}

func (o StatelessServicePropertiesOutput) ToStatelessServicePropertiesOutputWithContext(ctx context.Context) StatelessServicePropertiesOutput {
	return o
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesOutput) CorrelationScheme() ServiceCorrelationArrayOutput {
	return o.ApplyT(func(v StatelessServiceProperties) []ServiceCorrelation { return v.CorrelationScheme }).(ServiceCorrelationArrayOutput)
}

// Specifies the move cost for the service.
func (o StatelessServicePropertiesOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *string { return v.DefaultMoveCost }).(pulumi.StringPtrOutput)
}

// The instance count.
func (o StatelessServicePropertiesOutput) InstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v StatelessServiceProperties) int { return v.InstanceCount }).(pulumi.IntOutput)
}

// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesOutput) MinInstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *int { return v.MinInstanceCount }).(pulumi.IntPtrOutput)
}

// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesOutput) MinInstancePercentage() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *int { return v.MinInstancePercentage }).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatelessServicePropertiesOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v StatelessServiceProperties) interface{} { return v.PartitionDescription }).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatelessServicePropertiesOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *string { return v.PlacementConstraints }).(pulumi.StringPtrOutput)
}

// Scaling policies for this service.
func (o StatelessServicePropertiesOutput) ScalingPolicies() ScalingPolicyArrayOutput {
	return o.ApplyT(func(v StatelessServiceProperties) []ScalingPolicy { return v.ScalingPolicies }).(ScalingPolicyArrayOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateless'.
func (o StatelessServicePropertiesOutput) ServiceKind() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServiceProperties) string { return v.ServiceKind }).(pulumi.StringOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatelessServicePropertiesOutput) ServiceLoadMetrics() ServiceLoadMetricArrayOutput {
	return o.ApplyT(func(v StatelessServiceProperties) []ServiceLoadMetric { return v.ServiceLoadMetrics }).(ServiceLoadMetricArrayOutput)
}

// The activation Mode of the service package
func (o StatelessServicePropertiesOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServiceProperties) *string { return v.ServicePackageActivationMode }).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v StatelessServiceProperties) []interface{} { return v.ServicePlacementPolicies }).(pulumi.ArrayOutput)
}

// The name of the service type
func (o StatelessServicePropertiesOutput) ServiceTypeName() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServiceProperties) string { return v.ServiceTypeName }).(pulumi.StringOutput)
}

// The properties of a stateless service resource.
type StatelessServicePropertiesResponse struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme []ServiceCorrelationResponse `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost *string `pulumi:"defaultMoveCost"`
	// The instance count.
	InstanceCount int `pulumi:"instanceCount"`
	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount *int `pulumi:"minInstanceCount"`
	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage *int `pulumi:"minInstancePercentage"`
	// Describes how the service is partitioned.
	PartitionDescription interface{} `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints *string `pulumi:"placementConstraints"`
	// The current deployment or provisioning state, which only appears in the response
	ProvisioningState string `pulumi:"provisioningState"`
	// Scaling policies for this service.
	ScalingPolicies []ScalingPolicyResponse `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateless'.
	ServiceKind string `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics []ServiceLoadMetricResponse `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode *string `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies []interface{} `pulumi:"servicePlacementPolicies"`
	// The name of the service type
	ServiceTypeName string `pulumi:"serviceTypeName"`
}

// StatelessServicePropertiesResponseInput is an input type that accepts StatelessServicePropertiesResponseArgs and StatelessServicePropertiesResponseOutput values.
// You can construct a concrete instance of `StatelessServicePropertiesResponseInput` via:
//
//          StatelessServicePropertiesResponseArgs{...}
type StatelessServicePropertiesResponseInput interface {
	pulumi.Input

	ToStatelessServicePropertiesResponseOutput() StatelessServicePropertiesResponseOutput
	ToStatelessServicePropertiesResponseOutputWithContext(context.Context) StatelessServicePropertiesResponseOutput
}

// The properties of a stateless service resource.
type StatelessServicePropertiesResponseArgs struct {
	// A list that describes the correlation of the service with other services.
	CorrelationScheme ServiceCorrelationResponseArrayInput `pulumi:"correlationScheme"`
	// Specifies the move cost for the service.
	DefaultMoveCost pulumi.StringPtrInput `pulumi:"defaultMoveCost"`
	// The instance count.
	InstanceCount pulumi.IntInput `pulumi:"instanceCount"`
	// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstanceCount pulumi.IntPtrInput `pulumi:"minInstanceCount"`
	// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
	MinInstancePercentage pulumi.IntPtrInput `pulumi:"minInstancePercentage"`
	// Describes how the service is partitioned.
	PartitionDescription pulumi.Input `pulumi:"partitionDescription"`
	// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
	PlacementConstraints pulumi.StringPtrInput `pulumi:"placementConstraints"`
	// The current deployment or provisioning state, which only appears in the response
	ProvisioningState pulumi.StringInput `pulumi:"provisioningState"`
	// Scaling policies for this service.
	ScalingPolicies ScalingPolicyResponseArrayInput `pulumi:"scalingPolicies"`
	// The kind of service (Stateless or Stateful).
	// Expected value is 'Stateless'.
	ServiceKind pulumi.StringInput `pulumi:"serviceKind"`
	// The service load metrics is given as an array of ServiceLoadMetric objects.
	ServiceLoadMetrics ServiceLoadMetricResponseArrayInput `pulumi:"serviceLoadMetrics"`
	// The activation Mode of the service package
	ServicePackageActivationMode pulumi.StringPtrInput `pulumi:"servicePackageActivationMode"`
	// A list that describes the correlation of the service with other services.
	ServicePlacementPolicies pulumi.ArrayInput `pulumi:"servicePlacementPolicies"`
	// The name of the service type
	ServiceTypeName pulumi.StringInput `pulumi:"serviceTypeName"`
}

func (StatelessServicePropertiesResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatelessServicePropertiesResponse)(nil)).Elem()
}

func (i StatelessServicePropertiesResponseArgs) ToStatelessServicePropertiesResponseOutput() StatelessServicePropertiesResponseOutput {
	return i.ToStatelessServicePropertiesResponseOutputWithContext(context.Background())
}

func (i StatelessServicePropertiesResponseArgs) ToStatelessServicePropertiesResponseOutputWithContext(ctx context.Context) StatelessServicePropertiesResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatelessServicePropertiesResponseOutput)
}

// The properties of a stateless service resource.
type StatelessServicePropertiesResponseOutput struct{ *pulumi.OutputState }

func (StatelessServicePropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatelessServicePropertiesResponse)(nil)).Elem()
}

func (o StatelessServicePropertiesResponseOutput) ToStatelessServicePropertiesResponseOutput() StatelessServicePropertiesResponseOutput {
	return o
}

func (o StatelessServicePropertiesResponseOutput) ToStatelessServicePropertiesResponseOutputWithContext(ctx context.Context) StatelessServicePropertiesResponseOutput {
	return o
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesResponseOutput) CorrelationScheme() ServiceCorrelationResponseArrayOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) []ServiceCorrelationResponse { return v.CorrelationScheme }).(ServiceCorrelationResponseArrayOutput)
}

// Specifies the move cost for the service.
func (o StatelessServicePropertiesResponseOutput) DefaultMoveCost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *string { return v.DefaultMoveCost }).(pulumi.StringPtrOutput)
}

// The instance count.
func (o StatelessServicePropertiesResponseOutput) InstanceCount() pulumi.IntOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) int { return v.InstanceCount }).(pulumi.IntOutput)
}

// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesResponseOutput) MinInstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *int { return v.MinInstanceCount }).(pulumi.IntPtrOutput)
}

// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
func (o StatelessServicePropertiesResponseOutput) MinInstancePercentage() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *int { return v.MinInstancePercentage }).(pulumi.IntPtrOutput)
}

// Describes how the service is partitioned.
func (o StatelessServicePropertiesResponseOutput) PartitionDescription() pulumi.AnyOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) interface{} { return v.PartitionDescription }).(pulumi.AnyOutput)
}

// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
func (o StatelessServicePropertiesResponseOutput) PlacementConstraints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *string { return v.PlacementConstraints }).(pulumi.StringPtrOutput)
}

// The current deployment or provisioning state, which only appears in the response
func (o StatelessServicePropertiesResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Scaling policies for this service.
func (o StatelessServicePropertiesResponseOutput) ScalingPolicies() ScalingPolicyResponseArrayOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) []ScalingPolicyResponse { return v.ScalingPolicies }).(ScalingPolicyResponseArrayOutput)
}

// The kind of service (Stateless or Stateful).
// Expected value is 'Stateless'.
func (o StatelessServicePropertiesResponseOutput) ServiceKind() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) string { return v.ServiceKind }).(pulumi.StringOutput)
}

// The service load metrics is given as an array of ServiceLoadMetric objects.
func (o StatelessServicePropertiesResponseOutput) ServiceLoadMetrics() ServiceLoadMetricResponseArrayOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) []ServiceLoadMetricResponse { return v.ServiceLoadMetrics }).(ServiceLoadMetricResponseArrayOutput)
}

// The activation Mode of the service package
func (o StatelessServicePropertiesResponseOutput) ServicePackageActivationMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) *string { return v.ServicePackageActivationMode }).(pulumi.StringPtrOutput)
}

// A list that describes the correlation of the service with other services.
func (o StatelessServicePropertiesResponseOutput) ServicePlacementPolicies() pulumi.ArrayOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) []interface{} { return v.ServicePlacementPolicies }).(pulumi.ArrayOutput)
}

// The name of the service type
func (o StatelessServicePropertiesResponseOutput) ServiceTypeName() pulumi.StringOutput {
	return o.ApplyT(func(v StatelessServicePropertiesResponse) string { return v.ServiceTypeName }).(pulumi.StringOutput)
}

// Azure resource identifier.
type SubResource struct {
	// Azure resource identifier.
	Id *string `pulumi:"id"`
}

// SubResourceInput is an input type that accepts SubResourceArgs and SubResourceOutput values.
// You can construct a concrete instance of `SubResourceInput` via:
//
//          SubResourceArgs{...}
type SubResourceInput interface {
	pulumi.Input

	ToSubResourceOutput() SubResourceOutput
	ToSubResourceOutputWithContext(context.Context) SubResourceOutput
}

// Azure resource identifier.
type SubResourceArgs struct {
	// Azure resource identifier.
	Id pulumi.StringPtrInput `pulumi:"id"`
}

func (SubResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResource)(nil)).Elem()
}

func (i SubResourceArgs) ToSubResourceOutput() SubResourceOutput {
	return i.ToSubResourceOutputWithContext(context.Background())
}

func (i SubResourceArgs) ToSubResourceOutputWithContext(ctx context.Context) SubResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubResourceOutput)
}

// Azure resource identifier.
type SubResourceOutput struct{ *pulumi.OutputState }

func (SubResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResource)(nil)).Elem()
}

func (o SubResourceOutput) ToSubResourceOutput() SubResourceOutput {
	return o
}

func (o SubResourceOutput) ToSubResourceOutputWithContext(ctx context.Context) SubResourceOutput {
	return o
}

// Azure resource identifier.
func (o SubResourceOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubResource) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Azure resource identifier.
type SubResourceResponse struct {
	// Azure resource identifier.
	Id *string `pulumi:"id"`
}

// SubResourceResponseInput is an input type that accepts SubResourceResponseArgs and SubResourceResponseOutput values.
// You can construct a concrete instance of `SubResourceResponseInput` via:
//
//          SubResourceResponseArgs{...}
type SubResourceResponseInput interface {
	pulumi.Input

	ToSubResourceResponseOutput() SubResourceResponseOutput
	ToSubResourceResponseOutputWithContext(context.Context) SubResourceResponseOutput
}

// Azure resource identifier.
type SubResourceResponseArgs struct {
	// Azure resource identifier.
	Id pulumi.StringPtrInput `pulumi:"id"`
}

func (SubResourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResourceResponse)(nil)).Elem()
}

func (i SubResourceResponseArgs) ToSubResourceResponseOutput() SubResourceResponseOutput {
	return i.ToSubResourceResponseOutputWithContext(context.Background())
}

func (i SubResourceResponseArgs) ToSubResourceResponseOutputWithContext(ctx context.Context) SubResourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubResourceResponseOutput)
}

// Azure resource identifier.
type SubResourceResponseOutput struct{ *pulumi.OutputState }

func (SubResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubResourceResponse)(nil)).Elem()
}

func (o SubResourceResponseOutput) ToSubResourceResponseOutput() SubResourceResponseOutput {
	return o
}

func (o SubResourceResponseOutput) ToSubResourceResponseOutputWithContext(ctx context.Context) SubResourceResponseOutput {
	return o
}

// Azure resource identifier.
func (o SubResourceResponseOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubResourceResponse) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponse struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *string `pulumi:"createdAt"`
	// The identity that created the resource.
	CreatedBy *string `pulumi:"createdBy"`
	// The type of identity that created the resource.
	CreatedByType *string `pulumi:"createdByType"`
	// The timestamp of resource last modification (UTC).
	LastModifiedAt *string `pulumi:"lastModifiedAt"`
	// The identity that last modified the resource.
	LastModifiedBy *string `pulumi:"lastModifiedBy"`
	// The type of identity that last modified the resource.
	LastModifiedByType *string `pulumi:"lastModifiedByType"`
}

// SystemDataResponseInput is an input type that accepts SystemDataResponseArgs and SystemDataResponseOutput values.
// You can construct a concrete instance of `SystemDataResponseInput` via:
//
//          SystemDataResponseArgs{...}
type SystemDataResponseInput interface {
	pulumi.Input

	ToSystemDataResponseOutput() SystemDataResponseOutput
	ToSystemDataResponseOutputWithContext(context.Context) SystemDataResponseOutput
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponseArgs struct {
	// The timestamp of resource creation (UTC).
	CreatedAt pulumi.StringPtrInput `pulumi:"createdAt"`
	// The identity that created the resource.
	CreatedBy pulumi.StringPtrInput `pulumi:"createdBy"`
	// The type of identity that created the resource.
	CreatedByType pulumi.StringPtrInput `pulumi:"createdByType"`
	// The timestamp of resource last modification (UTC).
	LastModifiedAt pulumi.StringPtrInput `pulumi:"lastModifiedAt"`
	// The identity that last modified the resource.
	LastModifiedBy pulumi.StringPtrInput `pulumi:"lastModifiedBy"`
	// The type of identity that last modified the resource.
	LastModifiedByType pulumi.StringPtrInput `pulumi:"lastModifiedByType"`
}

func (SystemDataResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SystemDataResponse)(nil)).Elem()
}

func (i SystemDataResponseArgs) ToSystemDataResponseOutput() SystemDataResponseOutput {
	return i.ToSystemDataResponseOutputWithContext(context.Background())
}

func (i SystemDataResponseArgs) ToSystemDataResponseOutputWithContext(ctx context.Context) SystemDataResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SystemDataResponseOutput)
}

func (i SystemDataResponseArgs) ToSystemDataResponsePtrOutput() SystemDataResponsePtrOutput {
	return i.ToSystemDataResponsePtrOutputWithContext(context.Background())
}

func (i SystemDataResponseArgs) ToSystemDataResponsePtrOutputWithContext(ctx context.Context) SystemDataResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SystemDataResponseOutput).ToSystemDataResponsePtrOutputWithContext(ctx)
}

// SystemDataResponsePtrInput is an input type that accepts SystemDataResponseArgs, SystemDataResponsePtr and SystemDataResponsePtrOutput values.
// You can construct a concrete instance of `SystemDataResponsePtrInput` via:
//
//          SystemDataResponseArgs{...}
//
//  or:
//
//          nil
type SystemDataResponsePtrInput interface {
	pulumi.Input

	ToSystemDataResponsePtrOutput() SystemDataResponsePtrOutput
	ToSystemDataResponsePtrOutputWithContext(context.Context) SystemDataResponsePtrOutput
}

type systemDataResponsePtrType SystemDataResponseArgs

func SystemDataResponsePtr(v *SystemDataResponseArgs) SystemDataResponsePtrInput {
	return (*systemDataResponsePtrType)(v)
}

func (*systemDataResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SystemDataResponse)(nil)).Elem()
}

func (i *systemDataResponsePtrType) ToSystemDataResponsePtrOutput() SystemDataResponsePtrOutput {
	return i.ToSystemDataResponsePtrOutputWithContext(context.Background())
}

func (i *systemDataResponsePtrType) ToSystemDataResponsePtrOutputWithContext(ctx context.Context) SystemDataResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SystemDataResponsePtrOutput)
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponseOutput struct{ *pulumi.OutputState }

func (SystemDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SystemDataResponse)(nil)).Elem()
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutput() SystemDataResponseOutput {
	return o
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutputWithContext(ctx context.Context) SystemDataResponseOutput {
	return o
}

func (o SystemDataResponseOutput) ToSystemDataResponsePtrOutput() SystemDataResponsePtrOutput {
	return o.ToSystemDataResponsePtrOutputWithContext(context.Background())
}

func (o SystemDataResponseOutput) ToSystemDataResponsePtrOutputWithContext(ctx context.Context) SystemDataResponsePtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *SystemDataResponse {
		return &v
	}).(SystemDataResponsePtrOutput)
}

// The timestamp of resource creation (UTC).
func (o SystemDataResponseOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedAt }).(pulumi.StringPtrOutput)
}

// The identity that created the resource.
func (o SystemDataResponseOutput) CreatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that created the resource.
func (o SystemDataResponseOutput) CreatedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedByType }).(pulumi.StringPtrOutput)
}

// The timestamp of resource last modification (UTC).
func (o SystemDataResponseOutput) LastModifiedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedAt }).(pulumi.StringPtrOutput)
}

// The identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedByType }).(pulumi.StringPtrOutput)
}

type SystemDataResponsePtrOutput struct{ *pulumi.OutputState }

func (SystemDataResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SystemDataResponse)(nil)).Elem()
}

func (o SystemDataResponsePtrOutput) ToSystemDataResponsePtrOutput() SystemDataResponsePtrOutput {
	return o
}

func (o SystemDataResponsePtrOutput) ToSystemDataResponsePtrOutputWithContext(ctx context.Context) SystemDataResponsePtrOutput {
	return o
}

func (o SystemDataResponsePtrOutput) Elem() SystemDataResponseOutput {
	return o.ApplyT(func(v *SystemDataResponse) SystemDataResponse { return *v }).(SystemDataResponseOutput)
}

// The timestamp of resource creation (UTC).
func (o SystemDataResponsePtrOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SystemDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.CreatedAt
	}).(pulumi.StringPtrOutput)
}

// The identity that created the resource.
func (o SystemDataResponsePtrOutput) CreatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SystemDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.CreatedBy
	}).(pulumi.StringPtrOutput)
}

// The type of identity that created the resource.
func (o SystemDataResponsePtrOutput) CreatedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SystemDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.CreatedByType
	}).(pulumi.StringPtrOutput)
}

// The timestamp of resource last modification (UTC).
func (o SystemDataResponsePtrOutput) LastModifiedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SystemDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.LastModifiedAt
	}).(pulumi.StringPtrOutput)
}

// The identity that last modified the resource.
func (o SystemDataResponsePtrOutput) LastModifiedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SystemDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.LastModifiedBy
	}).(pulumi.StringPtrOutput)
}

// The type of identity that last modified the resource.
func (o SystemDataResponsePtrOutput) LastModifiedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SystemDataResponse) *string {
		if v == nil {
			return nil
		}
		return v.LastModifiedByType
	}).(pulumi.StringPtrOutput)
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionScheme struct {
	// The number of partitions.
	Count int `pulumi:"count"`
	// The upper bound of the partition key range that
	// should be split between the partition ‘Count’
	HighKey float64 `pulumi:"highKey"`
	// The lower bound of the partition key range that
	// should be split between the partition ‘Count’
	LowKey float64 `pulumi:"lowKey"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'UniformInt64Range'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// UniformInt64RangePartitionSchemeInput is an input type that accepts UniformInt64RangePartitionSchemeArgs and UniformInt64RangePartitionSchemeOutput values.
// You can construct a concrete instance of `UniformInt64RangePartitionSchemeInput` via:
//
//          UniformInt64RangePartitionSchemeArgs{...}
type UniformInt64RangePartitionSchemeInput interface {
	pulumi.Input

	ToUniformInt64RangePartitionSchemeOutput() UniformInt64RangePartitionSchemeOutput
	ToUniformInt64RangePartitionSchemeOutputWithContext(context.Context) UniformInt64RangePartitionSchemeOutput
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeArgs struct {
	// The number of partitions.
	Count pulumi.IntInput `pulumi:"count"`
	// The upper bound of the partition key range that
	// should be split between the partition ‘Count’
	HighKey pulumi.Float64Input `pulumi:"highKey"`
	// The lower bound of the partition key range that
	// should be split between the partition ‘Count’
	LowKey pulumi.Float64Input `pulumi:"lowKey"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'UniformInt64Range'.
	PartitionScheme pulumi.StringInput `pulumi:"partitionScheme"`
}

func (UniformInt64RangePartitionSchemeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UniformInt64RangePartitionScheme)(nil)).Elem()
}

func (i UniformInt64RangePartitionSchemeArgs) ToUniformInt64RangePartitionSchemeOutput() UniformInt64RangePartitionSchemeOutput {
	return i.ToUniformInt64RangePartitionSchemeOutputWithContext(context.Background())
}

func (i UniformInt64RangePartitionSchemeArgs) ToUniformInt64RangePartitionSchemeOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UniformInt64RangePartitionSchemeOutput)
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeOutput struct{ *pulumi.OutputState }

func (UniformInt64RangePartitionSchemeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UniformInt64RangePartitionScheme)(nil)).Elem()
}

func (o UniformInt64RangePartitionSchemeOutput) ToUniformInt64RangePartitionSchemeOutput() UniformInt64RangePartitionSchemeOutput {
	return o
}

func (o UniformInt64RangePartitionSchemeOutput) ToUniformInt64RangePartitionSchemeOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemeOutput {
	return o
}

// The number of partitions.
func (o UniformInt64RangePartitionSchemeOutput) Count() pulumi.IntOutput {
	return o.ApplyT(func(v UniformInt64RangePartitionScheme) int { return v.Count }).(pulumi.IntOutput)
}

// The upper bound of the partition key range that
// should be split between the partition ‘Count’
func (o UniformInt64RangePartitionSchemeOutput) HighKey() pulumi.Float64Output {
	return o.ApplyT(func(v UniformInt64RangePartitionScheme) float64 { return v.HighKey }).(pulumi.Float64Output)
}

// The lower bound of the partition key range that
// should be split between the partition ‘Count’
func (o UniformInt64RangePartitionSchemeOutput) LowKey() pulumi.Float64Output {
	return o.ApplyT(func(v UniformInt64RangePartitionScheme) float64 { return v.LowKey }).(pulumi.Float64Output)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'UniformInt64Range'.
func (o UniformInt64RangePartitionSchemeOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v UniformInt64RangePartitionScheme) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeResponse struct {
	// The number of partitions.
	Count int `pulumi:"count"`
	// The upper bound of the partition key range that
	// should be split between the partition ‘Count’
	HighKey float64 `pulumi:"highKey"`
	// The lower bound of the partition key range that
	// should be split between the partition ‘Count’
	LowKey float64 `pulumi:"lowKey"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'UniformInt64Range'.
	PartitionScheme string `pulumi:"partitionScheme"`
}

// UniformInt64RangePartitionSchemeResponseInput is an input type that accepts UniformInt64RangePartitionSchemeResponseArgs and UniformInt64RangePartitionSchemeResponseOutput values.
// You can construct a concrete instance of `UniformInt64RangePartitionSchemeResponseInput` via:
//
//          UniformInt64RangePartitionSchemeResponseArgs{...}
type UniformInt64RangePartitionSchemeResponseInput interface {
	pulumi.Input

	ToUniformInt64RangePartitionSchemeResponseOutput() UniformInt64RangePartitionSchemeResponseOutput
	ToUniformInt64RangePartitionSchemeResponseOutputWithContext(context.Context) UniformInt64RangePartitionSchemeResponseOutput
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeResponseArgs struct {
	// The number of partitions.
	Count pulumi.IntInput `pulumi:"count"`
	// The upper bound of the partition key range that
	// should be split between the partition ‘Count’
	HighKey pulumi.Float64Input `pulumi:"highKey"`
	// The lower bound of the partition key range that
	// should be split between the partition ‘Count’
	LowKey pulumi.Float64Input `pulumi:"lowKey"`
	// Enumerates the ways that a service can be partitioned.
	// Expected value is 'UniformInt64Range'.
	PartitionScheme pulumi.StringInput `pulumi:"partitionScheme"`
}

func (UniformInt64RangePartitionSchemeResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UniformInt64RangePartitionSchemeResponse)(nil)).Elem()
}

func (i UniformInt64RangePartitionSchemeResponseArgs) ToUniformInt64RangePartitionSchemeResponseOutput() UniformInt64RangePartitionSchemeResponseOutput {
	return i.ToUniformInt64RangePartitionSchemeResponseOutputWithContext(context.Background())
}

func (i UniformInt64RangePartitionSchemeResponseArgs) ToUniformInt64RangePartitionSchemeResponseOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemeResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UniformInt64RangePartitionSchemeResponseOutput)
}

// Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
type UniformInt64RangePartitionSchemeResponseOutput struct{ *pulumi.OutputState }

func (UniformInt64RangePartitionSchemeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UniformInt64RangePartitionSchemeResponse)(nil)).Elem()
}

func (o UniformInt64RangePartitionSchemeResponseOutput) ToUniformInt64RangePartitionSchemeResponseOutput() UniformInt64RangePartitionSchemeResponseOutput {
	return o
}

func (o UniformInt64RangePartitionSchemeResponseOutput) ToUniformInt64RangePartitionSchemeResponseOutputWithContext(ctx context.Context) UniformInt64RangePartitionSchemeResponseOutput {
	return o
}

// The number of partitions.
func (o UniformInt64RangePartitionSchemeResponseOutput) Count() pulumi.IntOutput {
	return o.ApplyT(func(v UniformInt64RangePartitionSchemeResponse) int { return v.Count }).(pulumi.IntOutput)
}

// The upper bound of the partition key range that
// should be split between the partition ‘Count’
func (o UniformInt64RangePartitionSchemeResponseOutput) HighKey() pulumi.Float64Output {
	return o.ApplyT(func(v UniformInt64RangePartitionSchemeResponse) float64 { return v.HighKey }).(pulumi.Float64Output)
}

// The lower bound of the partition key range that
// should be split between the partition ‘Count’
func (o UniformInt64RangePartitionSchemeResponseOutput) LowKey() pulumi.Float64Output {
	return o.ApplyT(func(v UniformInt64RangePartitionSchemeResponse) float64 { return v.LowKey }).(pulumi.Float64Output)
}

// Enumerates the ways that a service can be partitioned.
// Expected value is 'UniformInt64Range'.
func (o UniformInt64RangePartitionSchemeResponseOutput) PartitionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v UniformInt64RangePartitionSchemeResponse) string { return v.PartitionScheme }).(pulumi.StringOutput)
}

type UserAssignedIdentityResponse struct {
	// The client id of user assigned identity.
	ClientId string `pulumi:"clientId"`
	// The principal id of user assigned identity.
	PrincipalId string `pulumi:"principalId"`
}

// UserAssignedIdentityResponseInput is an input type that accepts UserAssignedIdentityResponseArgs and UserAssignedIdentityResponseOutput values.
// You can construct a concrete instance of `UserAssignedIdentityResponseInput` via:
//
//          UserAssignedIdentityResponseArgs{...}
type UserAssignedIdentityResponseInput interface {
	pulumi.Input

	ToUserAssignedIdentityResponseOutput() UserAssignedIdentityResponseOutput
	ToUserAssignedIdentityResponseOutputWithContext(context.Context) UserAssignedIdentityResponseOutput
}

type UserAssignedIdentityResponseArgs struct {
	// The client id of user assigned identity.
	ClientId pulumi.StringInput `pulumi:"clientId"`
	// The principal id of user assigned identity.
	PrincipalId pulumi.StringInput `pulumi:"principalId"`
}

func (UserAssignedIdentityResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserAssignedIdentityResponse)(nil)).Elem()
}

func (i UserAssignedIdentityResponseArgs) ToUserAssignedIdentityResponseOutput() UserAssignedIdentityResponseOutput {
	return i.ToUserAssignedIdentityResponseOutputWithContext(context.Background())
}

func (i UserAssignedIdentityResponseArgs) ToUserAssignedIdentityResponseOutputWithContext(ctx context.Context) UserAssignedIdentityResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserAssignedIdentityResponseOutput)
}

// UserAssignedIdentityResponseMapInput is an input type that accepts UserAssignedIdentityResponseMap and UserAssignedIdentityResponseMapOutput values.
// You can construct a concrete instance of `UserAssignedIdentityResponseMapInput` via:
//
//          UserAssignedIdentityResponseMap{ "key": UserAssignedIdentityResponseArgs{...} }
type UserAssignedIdentityResponseMapInput interface {
	pulumi.Input

	ToUserAssignedIdentityResponseMapOutput() UserAssignedIdentityResponseMapOutput
	ToUserAssignedIdentityResponseMapOutputWithContext(context.Context) UserAssignedIdentityResponseMapOutput
}

type UserAssignedIdentityResponseMap map[string]UserAssignedIdentityResponseInput

func (UserAssignedIdentityResponseMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]UserAssignedIdentityResponse)(nil)).Elem()
}

func (i UserAssignedIdentityResponseMap) ToUserAssignedIdentityResponseMapOutput() UserAssignedIdentityResponseMapOutput {
	return i.ToUserAssignedIdentityResponseMapOutputWithContext(context.Background())
}

func (i UserAssignedIdentityResponseMap) ToUserAssignedIdentityResponseMapOutputWithContext(ctx context.Context) UserAssignedIdentityResponseMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserAssignedIdentityResponseMapOutput)
}

type UserAssignedIdentityResponseOutput struct{ *pulumi.OutputState }

func (UserAssignedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserAssignedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedIdentityResponseOutput) ToUserAssignedIdentityResponseOutput() UserAssignedIdentityResponseOutput {
	return o
}

func (o UserAssignedIdentityResponseOutput) ToUserAssignedIdentityResponseOutputWithContext(ctx context.Context) UserAssignedIdentityResponseOutput {
	return o
}

// The client id of user assigned identity.
func (o UserAssignedIdentityResponseOutput) ClientId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedIdentityResponse) string { return v.ClientId }).(pulumi.StringOutput)
}

// The principal id of user assigned identity.
func (o UserAssignedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type UserAssignedIdentityResponseMapOutput struct{ *pulumi.OutputState }

func (UserAssignedIdentityResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]UserAssignedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedIdentityResponseMapOutput) ToUserAssignedIdentityResponseMapOutput() UserAssignedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedIdentityResponseMapOutput) ToUserAssignedIdentityResponseMapOutputWithContext(ctx context.Context) UserAssignedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedIdentityResponseMapOutput) MapIndex(k pulumi.StringInput) UserAssignedIdentityResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) UserAssignedIdentityResponse {
		return vs[0].(map[string]UserAssignedIdentityResponse)[vs[1].(string)]
	}).(UserAssignedIdentityResponseOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtension struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion *bool `pulumi:"autoUpgradeMinorVersion"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name string `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings interface{} `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `pulumi:"provisionAfterExtensions"`
	// The name of the extension handler publisher.
	Publisher string `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings interface{} `pulumi:"settings"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type string `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion string `pulumi:"typeHandlerVersion"`
}

// VMSSExtensionInput is an input type that accepts VMSSExtensionArgs and VMSSExtensionOutput values.
// You can construct a concrete instance of `VMSSExtensionInput` via:
//
//          VMSSExtensionArgs{...}
type VMSSExtensionInput interface {
	pulumi.Input

	ToVMSSExtensionOutput() VMSSExtensionOutput
	ToVMSSExtensionOutputWithContext(context.Context) VMSSExtensionOutput
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionArgs struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion pulumi.BoolPtrInput `pulumi:"autoUpgradeMinorVersion"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag pulumi.StringPtrInput `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name pulumi.StringInput `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings pulumi.Input `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions pulumi.StringArrayInput `pulumi:"provisionAfterExtensions"`
	// The name of the extension handler publisher.
	Publisher pulumi.StringInput `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings pulumi.Input `pulumi:"settings"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type pulumi.StringInput `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion pulumi.StringInput `pulumi:"typeHandlerVersion"`
}

func (VMSSExtensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtension)(nil)).Elem()
}

func (i VMSSExtensionArgs) ToVMSSExtensionOutput() VMSSExtensionOutput {
	return i.ToVMSSExtensionOutputWithContext(context.Background())
}

func (i VMSSExtensionArgs) ToVMSSExtensionOutputWithContext(ctx context.Context) VMSSExtensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMSSExtensionOutput)
}

// VMSSExtensionArrayInput is an input type that accepts VMSSExtensionArray and VMSSExtensionArrayOutput values.
// You can construct a concrete instance of `VMSSExtensionArrayInput` via:
//
//          VMSSExtensionArray{ VMSSExtensionArgs{...} }
type VMSSExtensionArrayInput interface {
	pulumi.Input

	ToVMSSExtensionArrayOutput() VMSSExtensionArrayOutput
	ToVMSSExtensionArrayOutputWithContext(context.Context) VMSSExtensionArrayOutput
}

type VMSSExtensionArray []VMSSExtensionInput

func (VMSSExtensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtension)(nil)).Elem()
}

func (i VMSSExtensionArray) ToVMSSExtensionArrayOutput() VMSSExtensionArrayOutput {
	return i.ToVMSSExtensionArrayOutputWithContext(context.Background())
}

func (i VMSSExtensionArray) ToVMSSExtensionArrayOutputWithContext(ctx context.Context) VMSSExtensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMSSExtensionArrayOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionOutput struct{ *pulumi.OutputState }

func (VMSSExtensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtension)(nil)).Elem()
}

func (o VMSSExtensionOutput) ToVMSSExtensionOutput() VMSSExtensionOutput {
	return o
}

func (o VMSSExtensionOutput) ToVMSSExtensionOutputWithContext(ctx context.Context) VMSSExtensionOutput {
	return o
}

// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
func (o VMSSExtensionOutput) AutoUpgradeMinorVersion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtension) *bool { return v.AutoUpgradeMinorVersion }).(pulumi.BoolPtrOutput)
}

// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
func (o VMSSExtensionOutput) ForceUpdateTag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMSSExtension) *string { return v.ForceUpdateTag }).(pulumi.StringPtrOutput)
}

// The name of the extension.
func (o VMSSExtensionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.Name }).(pulumi.StringOutput)
}

// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
func (o VMSSExtensionOutput) ProtectedSettings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtension) interface{} { return v.ProtectedSettings }).(pulumi.AnyOutput)
}

// Collection of extension names after which this extension needs to be provisioned.
func (o VMSSExtensionOutput) ProvisionAfterExtensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMSSExtension) []string { return v.ProvisionAfterExtensions }).(pulumi.StringArrayOutput)
}

// The name of the extension handler publisher.
func (o VMSSExtensionOutput) Publisher() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.Publisher }).(pulumi.StringOutput)
}

// Json formatted public settings for the extension.
func (o VMSSExtensionOutput) Settings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtension) interface{} { return v.Settings }).(pulumi.AnyOutput)
}

// Specifies the type of the extension; an example is "CustomScriptExtension".
func (o VMSSExtensionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.Type }).(pulumi.StringOutput)
}

// Specifies the version of the script handler.
func (o VMSSExtensionOutput) TypeHandlerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtension) string { return v.TypeHandlerVersion }).(pulumi.StringOutput)
}

type VMSSExtensionArrayOutput struct{ *pulumi.OutputState }

func (VMSSExtensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtension)(nil)).Elem()
}

func (o VMSSExtensionArrayOutput) ToVMSSExtensionArrayOutput() VMSSExtensionArrayOutput {
	return o
}

func (o VMSSExtensionArrayOutput) ToVMSSExtensionArrayOutputWithContext(ctx context.Context) VMSSExtensionArrayOutput {
	return o
}

func (o VMSSExtensionArrayOutput) Index(i pulumi.IntInput) VMSSExtensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMSSExtension {
		return vs[0].([]VMSSExtension)[vs[1].(int)]
	}).(VMSSExtensionOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionResponse struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion *bool `pulumi:"autoUpgradeMinorVersion"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name string `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings interface{} `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `pulumi:"provisionAfterExtensions"`
	// The provisioning state, which only appears in the response.
	ProvisioningState string `pulumi:"provisioningState"`
	// The name of the extension handler publisher.
	Publisher string `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings interface{} `pulumi:"settings"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type string `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion string `pulumi:"typeHandlerVersion"`
}

// VMSSExtensionResponseInput is an input type that accepts VMSSExtensionResponseArgs and VMSSExtensionResponseOutput values.
// You can construct a concrete instance of `VMSSExtensionResponseInput` via:
//
//          VMSSExtensionResponseArgs{...}
type VMSSExtensionResponseInput interface {
	pulumi.Input

	ToVMSSExtensionResponseOutput() VMSSExtensionResponseOutput
	ToVMSSExtensionResponseOutputWithContext(context.Context) VMSSExtensionResponseOutput
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionResponseArgs struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion pulumi.BoolPtrInput `pulumi:"autoUpgradeMinorVersion"`
	// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
	ForceUpdateTag pulumi.StringPtrInput `pulumi:"forceUpdateTag"`
	// The name of the extension.
	Name pulumi.StringInput `pulumi:"name"`
	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings pulumi.Input `pulumi:"protectedSettings"`
	// Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions pulumi.StringArrayInput `pulumi:"provisionAfterExtensions"`
	// The provisioning state, which only appears in the response.
	ProvisioningState pulumi.StringInput `pulumi:"provisioningState"`
	// The name of the extension handler publisher.
	Publisher pulumi.StringInput `pulumi:"publisher"`
	// Json formatted public settings for the extension.
	Settings pulumi.Input `pulumi:"settings"`
	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type pulumi.StringInput `pulumi:"type"`
	// Specifies the version of the script handler.
	TypeHandlerVersion pulumi.StringInput `pulumi:"typeHandlerVersion"`
}

func (VMSSExtensionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtensionResponse)(nil)).Elem()
}

func (i VMSSExtensionResponseArgs) ToVMSSExtensionResponseOutput() VMSSExtensionResponseOutput {
	return i.ToVMSSExtensionResponseOutputWithContext(context.Background())
}

func (i VMSSExtensionResponseArgs) ToVMSSExtensionResponseOutputWithContext(ctx context.Context) VMSSExtensionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMSSExtensionResponseOutput)
}

// VMSSExtensionResponseArrayInput is an input type that accepts VMSSExtensionResponseArray and VMSSExtensionResponseArrayOutput values.
// You can construct a concrete instance of `VMSSExtensionResponseArrayInput` via:
//
//          VMSSExtensionResponseArray{ VMSSExtensionResponseArgs{...} }
type VMSSExtensionResponseArrayInput interface {
	pulumi.Input

	ToVMSSExtensionResponseArrayOutput() VMSSExtensionResponseArrayOutput
	ToVMSSExtensionResponseArrayOutputWithContext(context.Context) VMSSExtensionResponseArrayOutput
}

type VMSSExtensionResponseArray []VMSSExtensionResponseInput

func (VMSSExtensionResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtensionResponse)(nil)).Elem()
}

func (i VMSSExtensionResponseArray) ToVMSSExtensionResponseArrayOutput() VMSSExtensionResponseArrayOutput {
	return i.ToVMSSExtensionResponseArrayOutputWithContext(context.Background())
}

func (i VMSSExtensionResponseArray) ToVMSSExtensionResponseArrayOutputWithContext(ctx context.Context) VMSSExtensionResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMSSExtensionResponseArrayOutput)
}

// Specifies set of extensions that should be installed onto the virtual machines.
type VMSSExtensionResponseOutput struct{ *pulumi.OutputState }

func (VMSSExtensionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMSSExtensionResponse)(nil)).Elem()
}

func (o VMSSExtensionResponseOutput) ToVMSSExtensionResponseOutput() VMSSExtensionResponseOutput {
	return o
}

func (o VMSSExtensionResponseOutput) ToVMSSExtensionResponseOutputWithContext(ctx context.Context) VMSSExtensionResponseOutput {
	return o
}

// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
func (o VMSSExtensionResponseOutput) AutoUpgradeMinorVersion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) *bool { return v.AutoUpgradeMinorVersion }).(pulumi.BoolPtrOutput)
}

// If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
func (o VMSSExtensionResponseOutput) ForceUpdateTag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) *string { return v.ForceUpdateTag }).(pulumi.StringPtrOutput)
}

// The name of the extension.
func (o VMSSExtensionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
func (o VMSSExtensionResponseOutput) ProtectedSettings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) interface{} { return v.ProtectedSettings }).(pulumi.AnyOutput)
}

// Collection of extension names after which this extension needs to be provisioned.
func (o VMSSExtensionResponseOutput) ProvisionAfterExtensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) []string { return v.ProvisionAfterExtensions }).(pulumi.StringArrayOutput)
}

// The provisioning state, which only appears in the response.
func (o VMSSExtensionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// The name of the extension handler publisher.
func (o VMSSExtensionResponseOutput) Publisher() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.Publisher }).(pulumi.StringOutput)
}

// Json formatted public settings for the extension.
func (o VMSSExtensionResponseOutput) Settings() pulumi.AnyOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) interface{} { return v.Settings }).(pulumi.AnyOutput)
}

// Specifies the type of the extension; an example is "CustomScriptExtension".
func (o VMSSExtensionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Specifies the version of the script handler.
func (o VMSSExtensionResponseOutput) TypeHandlerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v VMSSExtensionResponse) string { return v.TypeHandlerVersion }).(pulumi.StringOutput)
}

type VMSSExtensionResponseArrayOutput struct{ *pulumi.OutputState }

func (VMSSExtensionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMSSExtensionResponse)(nil)).Elem()
}

func (o VMSSExtensionResponseArrayOutput) ToVMSSExtensionResponseArrayOutput() VMSSExtensionResponseArrayOutput {
	return o
}

func (o VMSSExtensionResponseArrayOutput) ToVMSSExtensionResponseArrayOutputWithContext(ctx context.Context) VMSSExtensionResponseArrayOutput {
	return o
}

func (o VMSSExtensionResponseArrayOutput) Index(i pulumi.IntInput) VMSSExtensionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMSSExtensionResponse {
		return vs[0].([]VMSSExtensionResponse)[vs[1].(int)]
	}).(VMSSExtensionResponseOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificate struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore string `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
	CertificateUrl string `pulumi:"certificateUrl"`
}

// VaultCertificateInput is an input type that accepts VaultCertificateArgs and VaultCertificateOutput values.
// You can construct a concrete instance of `VaultCertificateInput` via:
//
//          VaultCertificateArgs{...}
type VaultCertificateInput interface {
	pulumi.Input

	ToVaultCertificateOutput() VaultCertificateOutput
	ToVaultCertificateOutputWithContext(context.Context) VaultCertificateOutput
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateArgs struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore pulumi.StringInput `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
	CertificateUrl pulumi.StringInput `pulumi:"certificateUrl"`
}

func (VaultCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificate)(nil)).Elem()
}

func (i VaultCertificateArgs) ToVaultCertificateOutput() VaultCertificateOutput {
	return i.ToVaultCertificateOutputWithContext(context.Background())
}

func (i VaultCertificateArgs) ToVaultCertificateOutputWithContext(ctx context.Context) VaultCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultCertificateOutput)
}

// VaultCertificateArrayInput is an input type that accepts VaultCertificateArray and VaultCertificateArrayOutput values.
// You can construct a concrete instance of `VaultCertificateArrayInput` via:
//
//          VaultCertificateArray{ VaultCertificateArgs{...} }
type VaultCertificateArrayInput interface {
	pulumi.Input

	ToVaultCertificateArrayOutput() VaultCertificateArrayOutput
	ToVaultCertificateArrayOutputWithContext(context.Context) VaultCertificateArrayOutput
}

type VaultCertificateArray []VaultCertificateInput

func (VaultCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificate)(nil)).Elem()
}

func (i VaultCertificateArray) ToVaultCertificateArrayOutput() VaultCertificateArrayOutput {
	return i.ToVaultCertificateArrayOutputWithContext(context.Background())
}

func (i VaultCertificateArray) ToVaultCertificateArrayOutputWithContext(ctx context.Context) VaultCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultCertificateArrayOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateOutput struct{ *pulumi.OutputState }

func (VaultCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificate)(nil)).Elem()
}

func (o VaultCertificateOutput) ToVaultCertificateOutput() VaultCertificateOutput {
	return o
}

func (o VaultCertificateOutput) ToVaultCertificateOutputWithContext(ctx context.Context) VaultCertificateOutput {
	return o
}

// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
func (o VaultCertificateOutput) CertificateStore() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificate) string { return v.CertificateStore }).(pulumi.StringOutput)
}

// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
func (o VaultCertificateOutput) CertificateUrl() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificate) string { return v.CertificateUrl }).(pulumi.StringOutput)
}

type VaultCertificateArrayOutput struct{ *pulumi.OutputState }

func (VaultCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificate)(nil)).Elem()
}

func (o VaultCertificateArrayOutput) ToVaultCertificateArrayOutput() VaultCertificateArrayOutput {
	return o
}

func (o VaultCertificateArrayOutput) ToVaultCertificateArrayOutputWithContext(ctx context.Context) VaultCertificateArrayOutput {
	return o
}

func (o VaultCertificateArrayOutput) Index(i pulumi.IntInput) VaultCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultCertificate {
		return vs[0].([]VaultCertificate)[vs[1].(int)]
	}).(VaultCertificateOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateResponse struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore string `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
	CertificateUrl string `pulumi:"certificateUrl"`
}

// VaultCertificateResponseInput is an input type that accepts VaultCertificateResponseArgs and VaultCertificateResponseOutput values.
// You can construct a concrete instance of `VaultCertificateResponseInput` via:
//
//          VaultCertificateResponseArgs{...}
type VaultCertificateResponseInput interface {
	pulumi.Input

	ToVaultCertificateResponseOutput() VaultCertificateResponseOutput
	ToVaultCertificateResponseOutputWithContext(context.Context) VaultCertificateResponseOutput
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateResponseArgs struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
	CertificateStore pulumi.StringInput `pulumi:"certificateStore"`
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
	CertificateUrl pulumi.StringInput `pulumi:"certificateUrl"`
}

func (VaultCertificateResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificateResponse)(nil)).Elem()
}

func (i VaultCertificateResponseArgs) ToVaultCertificateResponseOutput() VaultCertificateResponseOutput {
	return i.ToVaultCertificateResponseOutputWithContext(context.Background())
}

func (i VaultCertificateResponseArgs) ToVaultCertificateResponseOutputWithContext(ctx context.Context) VaultCertificateResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultCertificateResponseOutput)
}

// VaultCertificateResponseArrayInput is an input type that accepts VaultCertificateResponseArray and VaultCertificateResponseArrayOutput values.
// You can construct a concrete instance of `VaultCertificateResponseArrayInput` via:
//
//          VaultCertificateResponseArray{ VaultCertificateResponseArgs{...} }
type VaultCertificateResponseArrayInput interface {
	pulumi.Input

	ToVaultCertificateResponseArrayOutput() VaultCertificateResponseArrayOutput
	ToVaultCertificateResponseArrayOutputWithContext(context.Context) VaultCertificateResponseArrayOutput
}

type VaultCertificateResponseArray []VaultCertificateResponseInput

func (VaultCertificateResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificateResponse)(nil)).Elem()
}

func (i VaultCertificateResponseArray) ToVaultCertificateResponseArrayOutput() VaultCertificateResponseArrayOutput {
	return i.ToVaultCertificateResponseArrayOutputWithContext(context.Background())
}

func (i VaultCertificateResponseArray) ToVaultCertificateResponseArrayOutputWithContext(ctx context.Context) VaultCertificateResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultCertificateResponseArrayOutput)
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificateResponseOutput struct{ *pulumi.OutputState }

func (VaultCertificateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultCertificateResponse)(nil)).Elem()
}

func (o VaultCertificateResponseOutput) ToVaultCertificateResponseOutput() VaultCertificateResponseOutput {
	return o
}

func (o VaultCertificateResponseOutput) ToVaultCertificateResponseOutputWithContext(ctx context.Context) VaultCertificateResponseOutput {
	return o
}

// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
func (o VaultCertificateResponseOutput) CertificateStore() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificateResponse) string { return v.CertificateStore }).(pulumi.StringOutput)
}

// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
func (o VaultCertificateResponseOutput) CertificateUrl() pulumi.StringOutput {
	return o.ApplyT(func(v VaultCertificateResponse) string { return v.CertificateUrl }).(pulumi.StringOutput)
}

type VaultCertificateResponseArrayOutput struct{ *pulumi.OutputState }

func (VaultCertificateResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultCertificateResponse)(nil)).Elem()
}

func (o VaultCertificateResponseArrayOutput) ToVaultCertificateResponseArrayOutput() VaultCertificateResponseArrayOutput {
	return o
}

func (o VaultCertificateResponseArrayOutput) ToVaultCertificateResponseArrayOutputWithContext(ctx context.Context) VaultCertificateResponseArrayOutput {
	return o
}

func (o VaultCertificateResponseArrayOutput) Index(i pulumi.IntInput) VaultCertificateResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultCertificateResponse {
		return vs[0].([]VaultCertificateResponse)[vs[1].(int)]
	}).(VaultCertificateResponseOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroup struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResource `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []VaultCertificate `pulumi:"vaultCertificates"`
}

// VaultSecretGroupInput is an input type that accepts VaultSecretGroupArgs and VaultSecretGroupOutput values.
// You can construct a concrete instance of `VaultSecretGroupInput` via:
//
//          VaultSecretGroupArgs{...}
type VaultSecretGroupInput interface {
	pulumi.Input

	ToVaultSecretGroupOutput() VaultSecretGroupOutput
	ToVaultSecretGroupOutputWithContext(context.Context) VaultSecretGroupOutput
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupArgs struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResourceInput `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates VaultCertificateArrayInput `pulumi:"vaultCertificates"`
}

func (VaultSecretGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroup)(nil)).Elem()
}

func (i VaultSecretGroupArgs) ToVaultSecretGroupOutput() VaultSecretGroupOutput {
	return i.ToVaultSecretGroupOutputWithContext(context.Background())
}

func (i VaultSecretGroupArgs) ToVaultSecretGroupOutputWithContext(ctx context.Context) VaultSecretGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultSecretGroupOutput)
}

// VaultSecretGroupArrayInput is an input type that accepts VaultSecretGroupArray and VaultSecretGroupArrayOutput values.
// You can construct a concrete instance of `VaultSecretGroupArrayInput` via:
//
//          VaultSecretGroupArray{ VaultSecretGroupArgs{...} }
type VaultSecretGroupArrayInput interface {
	pulumi.Input

	ToVaultSecretGroupArrayOutput() VaultSecretGroupArrayOutput
	ToVaultSecretGroupArrayOutputWithContext(context.Context) VaultSecretGroupArrayOutput
}

type VaultSecretGroupArray []VaultSecretGroupInput

func (VaultSecretGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroup)(nil)).Elem()
}

func (i VaultSecretGroupArray) ToVaultSecretGroupArrayOutput() VaultSecretGroupArrayOutput {
	return i.ToVaultSecretGroupArrayOutputWithContext(context.Background())
}

func (i VaultSecretGroupArray) ToVaultSecretGroupArrayOutputWithContext(ctx context.Context) VaultSecretGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultSecretGroupArrayOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroup)(nil)).Elem()
}

func (o VaultSecretGroupOutput) ToVaultSecretGroupOutput() VaultSecretGroupOutput {
	return o
}

func (o VaultSecretGroupOutput) ToVaultSecretGroupOutputWithContext(ctx context.Context) VaultSecretGroupOutput {
	return o
}

// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
func (o VaultSecretGroupOutput) SourceVault() SubResourceOutput {
	return o.ApplyT(func(v VaultSecretGroup) SubResource { return v.SourceVault }).(SubResourceOutput)
}

// The list of key vault references in SourceVault which contain certificates.
func (o VaultSecretGroupOutput) VaultCertificates() VaultCertificateArrayOutput {
	return o.ApplyT(func(v VaultSecretGroup) []VaultCertificate { return v.VaultCertificates }).(VaultCertificateArrayOutput)
}

type VaultSecretGroupArrayOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroup)(nil)).Elem()
}

func (o VaultSecretGroupArrayOutput) ToVaultSecretGroupArrayOutput() VaultSecretGroupArrayOutput {
	return o
}

func (o VaultSecretGroupArrayOutput) ToVaultSecretGroupArrayOutputWithContext(ctx context.Context) VaultSecretGroupArrayOutput {
	return o
}

func (o VaultSecretGroupArrayOutput) Index(i pulumi.IntInput) VaultSecretGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultSecretGroup {
		return vs[0].([]VaultSecretGroup)[vs[1].(int)]
	}).(VaultSecretGroupOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupResponse struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResourceResponse `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []VaultCertificateResponse `pulumi:"vaultCertificates"`
}

// VaultSecretGroupResponseInput is an input type that accepts VaultSecretGroupResponseArgs and VaultSecretGroupResponseOutput values.
// You can construct a concrete instance of `VaultSecretGroupResponseInput` via:
//
//          VaultSecretGroupResponseArgs{...}
type VaultSecretGroupResponseInput interface {
	pulumi.Input

	ToVaultSecretGroupResponseOutput() VaultSecretGroupResponseOutput
	ToVaultSecretGroupResponseOutputWithContext(context.Context) VaultSecretGroupResponseOutput
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupResponseArgs struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault SubResourceResponseInput `pulumi:"sourceVault"`
	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates VaultCertificateResponseArrayInput `pulumi:"vaultCertificates"`
}

func (VaultSecretGroupResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroupResponse)(nil)).Elem()
}

func (i VaultSecretGroupResponseArgs) ToVaultSecretGroupResponseOutput() VaultSecretGroupResponseOutput {
	return i.ToVaultSecretGroupResponseOutputWithContext(context.Background())
}

func (i VaultSecretGroupResponseArgs) ToVaultSecretGroupResponseOutputWithContext(ctx context.Context) VaultSecretGroupResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultSecretGroupResponseOutput)
}

// VaultSecretGroupResponseArrayInput is an input type that accepts VaultSecretGroupResponseArray and VaultSecretGroupResponseArrayOutput values.
// You can construct a concrete instance of `VaultSecretGroupResponseArrayInput` via:
//
//          VaultSecretGroupResponseArray{ VaultSecretGroupResponseArgs{...} }
type VaultSecretGroupResponseArrayInput interface {
	pulumi.Input

	ToVaultSecretGroupResponseArrayOutput() VaultSecretGroupResponseArrayOutput
	ToVaultSecretGroupResponseArrayOutputWithContext(context.Context) VaultSecretGroupResponseArrayOutput
}

type VaultSecretGroupResponseArray []VaultSecretGroupResponseInput

func (VaultSecretGroupResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroupResponse)(nil)).Elem()
}

func (i VaultSecretGroupResponseArray) ToVaultSecretGroupResponseArrayOutput() VaultSecretGroupResponseArrayOutput {
	return i.ToVaultSecretGroupResponseArrayOutputWithContext(context.Background())
}

func (i VaultSecretGroupResponseArray) ToVaultSecretGroupResponseArrayOutputWithContext(ctx context.Context) VaultSecretGroupResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VaultSecretGroupResponseArrayOutput)
}

// Specifies set of certificates that should be installed onto the virtual machines.
type VaultSecretGroupResponseOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VaultSecretGroupResponse)(nil)).Elem()
}

func (o VaultSecretGroupResponseOutput) ToVaultSecretGroupResponseOutput() VaultSecretGroupResponseOutput {
	return o
}

func (o VaultSecretGroupResponseOutput) ToVaultSecretGroupResponseOutputWithContext(ctx context.Context) VaultSecretGroupResponseOutput {
	return o
}

// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
func (o VaultSecretGroupResponseOutput) SourceVault() SubResourceResponseOutput {
	return o.ApplyT(func(v VaultSecretGroupResponse) SubResourceResponse { return v.SourceVault }).(SubResourceResponseOutput)
}

// The list of key vault references in SourceVault which contain certificates.
func (o VaultSecretGroupResponseOutput) VaultCertificates() VaultCertificateResponseArrayOutput {
	return o.ApplyT(func(v VaultSecretGroupResponse) []VaultCertificateResponse { return v.VaultCertificates }).(VaultCertificateResponseArrayOutput)
}

type VaultSecretGroupResponseArrayOutput struct{ *pulumi.OutputState }

func (VaultSecretGroupResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VaultSecretGroupResponse)(nil)).Elem()
}

func (o VaultSecretGroupResponseArrayOutput) ToVaultSecretGroupResponseArrayOutput() VaultSecretGroupResponseArrayOutput {
	return o
}

func (o VaultSecretGroupResponseArrayOutput) ToVaultSecretGroupResponseArrayOutputWithContext(ctx context.Context) VaultSecretGroupResponseArrayOutput {
	return o
}

func (o VaultSecretGroupResponseArrayOutput) Index(i pulumi.IntInput) VaultSecretGroupResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VaultSecretGroupResponse {
		return vs[0].([]VaultSecretGroupResponse)[vs[1].(int)]
	}).(VaultSecretGroupResponseOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentity struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []string `pulumi:"userAssignedIdentities"`
}

// VmManagedIdentityInput is an input type that accepts VmManagedIdentityArgs and VmManagedIdentityOutput values.
// You can construct a concrete instance of `VmManagedIdentityInput` via:
//
//          VmManagedIdentityArgs{...}
type VmManagedIdentityInput interface {
	pulumi.Input

	ToVmManagedIdentityOutput() VmManagedIdentityOutput
	ToVmManagedIdentityOutputWithContext(context.Context) VmManagedIdentityOutput
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityArgs struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities pulumi.StringArrayInput `pulumi:"userAssignedIdentities"`
}

func (VmManagedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentity)(nil)).Elem()
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityOutput() VmManagedIdentityOutput {
	return i.ToVmManagedIdentityOutputWithContext(context.Background())
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityOutputWithContext(ctx context.Context) VmManagedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityOutput)
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return i.ToVmManagedIdentityPtrOutputWithContext(context.Background())
}

func (i VmManagedIdentityArgs) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityOutput).ToVmManagedIdentityPtrOutputWithContext(ctx)
}

// VmManagedIdentityPtrInput is an input type that accepts VmManagedIdentityArgs, VmManagedIdentityPtr and VmManagedIdentityPtrOutput values.
// You can construct a concrete instance of `VmManagedIdentityPtrInput` via:
//
//          VmManagedIdentityArgs{...}
//
//  or:
//
//          nil
type VmManagedIdentityPtrInput interface {
	pulumi.Input

	ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput
	ToVmManagedIdentityPtrOutputWithContext(context.Context) VmManagedIdentityPtrOutput
}

type vmManagedIdentityPtrType VmManagedIdentityArgs

func VmManagedIdentityPtr(v *VmManagedIdentityArgs) VmManagedIdentityPtrInput {
	return (*vmManagedIdentityPtrType)(v)
}

func (*vmManagedIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentity)(nil)).Elem()
}

func (i *vmManagedIdentityPtrType) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return i.ToVmManagedIdentityPtrOutputWithContext(context.Background())
}

func (i *vmManagedIdentityPtrType) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityPtrOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentity)(nil)).Elem()
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityOutput() VmManagedIdentityOutput {
	return o
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityOutputWithContext(ctx context.Context) VmManagedIdentityOutput {
	return o
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return o.ToVmManagedIdentityPtrOutputWithContext(context.Background())
}

func (o VmManagedIdentityOutput) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return o.ApplyT(func(v VmManagedIdentity) *VmManagedIdentity {
		return &v
	}).(VmManagedIdentityPtrOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmManagedIdentity) []string { return v.UserAssignedIdentities }).(pulumi.StringArrayOutput)
}

type VmManagedIdentityPtrOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentity)(nil)).Elem()
}

func (o VmManagedIdentityPtrOutput) ToVmManagedIdentityPtrOutput() VmManagedIdentityPtrOutput {
	return o
}

func (o VmManagedIdentityPtrOutput) ToVmManagedIdentityPtrOutputWithContext(ctx context.Context) VmManagedIdentityPtrOutput {
	return o
}

func (o VmManagedIdentityPtrOutput) Elem() VmManagedIdentityOutput {
	return o.ApplyT(func(v *VmManagedIdentity) VmManagedIdentity { return *v }).(VmManagedIdentityOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityPtrOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VmManagedIdentity) []string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.StringArrayOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityResponse struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []string `pulumi:"userAssignedIdentities"`
}

// VmManagedIdentityResponseInput is an input type that accepts VmManagedIdentityResponseArgs and VmManagedIdentityResponseOutput values.
// You can construct a concrete instance of `VmManagedIdentityResponseInput` via:
//
//          VmManagedIdentityResponseArgs{...}
type VmManagedIdentityResponseInput interface {
	pulumi.Input

	ToVmManagedIdentityResponseOutput() VmManagedIdentityResponseOutput
	ToVmManagedIdentityResponseOutputWithContext(context.Context) VmManagedIdentityResponseOutput
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityResponseArgs struct {
	// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities pulumi.StringArrayInput `pulumi:"userAssignedIdentities"`
}

func (VmManagedIdentityResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentityResponse)(nil)).Elem()
}

func (i VmManagedIdentityResponseArgs) ToVmManagedIdentityResponseOutput() VmManagedIdentityResponseOutput {
	return i.ToVmManagedIdentityResponseOutputWithContext(context.Background())
}

func (i VmManagedIdentityResponseArgs) ToVmManagedIdentityResponseOutputWithContext(ctx context.Context) VmManagedIdentityResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityResponseOutput)
}

func (i VmManagedIdentityResponseArgs) ToVmManagedIdentityResponsePtrOutput() VmManagedIdentityResponsePtrOutput {
	return i.ToVmManagedIdentityResponsePtrOutputWithContext(context.Background())
}

func (i VmManagedIdentityResponseArgs) ToVmManagedIdentityResponsePtrOutputWithContext(ctx context.Context) VmManagedIdentityResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityResponseOutput).ToVmManagedIdentityResponsePtrOutputWithContext(ctx)
}

// VmManagedIdentityResponsePtrInput is an input type that accepts VmManagedIdentityResponseArgs, VmManagedIdentityResponsePtr and VmManagedIdentityResponsePtrOutput values.
// You can construct a concrete instance of `VmManagedIdentityResponsePtrInput` via:
//
//          VmManagedIdentityResponseArgs{...}
//
//  or:
//
//          nil
type VmManagedIdentityResponsePtrInput interface {
	pulumi.Input

	ToVmManagedIdentityResponsePtrOutput() VmManagedIdentityResponsePtrOutput
	ToVmManagedIdentityResponsePtrOutputWithContext(context.Context) VmManagedIdentityResponsePtrOutput
}

type vmManagedIdentityResponsePtrType VmManagedIdentityResponseArgs

func VmManagedIdentityResponsePtr(v *VmManagedIdentityResponseArgs) VmManagedIdentityResponsePtrInput {
	return (*vmManagedIdentityResponsePtrType)(v)
}

func (*vmManagedIdentityResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentityResponse)(nil)).Elem()
}

func (i *vmManagedIdentityResponsePtrType) ToVmManagedIdentityResponsePtrOutput() VmManagedIdentityResponsePtrOutput {
	return i.ToVmManagedIdentityResponsePtrOutputWithContext(context.Background())
}

func (i *vmManagedIdentityResponsePtrType) ToVmManagedIdentityResponsePtrOutputWithContext(ctx context.Context) VmManagedIdentityResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmManagedIdentityResponsePtrOutput)
}

// Identities for the virtual machine scale set under the node type.
type VmManagedIdentityResponseOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmManagedIdentityResponse)(nil)).Elem()
}

func (o VmManagedIdentityResponseOutput) ToVmManagedIdentityResponseOutput() VmManagedIdentityResponseOutput {
	return o
}

func (o VmManagedIdentityResponseOutput) ToVmManagedIdentityResponseOutputWithContext(ctx context.Context) VmManagedIdentityResponseOutput {
	return o
}

func (o VmManagedIdentityResponseOutput) ToVmManagedIdentityResponsePtrOutput() VmManagedIdentityResponsePtrOutput {
	return o.ToVmManagedIdentityResponsePtrOutputWithContext(context.Background())
}

func (o VmManagedIdentityResponseOutput) ToVmManagedIdentityResponsePtrOutputWithContext(ctx context.Context) VmManagedIdentityResponsePtrOutput {
	return o.ApplyT(func(v VmManagedIdentityResponse) *VmManagedIdentityResponse {
		return &v
	}).(VmManagedIdentityResponsePtrOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityResponseOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmManagedIdentityResponse) []string { return v.UserAssignedIdentities }).(pulumi.StringArrayOutput)
}

type VmManagedIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (VmManagedIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmManagedIdentityResponse)(nil)).Elem()
}

func (o VmManagedIdentityResponsePtrOutput) ToVmManagedIdentityResponsePtrOutput() VmManagedIdentityResponsePtrOutput {
	return o
}

func (o VmManagedIdentityResponsePtrOutput) ToVmManagedIdentityResponsePtrOutputWithContext(ctx context.Context) VmManagedIdentityResponsePtrOutput {
	return o
}

func (o VmManagedIdentityResponsePtrOutput) Elem() VmManagedIdentityResponseOutput {
	return o.ApplyT(func(v *VmManagedIdentityResponse) VmManagedIdentityResponse { return *v }).(VmManagedIdentityResponseOutput)
}

// The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func (o VmManagedIdentityResponsePtrOutput) UserAssignedIdentities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VmManagedIdentityResponse) []string {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.StringArrayOutput)
}

func init() {
	pulumi.RegisterOutputType(AddRemoveIncrementalNamedPartitionScalingMechanismOutput{})
	pulumi.RegisterOutputType(AddRemoveIncrementalNamedPartitionScalingMechanismResponseOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyPtrOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyResponseOutput{})
	pulumi.RegisterOutputType(ApplicationHealthPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyPtrOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyResponseOutput{})
	pulumi.RegisterOutputType(ApplicationTypeVersionsCleanupPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyPtrOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyResponseOutput{})
	pulumi.RegisterOutputType(ApplicationUpgradePolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityArrayOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityResponseOutput{})
	pulumi.RegisterOutputType(ApplicationUserAssignedIdentityResponseArrayOutput{})
	pulumi.RegisterOutputType(AveragePartitionLoadScalingTriggerOutput{})
	pulumi.RegisterOutputType(AveragePartitionLoadScalingTriggerResponseOutput{})
	pulumi.RegisterOutputType(AverageServiceLoadScalingTriggerOutput{})
	pulumi.RegisterOutputType(AverageServiceLoadScalingTriggerResponseOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryPtrOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryResponseOutput{})
	pulumi.RegisterOutputType(AzureActiveDirectoryResponsePtrOutput{})
	pulumi.RegisterOutputType(ClientCertificateOutput{})
	pulumi.RegisterOutputType(ClientCertificateArrayOutput{})
	pulumi.RegisterOutputType(ClientCertificateResponseOutput{})
	pulumi.RegisterOutputType(ClientCertificateResponseArrayOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionPtrOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionResponseOutput{})
	pulumi.RegisterOutputType(EndpointRangeDescriptionResponsePtrOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationArrayOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationResponseOutput{})
	pulumi.RegisterOutputType(FrontendConfigurationResponseArrayOutput{})
	pulumi.RegisterOutputType(IPTagOutput{})
	pulumi.RegisterOutputType(IPTagArrayOutput{})
	pulumi.RegisterOutputType(IPTagResponseOutput{})
	pulumi.RegisterOutputType(IPTagResponseArrayOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleArrayOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleResponseOutput{})
	pulumi.RegisterOutputType(LoadBalancingRuleResponseArrayOutput{})
	pulumi.RegisterOutputType(ManagedIdentityOutput{})
	pulumi.RegisterOutputType(ManagedIdentityPtrOutput{})
	pulumi.RegisterOutputType(ManagedIdentityResponseOutput{})
	pulumi.RegisterOutputType(ManagedIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(NamedPartitionSchemeOutput{})
	pulumi.RegisterOutputType(NamedPartitionSchemeResponseOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleArrayOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleResponseOutput{})
	pulumi.RegisterOutputType(NetworkSecurityRuleResponseArrayOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuPtrOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuResponseOutput{})
	pulumi.RegisterOutputType(NodeTypeSkuResponsePtrOutput{})
	pulumi.RegisterOutputType(PartitionInstanceCountScaleMechanismOutput{})
	pulumi.RegisterOutputType(PartitionInstanceCountScaleMechanismResponseOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyPtrOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyResponseOutput{})
	pulumi.RegisterOutputType(RollingUpgradeMonitoringPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ScalingPolicyOutput{})
	pulumi.RegisterOutputType(ScalingPolicyArrayOutput{})
	pulumi.RegisterOutputType(ScalingPolicyResponseOutput{})
	pulumi.RegisterOutputType(ScalingPolicyResponseArrayOutput{})
	pulumi.RegisterOutputType(ServiceCorrelationOutput{})
	pulumi.RegisterOutputType(ServiceCorrelationArrayOutput{})
	pulumi.RegisterOutputType(ServiceCorrelationResponseOutput{})
	pulumi.RegisterOutputType(ServiceCorrelationResponseArrayOutput{})
	pulumi.RegisterOutputType(ServiceLoadMetricOutput{})
	pulumi.RegisterOutputType(ServiceLoadMetricArrayOutput{})
	pulumi.RegisterOutputType(ServiceLoadMetricResponseOutput{})
	pulumi.RegisterOutputType(ServiceLoadMetricResponseArrayOutput{})
	pulumi.RegisterOutputType(ServicePlacementInvalidDomainPolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementInvalidDomainPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServicePlacementNonPartiallyPlaceServicePolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementNonPartiallyPlaceServicePolicyResponseOutput{})
	pulumi.RegisterOutputType(ServicePlacementPreferPrimaryDomainPolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementPreferPrimaryDomainPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServicePlacementRequireDomainDistributionPolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementRequireDomainDistributionPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServicePlacementRequiredDomainPolicyOutput{})
	pulumi.RegisterOutputType(ServicePlacementRequiredDomainPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyPtrOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyMapOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyResponseOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(ServiceTypeHealthPolicyResponseMapOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionArrayOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionResponseOutput{})
	pulumi.RegisterOutputType(SettingsParameterDescriptionResponseArrayOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionArrayOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionResponseOutput{})
	pulumi.RegisterOutputType(SettingsSectionDescriptionResponseArrayOutput{})
	pulumi.RegisterOutputType(SingletonPartitionSchemeOutput{})
	pulumi.RegisterOutputType(SingletonPartitionSchemeResponseOutput{})
	pulumi.RegisterOutputType(SkuOutput{})
	pulumi.RegisterOutputType(SkuPtrOutput{})
	pulumi.RegisterOutputType(SkuResponseOutput{})
	pulumi.RegisterOutputType(SkuResponsePtrOutput{})
	pulumi.RegisterOutputType(StatefulServicePropertiesOutput{})
	pulumi.RegisterOutputType(StatefulServicePropertiesResponseOutput{})
	pulumi.RegisterOutputType(StatelessServicePropertiesOutput{})
	pulumi.RegisterOutputType(StatelessServicePropertiesResponseOutput{})
	pulumi.RegisterOutputType(SubResourceOutput{})
	pulumi.RegisterOutputType(SubResourceResponseOutput{})
	pulumi.RegisterOutputType(SystemDataResponseOutput{})
	pulumi.RegisterOutputType(SystemDataResponsePtrOutput{})
	pulumi.RegisterOutputType(UniformInt64RangePartitionSchemeOutput{})
	pulumi.RegisterOutputType(UniformInt64RangePartitionSchemeResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedIdentityResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedIdentityResponseMapOutput{})
	pulumi.RegisterOutputType(VMSSExtensionOutput{})
	pulumi.RegisterOutputType(VMSSExtensionArrayOutput{})
	pulumi.RegisterOutputType(VMSSExtensionResponseOutput{})
	pulumi.RegisterOutputType(VMSSExtensionResponseArrayOutput{})
	pulumi.RegisterOutputType(VaultCertificateOutput{})
	pulumi.RegisterOutputType(VaultCertificateArrayOutput{})
	pulumi.RegisterOutputType(VaultCertificateResponseOutput{})
	pulumi.RegisterOutputType(VaultCertificateResponseArrayOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupArrayOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupResponseOutput{})
	pulumi.RegisterOutputType(VaultSecretGroupResponseArrayOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityPtrOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityResponseOutput{})
	pulumi.RegisterOutputType(VmManagedIdentityResponsePtrOutput{})
}
