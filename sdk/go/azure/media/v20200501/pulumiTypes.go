// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v20200501

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudio struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AacAudio'.
	OdataType string `pulumi:"odataType"`
	// The encoding profile to be used when encoding audio with AAC.
	Profile *string `pulumi:"profile"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// Describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudioResponse struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AacAudio'.
	OdataType string `pulumi:"odataType"`
	// The encoding profile to be used when encoding audio with AAC.
	Profile *string `pulumi:"profile"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// Specifies the clip time as an absolute time position in the media file.  The absolute time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type AbsoluteClipTime struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AbsoluteClipTime'.
	OdataType string `pulumi:"odataType"`
	// The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
	Time string `pulumi:"time"`
}

// Specifies the clip time as an absolute time position in the media file.  The absolute time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type AbsoluteClipTimeResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AbsoluteClipTime'.
	OdataType string `pulumi:"odataType"`
	// The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
	Time string `pulumi:"time"`
}

type AccountEncryption struct {
	// The properties of the key used to encrypt the account.
	KeyVaultProperties *KeyVaultProperties `pulumi:"keyVaultProperties"`
	// The type of key used to encrypt the Account Key.
	Type string `pulumi:"type"`
}

// AccountEncryptionInput is an input type that accepts AccountEncryptionArgs and AccountEncryptionOutput values.
// You can construct a concrete instance of `AccountEncryptionInput` via:
//
//	AccountEncryptionArgs{...}
type AccountEncryptionInput interface {
	pulumi.Input

	ToAccountEncryptionOutput() AccountEncryptionOutput
	ToAccountEncryptionOutputWithContext(context.Context) AccountEncryptionOutput
}

type AccountEncryptionArgs struct {
	// The properties of the key used to encrypt the account.
	KeyVaultProperties KeyVaultPropertiesPtrInput `pulumi:"keyVaultProperties"`
	// The type of key used to encrypt the Account Key.
	Type pulumi.StringInput `pulumi:"type"`
}

func (AccountEncryptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AccountEncryption)(nil)).Elem()
}

func (i AccountEncryptionArgs) ToAccountEncryptionOutput() AccountEncryptionOutput {
	return i.ToAccountEncryptionOutputWithContext(context.Background())
}

func (i AccountEncryptionArgs) ToAccountEncryptionOutputWithContext(ctx context.Context) AccountEncryptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionOutput)
}

func (i AccountEncryptionArgs) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return i.ToAccountEncryptionPtrOutputWithContext(context.Background())
}

func (i AccountEncryptionArgs) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionOutput).ToAccountEncryptionPtrOutputWithContext(ctx)
}

// AccountEncryptionPtrInput is an input type that accepts AccountEncryptionArgs, AccountEncryptionPtr and AccountEncryptionPtrOutput values.
// You can construct a concrete instance of `AccountEncryptionPtrInput` via:
//
//	        AccountEncryptionArgs{...}
//
//	or:
//
//	        nil
type AccountEncryptionPtrInput interface {
	pulumi.Input

	ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput
	ToAccountEncryptionPtrOutputWithContext(context.Context) AccountEncryptionPtrOutput
}

type accountEncryptionPtrType AccountEncryptionArgs

func AccountEncryptionPtr(v *AccountEncryptionArgs) AccountEncryptionPtrInput {
	return (*accountEncryptionPtrType)(v)
}

func (*accountEncryptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryption)(nil)).Elem()
}

func (i *accountEncryptionPtrType) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return i.ToAccountEncryptionPtrOutputWithContext(context.Background())
}

func (i *accountEncryptionPtrType) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionPtrOutput)
}

type AccountEncryptionOutput struct{ *pulumi.OutputState }

func (AccountEncryptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccountEncryption)(nil)).Elem()
}

func (o AccountEncryptionOutput) ToAccountEncryptionOutput() AccountEncryptionOutput {
	return o
}

func (o AccountEncryptionOutput) ToAccountEncryptionOutputWithContext(ctx context.Context) AccountEncryptionOutput {
	return o
}

func (o AccountEncryptionOutput) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return o.ToAccountEncryptionPtrOutputWithContext(context.Background())
}

func (o AccountEncryptionOutput) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AccountEncryption) *AccountEncryption {
		return &v
	}).(AccountEncryptionPtrOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionOutput) KeyVaultProperties() KeyVaultPropertiesPtrOutput {
	return o.ApplyT(func(v AccountEncryption) *KeyVaultProperties { return v.KeyVaultProperties }).(KeyVaultPropertiesPtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AccountEncryption) string { return v.Type }).(pulumi.StringOutput)
}

type AccountEncryptionPtrOutput struct{ *pulumi.OutputState }

func (AccountEncryptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryption)(nil)).Elem()
}

func (o AccountEncryptionPtrOutput) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return o
}

func (o AccountEncryptionPtrOutput) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return o
}

func (o AccountEncryptionPtrOutput) Elem() AccountEncryptionOutput {
	return o.ApplyT(func(v *AccountEncryption) AccountEncryption {
		if v != nil {
			return *v
		}
		var ret AccountEncryption
		return ret
	}).(AccountEncryptionOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionPtrOutput) KeyVaultProperties() KeyVaultPropertiesPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) *KeyVaultProperties {
		if v == nil {
			return nil
		}
		return v.KeyVaultProperties
	}).(KeyVaultPropertiesPtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

type AccountEncryptionResponse struct {
	// The properties of the key used to encrypt the account.
	KeyVaultProperties *KeyVaultPropertiesResponse `pulumi:"keyVaultProperties"`
	// The type of key used to encrypt the Account Key.
	Type string `pulumi:"type"`
}

type AccountEncryptionResponseOutput struct{ *pulumi.OutputState }

func (AccountEncryptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccountEncryptionResponse)(nil)).Elem()
}

func (o AccountEncryptionResponseOutput) ToAccountEncryptionResponseOutput() AccountEncryptionResponseOutput {
	return o
}

func (o AccountEncryptionResponseOutput) ToAccountEncryptionResponseOutputWithContext(ctx context.Context) AccountEncryptionResponseOutput {
	return o
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionResponseOutput) KeyVaultProperties() KeyVaultPropertiesResponsePtrOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) *KeyVaultPropertiesResponse { return v.KeyVaultProperties }).(KeyVaultPropertiesResponsePtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) string { return v.Type }).(pulumi.StringOutput)
}

type AccountEncryptionResponsePtrOutput struct{ *pulumi.OutputState }

func (AccountEncryptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryptionResponse)(nil)).Elem()
}

func (o AccountEncryptionResponsePtrOutput) ToAccountEncryptionResponsePtrOutput() AccountEncryptionResponsePtrOutput {
	return o
}

func (o AccountEncryptionResponsePtrOutput) ToAccountEncryptionResponsePtrOutputWithContext(ctx context.Context) AccountEncryptionResponsePtrOutput {
	return o
}

func (o AccountEncryptionResponsePtrOutput) Elem() AccountEncryptionResponseOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) AccountEncryptionResponse {
		if v != nil {
			return *v
		}
		var ret AccountEncryptionResponse
		return ret
	}).(AccountEncryptionResponseOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionResponsePtrOutput) KeyVaultProperties() KeyVaultPropertiesResponsePtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *KeyVaultPropertiesResponse {
		if v == nil {
			return nil
		}
		return v.KeyVaultProperties
	}).(KeyVaultPropertiesResponsePtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// Akamai access control
type AkamaiAccessControl struct {
	// authentication key list
	AkamaiSignatureHeaderAuthenticationKeyList []AkamaiSignatureHeaderAuthenticationKey `pulumi:"akamaiSignatureHeaderAuthenticationKeyList"`
}

// AkamaiAccessControlInput is an input type that accepts AkamaiAccessControlArgs and AkamaiAccessControlOutput values.
// You can construct a concrete instance of `AkamaiAccessControlInput` via:
//
//	AkamaiAccessControlArgs{...}
type AkamaiAccessControlInput interface {
	pulumi.Input

	ToAkamaiAccessControlOutput() AkamaiAccessControlOutput
	ToAkamaiAccessControlOutputWithContext(context.Context) AkamaiAccessControlOutput
}

// Akamai access control
type AkamaiAccessControlArgs struct {
	// authentication key list
	AkamaiSignatureHeaderAuthenticationKeyList AkamaiSignatureHeaderAuthenticationKeyArrayInput `pulumi:"akamaiSignatureHeaderAuthenticationKeyList"`
}

func (AkamaiAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiAccessControl)(nil)).Elem()
}

func (i AkamaiAccessControlArgs) ToAkamaiAccessControlOutput() AkamaiAccessControlOutput {
	return i.ToAkamaiAccessControlOutputWithContext(context.Background())
}

func (i AkamaiAccessControlArgs) ToAkamaiAccessControlOutputWithContext(ctx context.Context) AkamaiAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiAccessControlOutput)
}

func (i AkamaiAccessControlArgs) ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput {
	return i.ToAkamaiAccessControlPtrOutputWithContext(context.Background())
}

func (i AkamaiAccessControlArgs) ToAkamaiAccessControlPtrOutputWithContext(ctx context.Context) AkamaiAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiAccessControlOutput).ToAkamaiAccessControlPtrOutputWithContext(ctx)
}

// AkamaiAccessControlPtrInput is an input type that accepts AkamaiAccessControlArgs, AkamaiAccessControlPtr and AkamaiAccessControlPtrOutput values.
// You can construct a concrete instance of `AkamaiAccessControlPtrInput` via:
//
//	        AkamaiAccessControlArgs{...}
//
//	or:
//
//	        nil
type AkamaiAccessControlPtrInput interface {
	pulumi.Input

	ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput
	ToAkamaiAccessControlPtrOutputWithContext(context.Context) AkamaiAccessControlPtrOutput
}

type akamaiAccessControlPtrType AkamaiAccessControlArgs

func AkamaiAccessControlPtr(v *AkamaiAccessControlArgs) AkamaiAccessControlPtrInput {
	return (*akamaiAccessControlPtrType)(v)
}

func (*akamaiAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AkamaiAccessControl)(nil)).Elem()
}

func (i *akamaiAccessControlPtrType) ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput {
	return i.ToAkamaiAccessControlPtrOutputWithContext(context.Background())
}

func (i *akamaiAccessControlPtrType) ToAkamaiAccessControlPtrOutputWithContext(ctx context.Context) AkamaiAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiAccessControlPtrOutput)
}

// Akamai access control
type AkamaiAccessControlOutput struct{ *pulumi.OutputState }

func (AkamaiAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiAccessControl)(nil)).Elem()
}

func (o AkamaiAccessControlOutput) ToAkamaiAccessControlOutput() AkamaiAccessControlOutput {
	return o
}

func (o AkamaiAccessControlOutput) ToAkamaiAccessControlOutputWithContext(ctx context.Context) AkamaiAccessControlOutput {
	return o
}

func (o AkamaiAccessControlOutput) ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput {
	return o.ToAkamaiAccessControlPtrOutputWithContext(context.Background())
}

func (o AkamaiAccessControlOutput) ToAkamaiAccessControlPtrOutputWithContext(ctx context.Context) AkamaiAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AkamaiAccessControl) *AkamaiAccessControl {
		return &v
	}).(AkamaiAccessControlPtrOutput)
}

// authentication key list
func (o AkamaiAccessControlOutput) AkamaiSignatureHeaderAuthenticationKeyList() AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o.ApplyT(func(v AkamaiAccessControl) []AkamaiSignatureHeaderAuthenticationKey {
		return v.AkamaiSignatureHeaderAuthenticationKeyList
	}).(AkamaiSignatureHeaderAuthenticationKeyArrayOutput)
}

type AkamaiAccessControlPtrOutput struct{ *pulumi.OutputState }

func (AkamaiAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AkamaiAccessControl)(nil)).Elem()
}

func (o AkamaiAccessControlPtrOutput) ToAkamaiAccessControlPtrOutput() AkamaiAccessControlPtrOutput {
	return o
}

func (o AkamaiAccessControlPtrOutput) ToAkamaiAccessControlPtrOutputWithContext(ctx context.Context) AkamaiAccessControlPtrOutput {
	return o
}

func (o AkamaiAccessControlPtrOutput) Elem() AkamaiAccessControlOutput {
	return o.ApplyT(func(v *AkamaiAccessControl) AkamaiAccessControl {
		if v != nil {
			return *v
		}
		var ret AkamaiAccessControl
		return ret
	}).(AkamaiAccessControlOutput)
}

// authentication key list
func (o AkamaiAccessControlPtrOutput) AkamaiSignatureHeaderAuthenticationKeyList() AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o.ApplyT(func(v *AkamaiAccessControl) []AkamaiSignatureHeaderAuthenticationKey {
		if v == nil {
			return nil
		}
		return v.AkamaiSignatureHeaderAuthenticationKeyList
	}).(AkamaiSignatureHeaderAuthenticationKeyArrayOutput)
}

// Akamai access control
type AkamaiAccessControlResponse struct {
	// authentication key list
	AkamaiSignatureHeaderAuthenticationKeyList []AkamaiSignatureHeaderAuthenticationKeyResponse `pulumi:"akamaiSignatureHeaderAuthenticationKeyList"`
}

// Akamai access control
type AkamaiAccessControlResponseOutput struct{ *pulumi.OutputState }

func (AkamaiAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiAccessControlResponse)(nil)).Elem()
}

func (o AkamaiAccessControlResponseOutput) ToAkamaiAccessControlResponseOutput() AkamaiAccessControlResponseOutput {
	return o
}

func (o AkamaiAccessControlResponseOutput) ToAkamaiAccessControlResponseOutputWithContext(ctx context.Context) AkamaiAccessControlResponseOutput {
	return o
}

// authentication key list
func (o AkamaiAccessControlResponseOutput) AkamaiSignatureHeaderAuthenticationKeyList() AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput {
	return o.ApplyT(func(v AkamaiAccessControlResponse) []AkamaiSignatureHeaderAuthenticationKeyResponse {
		return v.AkamaiSignatureHeaderAuthenticationKeyList
	}).(AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput)
}

type AkamaiAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (AkamaiAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AkamaiAccessControlResponse)(nil)).Elem()
}

func (o AkamaiAccessControlResponsePtrOutput) ToAkamaiAccessControlResponsePtrOutput() AkamaiAccessControlResponsePtrOutput {
	return o
}

func (o AkamaiAccessControlResponsePtrOutput) ToAkamaiAccessControlResponsePtrOutputWithContext(ctx context.Context) AkamaiAccessControlResponsePtrOutput {
	return o
}

func (o AkamaiAccessControlResponsePtrOutput) Elem() AkamaiAccessControlResponseOutput {
	return o.ApplyT(func(v *AkamaiAccessControlResponse) AkamaiAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret AkamaiAccessControlResponse
		return ret
	}).(AkamaiAccessControlResponseOutput)
}

// authentication key list
func (o AkamaiAccessControlResponsePtrOutput) AkamaiSignatureHeaderAuthenticationKeyList() AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput {
	return o.ApplyT(func(v *AkamaiAccessControlResponse) []AkamaiSignatureHeaderAuthenticationKeyResponse {
		if v == nil {
			return nil
		}
		return v.AkamaiSignatureHeaderAuthenticationKeyList
	}).(AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput)
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKey struct {
	// authentication key
	Base64Key *string `pulumi:"base64Key"`
	// The expiration time of the authentication key.
	Expiration *string `pulumi:"expiration"`
	// identifier of the key
	Identifier *string `pulumi:"identifier"`
}

// AkamaiSignatureHeaderAuthenticationKeyInput is an input type that accepts AkamaiSignatureHeaderAuthenticationKeyArgs and AkamaiSignatureHeaderAuthenticationKeyOutput values.
// You can construct a concrete instance of `AkamaiSignatureHeaderAuthenticationKeyInput` via:
//
//	AkamaiSignatureHeaderAuthenticationKeyArgs{...}
type AkamaiSignatureHeaderAuthenticationKeyInput interface {
	pulumi.Input

	ToAkamaiSignatureHeaderAuthenticationKeyOutput() AkamaiSignatureHeaderAuthenticationKeyOutput
	ToAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(context.Context) AkamaiSignatureHeaderAuthenticationKeyOutput
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKeyArgs struct {
	// authentication key
	Base64Key pulumi.StringPtrInput `pulumi:"base64Key"`
	// The expiration time of the authentication key.
	Expiration pulumi.StringPtrInput `pulumi:"expiration"`
	// identifier of the key
	Identifier pulumi.StringPtrInput `pulumi:"identifier"`
}

func (AkamaiSignatureHeaderAuthenticationKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (i AkamaiSignatureHeaderAuthenticationKeyArgs) ToAkamaiSignatureHeaderAuthenticationKeyOutput() AkamaiSignatureHeaderAuthenticationKeyOutput {
	return i.ToAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(context.Background())
}

func (i AkamaiSignatureHeaderAuthenticationKeyArgs) ToAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiSignatureHeaderAuthenticationKeyOutput)
}

// AkamaiSignatureHeaderAuthenticationKeyArrayInput is an input type that accepts AkamaiSignatureHeaderAuthenticationKeyArray and AkamaiSignatureHeaderAuthenticationKeyArrayOutput values.
// You can construct a concrete instance of `AkamaiSignatureHeaderAuthenticationKeyArrayInput` via:
//
//	AkamaiSignatureHeaderAuthenticationKeyArray{ AkamaiSignatureHeaderAuthenticationKeyArgs{...} }
type AkamaiSignatureHeaderAuthenticationKeyArrayInput interface {
	pulumi.Input

	ToAkamaiSignatureHeaderAuthenticationKeyArrayOutput() AkamaiSignatureHeaderAuthenticationKeyArrayOutput
	ToAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(context.Context) AkamaiSignatureHeaderAuthenticationKeyArrayOutput
}

type AkamaiSignatureHeaderAuthenticationKeyArray []AkamaiSignatureHeaderAuthenticationKeyInput

func (AkamaiSignatureHeaderAuthenticationKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (i AkamaiSignatureHeaderAuthenticationKeyArray) ToAkamaiSignatureHeaderAuthenticationKeyArrayOutput() AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return i.ToAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(context.Background())
}

func (i AkamaiSignatureHeaderAuthenticationKeyArray) ToAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AkamaiSignatureHeaderAuthenticationKeyArrayOutput)
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKeyOutput struct{ *pulumi.OutputState }

func (AkamaiSignatureHeaderAuthenticationKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (o AkamaiSignatureHeaderAuthenticationKeyOutput) ToAkamaiSignatureHeaderAuthenticationKeyOutput() AkamaiSignatureHeaderAuthenticationKeyOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyOutput) ToAkamaiSignatureHeaderAuthenticationKeyOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyOutput {
	return o
}

// authentication key
func (o AkamaiSignatureHeaderAuthenticationKeyOutput) Base64Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKey) *string { return v.Base64Key }).(pulumi.StringPtrOutput)
}

// The expiration time of the authentication key.
func (o AkamaiSignatureHeaderAuthenticationKeyOutput) Expiration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKey) *string { return v.Expiration }).(pulumi.StringPtrOutput)
}

// identifier of the key
func (o AkamaiSignatureHeaderAuthenticationKeyOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKey) *string { return v.Identifier }).(pulumi.StringPtrOutput)
}

type AkamaiSignatureHeaderAuthenticationKeyArrayOutput struct{ *pulumi.OutputState }

func (AkamaiSignatureHeaderAuthenticationKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AkamaiSignatureHeaderAuthenticationKey)(nil)).Elem()
}

func (o AkamaiSignatureHeaderAuthenticationKeyArrayOutput) ToAkamaiSignatureHeaderAuthenticationKeyArrayOutput() AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyArrayOutput) ToAkamaiSignatureHeaderAuthenticationKeyArrayOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyArrayOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyArrayOutput) Index(i pulumi.IntInput) AkamaiSignatureHeaderAuthenticationKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AkamaiSignatureHeaderAuthenticationKey {
		return vs[0].([]AkamaiSignatureHeaderAuthenticationKey)[vs[1].(int)]
	}).(AkamaiSignatureHeaderAuthenticationKeyOutput)
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKeyResponse struct {
	// authentication key
	Base64Key *string `pulumi:"base64Key"`
	// The expiration time of the authentication key.
	Expiration *string `pulumi:"expiration"`
	// identifier of the key
	Identifier *string `pulumi:"identifier"`
}

// Akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKeyResponseOutput struct{ *pulumi.OutputState }

func (AkamaiSignatureHeaderAuthenticationKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AkamaiSignatureHeaderAuthenticationKeyResponse)(nil)).Elem()
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) ToAkamaiSignatureHeaderAuthenticationKeyResponseOutput() AkamaiSignatureHeaderAuthenticationKeyResponseOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) ToAkamaiSignatureHeaderAuthenticationKeyResponseOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyResponseOutput {
	return o
}

// authentication key
func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) Base64Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKeyResponse) *string { return v.Base64Key }).(pulumi.StringPtrOutput)
}

// The expiration time of the authentication key.
func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) Expiration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKeyResponse) *string { return v.Expiration }).(pulumi.StringPtrOutput)
}

// identifier of the key
func (o AkamaiSignatureHeaderAuthenticationKeyResponseOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AkamaiSignatureHeaderAuthenticationKeyResponse) *string { return v.Identifier }).(pulumi.StringPtrOutput)
}

type AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AkamaiSignatureHeaderAuthenticationKeyResponse)(nil)).Elem()
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput) ToAkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput() AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput) ToAkamaiSignatureHeaderAuthenticationKeyResponseArrayOutputWithContext(ctx context.Context) AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput {
	return o
}

func (o AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput) Index(i pulumi.IntInput) AkamaiSignatureHeaderAuthenticationKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AkamaiSignatureHeaderAuthenticationKeyResponse {
		return vs[0].([]AkamaiSignatureHeaderAuthenticationKeyResponse)[vs[1].(int)]
	}).(AkamaiSignatureHeaderAuthenticationKeyResponseOutput)
}

// The Asset File Storage encryption metadata.
type AssetFileEncryptionMetadataResponse struct {
	// The Asset File Id.
	AssetFileId string `pulumi:"assetFileId"`
	// The Asset File name.
	AssetFileName *string `pulumi:"assetFileName"`
	// The Asset File initialization vector.
	InitializationVector *string `pulumi:"initializationVector"`
}

// The Asset File Storage encryption metadata.
type AssetFileEncryptionMetadataResponseOutput struct{ *pulumi.OutputState }

func (AssetFileEncryptionMetadataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AssetFileEncryptionMetadataResponse)(nil)).Elem()
}

func (o AssetFileEncryptionMetadataResponseOutput) ToAssetFileEncryptionMetadataResponseOutput() AssetFileEncryptionMetadataResponseOutput {
	return o
}

func (o AssetFileEncryptionMetadataResponseOutput) ToAssetFileEncryptionMetadataResponseOutputWithContext(ctx context.Context) AssetFileEncryptionMetadataResponseOutput {
	return o
}

// The Asset File Id.
func (o AssetFileEncryptionMetadataResponseOutput) AssetFileId() pulumi.StringOutput {
	return o.ApplyT(func(v AssetFileEncryptionMetadataResponse) string { return v.AssetFileId }).(pulumi.StringOutput)
}

// The Asset File name.
func (o AssetFileEncryptionMetadataResponseOutput) AssetFileName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AssetFileEncryptionMetadataResponse) *string { return v.AssetFileName }).(pulumi.StringPtrOutput)
}

// The Asset File initialization vector.
func (o AssetFileEncryptionMetadataResponseOutput) InitializationVector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AssetFileEncryptionMetadataResponse) *string { return v.InitializationVector }).(pulumi.StringPtrOutput)
}

type AssetFileEncryptionMetadataResponseArrayOutput struct{ *pulumi.OutputState }

func (AssetFileEncryptionMetadataResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AssetFileEncryptionMetadataResponse)(nil)).Elem()
}

func (o AssetFileEncryptionMetadataResponseArrayOutput) ToAssetFileEncryptionMetadataResponseArrayOutput() AssetFileEncryptionMetadataResponseArrayOutput {
	return o
}

func (o AssetFileEncryptionMetadataResponseArrayOutput) ToAssetFileEncryptionMetadataResponseArrayOutputWithContext(ctx context.Context) AssetFileEncryptionMetadataResponseArrayOutput {
	return o
}

func (o AssetFileEncryptionMetadataResponseArrayOutput) Index(i pulumi.IntInput) AssetFileEncryptionMetadataResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AssetFileEncryptionMetadataResponse {
		return vs[0].([]AssetFileEncryptionMetadataResponse)[vs[1].(int)]
	}).(AssetFileEncryptionMetadataResponseOutput)
}

// Properties of the Streaming Locator.
type AssetStreamingLocatorResponse struct {
	// Asset Name.
	AssetName string `pulumi:"assetName"`
	// The creation time of the Streaming Locator.
	Created string `pulumi:"created"`
	// Name of the default ContentKeyPolicy used by this Streaming Locator.
	DefaultContentKeyPolicyName string `pulumi:"defaultContentKeyPolicyName"`
	// The end time of the Streaming Locator.
	EndTime string `pulumi:"endTime"`
	// Streaming Locator name.
	Name string `pulumi:"name"`
	// The start time of the Streaming Locator.
	StartTime string `pulumi:"startTime"`
	// StreamingLocatorId of the Streaming Locator.
	StreamingLocatorId string `pulumi:"streamingLocatorId"`
	// Name of the Streaming Policy used by this Streaming Locator.
	StreamingPolicyName string `pulumi:"streamingPolicyName"`
}

// Properties of the Streaming Locator.
type AssetStreamingLocatorResponseOutput struct{ *pulumi.OutputState }

func (AssetStreamingLocatorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AssetStreamingLocatorResponse)(nil)).Elem()
}

func (o AssetStreamingLocatorResponseOutput) ToAssetStreamingLocatorResponseOutput() AssetStreamingLocatorResponseOutput {
	return o
}

func (o AssetStreamingLocatorResponseOutput) ToAssetStreamingLocatorResponseOutputWithContext(ctx context.Context) AssetStreamingLocatorResponseOutput {
	return o
}

// Asset Name.
func (o AssetStreamingLocatorResponseOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.AssetName }).(pulumi.StringOutput)
}

// The creation time of the Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) Created() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.Created }).(pulumi.StringOutput)
}

// Name of the default ContentKeyPolicy used by this Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) DefaultContentKeyPolicyName() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.DefaultContentKeyPolicyName }).(pulumi.StringOutput)
}

// The end time of the Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.EndTime }).(pulumi.StringOutput)
}

// Streaming Locator name.
func (o AssetStreamingLocatorResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The start time of the Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.StartTime }).(pulumi.StringOutput)
}

// StreamingLocatorId of the Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) StreamingLocatorId() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.StreamingLocatorId }).(pulumi.StringOutput)
}

// Name of the Streaming Policy used by this Streaming Locator.
func (o AssetStreamingLocatorResponseOutput) StreamingPolicyName() pulumi.StringOutput {
	return o.ApplyT(func(v AssetStreamingLocatorResponse) string { return v.StreamingPolicyName }).(pulumi.StringOutput)
}

type AssetStreamingLocatorResponseArrayOutput struct{ *pulumi.OutputState }

func (AssetStreamingLocatorResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AssetStreamingLocatorResponse)(nil)).Elem()
}

func (o AssetStreamingLocatorResponseArrayOutput) ToAssetStreamingLocatorResponseArrayOutput() AssetStreamingLocatorResponseArrayOutput {
	return o
}

func (o AssetStreamingLocatorResponseArrayOutput) ToAssetStreamingLocatorResponseArrayOutputWithContext(ctx context.Context) AssetStreamingLocatorResponseArrayOutput {
	return o
}

func (o AssetStreamingLocatorResponseArrayOutput) Index(i pulumi.IntInput) AssetStreamingLocatorResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AssetStreamingLocatorResponse {
		return vs[0].([]AssetStreamingLocatorResponse)[vs[1].(int)]
	}).(AssetStreamingLocatorResponseOutput)
}

// Defines the common properties for all audio codecs.
type Audio struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Audio'.
	OdataType string `pulumi:"odataType"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// The Audio Analyzer preset applies a pre-defined set of AI-based analysis operations, including speech transcription. Currently, the preset supports processing of content with a single audio track.
type AudioAnalyzerPreset struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioAnalyzerPreset'.
	OdataType string `pulumi:"odataType"`
}

// The Audio Analyzer preset applies a pre-defined set of AI-based analysis operations, including speech transcription. Currently, the preset supports processing of content with a single audio track.
type AudioAnalyzerPresetResponse struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioAnalyzerPreset'.
	OdataType string `pulumi:"odataType"`
}

// Describes the properties of an audio overlay.
type AudioOverlay struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `pulumi:"audioGainLevel"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End *string `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel string `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioOverlay'.
	OdataType string `pulumi:"odataType"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `pulumi:"start"`
}

// Describes the properties of an audio overlay.
type AudioOverlayResponse struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `pulumi:"audioGainLevel"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End *string `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel string `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioOverlay'.
	OdataType string `pulumi:"odataType"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `pulumi:"start"`
}

// Defines the common properties for all audio codecs.
type AudioResponse struct {
	// The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int `pulumi:"bitrate"`
	// The number of channels in the audio.
	Channels *int `pulumi:"channels"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Audio'.
	OdataType string `pulumi:"odataType"`
	// The sampling rate to use for encoding in hertz.
	SamplingRate *int `pulumi:"samplingRate"`
}

// A TrackSelection to select audio tracks.
type AudioTrackDescriptor struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioTrackDescriptor'.
	OdataType string `pulumi:"odataType"`
}

// A TrackSelection to select audio tracks.
type AudioTrackDescriptorResponse struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.AudioTrackDescriptor'.
	OdataType string `pulumi:"odataType"`
}

// Describes a built-in preset for encoding the input video with the Standard Encoder.
type BuiltInStandardEncoderPreset struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.BuiltInStandardEncoderPreset'.
	OdataType string `pulumi:"odataType"`
	// The built-in preset to be used for encoding videos.
	PresetName string `pulumi:"presetName"`
}

// Describes a built-in preset for encoding the input video with the Standard Encoder.
type BuiltInStandardEncoderPresetResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.BuiltInStandardEncoderPreset'.
	OdataType string `pulumi:"odataType"`
	// The built-in preset to be used for encoding videos.
	PresetName string `pulumi:"presetName"`
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfiguration struct {
	// FairPlay configurations
	FairPlay *StreamingPolicyFairPlayConfiguration `pulumi:"fairPlay"`
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `pulumi:"playReady"`
	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `pulumi:"widevine"`
}

// CbcsDrmConfigurationInput is an input type that accepts CbcsDrmConfigurationArgs and CbcsDrmConfigurationOutput values.
// You can construct a concrete instance of `CbcsDrmConfigurationInput` via:
//
//	CbcsDrmConfigurationArgs{...}
type CbcsDrmConfigurationInput interface {
	pulumi.Input

	ToCbcsDrmConfigurationOutput() CbcsDrmConfigurationOutput
	ToCbcsDrmConfigurationOutputWithContext(context.Context) CbcsDrmConfigurationOutput
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfigurationArgs struct {
	// FairPlay configurations
	FairPlay StreamingPolicyFairPlayConfigurationPtrInput `pulumi:"fairPlay"`
	// PlayReady configurations
	PlayReady StreamingPolicyPlayReadyConfigurationPtrInput `pulumi:"playReady"`
	// Widevine configurations
	Widevine StreamingPolicyWidevineConfigurationPtrInput `pulumi:"widevine"`
}

func (CbcsDrmConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CbcsDrmConfiguration)(nil)).Elem()
}

func (i CbcsDrmConfigurationArgs) ToCbcsDrmConfigurationOutput() CbcsDrmConfigurationOutput {
	return i.ToCbcsDrmConfigurationOutputWithContext(context.Background())
}

func (i CbcsDrmConfigurationArgs) ToCbcsDrmConfigurationOutputWithContext(ctx context.Context) CbcsDrmConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CbcsDrmConfigurationOutput)
}

func (i CbcsDrmConfigurationArgs) ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput {
	return i.ToCbcsDrmConfigurationPtrOutputWithContext(context.Background())
}

func (i CbcsDrmConfigurationArgs) ToCbcsDrmConfigurationPtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CbcsDrmConfigurationOutput).ToCbcsDrmConfigurationPtrOutputWithContext(ctx)
}

// CbcsDrmConfigurationPtrInput is an input type that accepts CbcsDrmConfigurationArgs, CbcsDrmConfigurationPtr and CbcsDrmConfigurationPtrOutput values.
// You can construct a concrete instance of `CbcsDrmConfigurationPtrInput` via:
//
//	        CbcsDrmConfigurationArgs{...}
//
//	or:
//
//	        nil
type CbcsDrmConfigurationPtrInput interface {
	pulumi.Input

	ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput
	ToCbcsDrmConfigurationPtrOutputWithContext(context.Context) CbcsDrmConfigurationPtrOutput
}

type cbcsDrmConfigurationPtrType CbcsDrmConfigurationArgs

func CbcsDrmConfigurationPtr(v *CbcsDrmConfigurationArgs) CbcsDrmConfigurationPtrInput {
	return (*cbcsDrmConfigurationPtrType)(v)
}

func (*cbcsDrmConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CbcsDrmConfiguration)(nil)).Elem()
}

func (i *cbcsDrmConfigurationPtrType) ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput {
	return i.ToCbcsDrmConfigurationPtrOutputWithContext(context.Background())
}

func (i *cbcsDrmConfigurationPtrType) ToCbcsDrmConfigurationPtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CbcsDrmConfigurationPtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfigurationOutput struct{ *pulumi.OutputState }

func (CbcsDrmConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CbcsDrmConfiguration)(nil)).Elem()
}

func (o CbcsDrmConfigurationOutput) ToCbcsDrmConfigurationOutput() CbcsDrmConfigurationOutput {
	return o
}

func (o CbcsDrmConfigurationOutput) ToCbcsDrmConfigurationOutputWithContext(ctx context.Context) CbcsDrmConfigurationOutput {
	return o
}

func (o CbcsDrmConfigurationOutput) ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput {
	return o.ToCbcsDrmConfigurationPtrOutputWithContext(context.Background())
}

func (o CbcsDrmConfigurationOutput) ToCbcsDrmConfigurationPtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CbcsDrmConfiguration) *CbcsDrmConfiguration {
		return &v
	}).(CbcsDrmConfigurationPtrOutput)
}

// FairPlay configurations
func (o CbcsDrmConfigurationOutput) FairPlay() StreamingPolicyFairPlayConfigurationPtrOutput {
	return o.ApplyT(func(v CbcsDrmConfiguration) *StreamingPolicyFairPlayConfiguration { return v.FairPlay }).(StreamingPolicyFairPlayConfigurationPtrOutput)
}

// PlayReady configurations
func (o CbcsDrmConfigurationOutput) PlayReady() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyT(func(v CbcsDrmConfiguration) *StreamingPolicyPlayReadyConfiguration { return v.PlayReady }).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Widevine configurations
func (o CbcsDrmConfigurationOutput) Widevine() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyT(func(v CbcsDrmConfiguration) *StreamingPolicyWidevineConfiguration { return v.Widevine }).(StreamingPolicyWidevineConfigurationPtrOutput)
}

type CbcsDrmConfigurationPtrOutput struct{ *pulumi.OutputState }

func (CbcsDrmConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CbcsDrmConfiguration)(nil)).Elem()
}

func (o CbcsDrmConfigurationPtrOutput) ToCbcsDrmConfigurationPtrOutput() CbcsDrmConfigurationPtrOutput {
	return o
}

func (o CbcsDrmConfigurationPtrOutput) ToCbcsDrmConfigurationPtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationPtrOutput {
	return o
}

func (o CbcsDrmConfigurationPtrOutput) Elem() CbcsDrmConfigurationOutput {
	return o.ApplyT(func(v *CbcsDrmConfiguration) CbcsDrmConfiguration {
		if v != nil {
			return *v
		}
		var ret CbcsDrmConfiguration
		return ret
	}).(CbcsDrmConfigurationOutput)
}

// FairPlay configurations
func (o CbcsDrmConfigurationPtrOutput) FairPlay() StreamingPolicyFairPlayConfigurationPtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfiguration) *StreamingPolicyFairPlayConfiguration {
		if v == nil {
			return nil
		}
		return v.FairPlay
	}).(StreamingPolicyFairPlayConfigurationPtrOutput)
}

// PlayReady configurations
func (o CbcsDrmConfigurationPtrOutput) PlayReady() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfiguration) *StreamingPolicyPlayReadyConfiguration {
		if v == nil {
			return nil
		}
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Widevine configurations
func (o CbcsDrmConfigurationPtrOutput) Widevine() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfiguration) *StreamingPolicyWidevineConfiguration {
		if v == nil {
			return nil
		}
		return v.Widevine
	}).(StreamingPolicyWidevineConfigurationPtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfigurationResponse struct {
	// FairPlay configurations
	FairPlay *StreamingPolicyFairPlayConfigurationResponse `pulumi:"fairPlay"`
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfigurationResponse `pulumi:"playReady"`
	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfigurationResponse `pulumi:"widevine"`
}

// Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
type CbcsDrmConfigurationResponseOutput struct{ *pulumi.OutputState }

func (CbcsDrmConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CbcsDrmConfigurationResponse)(nil)).Elem()
}

func (o CbcsDrmConfigurationResponseOutput) ToCbcsDrmConfigurationResponseOutput() CbcsDrmConfigurationResponseOutput {
	return o
}

func (o CbcsDrmConfigurationResponseOutput) ToCbcsDrmConfigurationResponseOutputWithContext(ctx context.Context) CbcsDrmConfigurationResponseOutput {
	return o
}

// FairPlay configurations
func (o CbcsDrmConfigurationResponseOutput) FairPlay() StreamingPolicyFairPlayConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CbcsDrmConfigurationResponse) *StreamingPolicyFairPlayConfigurationResponse { return v.FairPlay }).(StreamingPolicyFairPlayConfigurationResponsePtrOutput)
}

// PlayReady configurations
func (o CbcsDrmConfigurationResponseOutput) PlayReady() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CbcsDrmConfigurationResponse) *StreamingPolicyPlayReadyConfigurationResponse {
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationResponsePtrOutput)
}

// Widevine configurations
func (o CbcsDrmConfigurationResponseOutput) Widevine() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CbcsDrmConfigurationResponse) *StreamingPolicyWidevineConfigurationResponse { return v.Widevine }).(StreamingPolicyWidevineConfigurationResponsePtrOutput)
}

type CbcsDrmConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (CbcsDrmConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CbcsDrmConfigurationResponse)(nil)).Elem()
}

func (o CbcsDrmConfigurationResponsePtrOutput) ToCbcsDrmConfigurationResponsePtrOutput() CbcsDrmConfigurationResponsePtrOutput {
	return o
}

func (o CbcsDrmConfigurationResponsePtrOutput) ToCbcsDrmConfigurationResponsePtrOutputWithContext(ctx context.Context) CbcsDrmConfigurationResponsePtrOutput {
	return o
}

func (o CbcsDrmConfigurationResponsePtrOutput) Elem() CbcsDrmConfigurationResponseOutput {
	return o.ApplyT(func(v *CbcsDrmConfigurationResponse) CbcsDrmConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret CbcsDrmConfigurationResponse
		return ret
	}).(CbcsDrmConfigurationResponseOutput)
}

// FairPlay configurations
func (o CbcsDrmConfigurationResponsePtrOutput) FairPlay() StreamingPolicyFairPlayConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfigurationResponse) *StreamingPolicyFairPlayConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.FairPlay
	}).(StreamingPolicyFairPlayConfigurationResponsePtrOutput)
}

// PlayReady configurations
func (o CbcsDrmConfigurationResponsePtrOutput) PlayReady() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfigurationResponse) *StreamingPolicyPlayReadyConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationResponsePtrOutput)
}

// Widevine configurations
func (o CbcsDrmConfigurationResponsePtrOutput) Widevine() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CbcsDrmConfigurationResponse) *StreamingPolicyWidevineConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.Widevine
	}).(StreamingPolicyWidevineConfigurationResponsePtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfiguration struct {
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `pulumi:"playReady"`
	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `pulumi:"widevine"`
}

// CencDrmConfigurationInput is an input type that accepts CencDrmConfigurationArgs and CencDrmConfigurationOutput values.
// You can construct a concrete instance of `CencDrmConfigurationInput` via:
//
//	CencDrmConfigurationArgs{...}
type CencDrmConfigurationInput interface {
	pulumi.Input

	ToCencDrmConfigurationOutput() CencDrmConfigurationOutput
	ToCencDrmConfigurationOutputWithContext(context.Context) CencDrmConfigurationOutput
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfigurationArgs struct {
	// PlayReady configurations
	PlayReady StreamingPolicyPlayReadyConfigurationPtrInput `pulumi:"playReady"`
	// Widevine configurations
	Widevine StreamingPolicyWidevineConfigurationPtrInput `pulumi:"widevine"`
}

func (CencDrmConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CencDrmConfiguration)(nil)).Elem()
}

func (i CencDrmConfigurationArgs) ToCencDrmConfigurationOutput() CencDrmConfigurationOutput {
	return i.ToCencDrmConfigurationOutputWithContext(context.Background())
}

func (i CencDrmConfigurationArgs) ToCencDrmConfigurationOutputWithContext(ctx context.Context) CencDrmConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CencDrmConfigurationOutput)
}

func (i CencDrmConfigurationArgs) ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput {
	return i.ToCencDrmConfigurationPtrOutputWithContext(context.Background())
}

func (i CencDrmConfigurationArgs) ToCencDrmConfigurationPtrOutputWithContext(ctx context.Context) CencDrmConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CencDrmConfigurationOutput).ToCencDrmConfigurationPtrOutputWithContext(ctx)
}

// CencDrmConfigurationPtrInput is an input type that accepts CencDrmConfigurationArgs, CencDrmConfigurationPtr and CencDrmConfigurationPtrOutput values.
// You can construct a concrete instance of `CencDrmConfigurationPtrInput` via:
//
//	        CencDrmConfigurationArgs{...}
//
//	or:
//
//	        nil
type CencDrmConfigurationPtrInput interface {
	pulumi.Input

	ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput
	ToCencDrmConfigurationPtrOutputWithContext(context.Context) CencDrmConfigurationPtrOutput
}

type cencDrmConfigurationPtrType CencDrmConfigurationArgs

func CencDrmConfigurationPtr(v *CencDrmConfigurationArgs) CencDrmConfigurationPtrInput {
	return (*cencDrmConfigurationPtrType)(v)
}

func (*cencDrmConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CencDrmConfiguration)(nil)).Elem()
}

func (i *cencDrmConfigurationPtrType) ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput {
	return i.ToCencDrmConfigurationPtrOutputWithContext(context.Background())
}

func (i *cencDrmConfigurationPtrType) ToCencDrmConfigurationPtrOutputWithContext(ctx context.Context) CencDrmConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CencDrmConfigurationPtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfigurationOutput struct{ *pulumi.OutputState }

func (CencDrmConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CencDrmConfiguration)(nil)).Elem()
}

func (o CencDrmConfigurationOutput) ToCencDrmConfigurationOutput() CencDrmConfigurationOutput {
	return o
}

func (o CencDrmConfigurationOutput) ToCencDrmConfigurationOutputWithContext(ctx context.Context) CencDrmConfigurationOutput {
	return o
}

func (o CencDrmConfigurationOutput) ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput {
	return o.ToCencDrmConfigurationPtrOutputWithContext(context.Background())
}

func (o CencDrmConfigurationOutput) ToCencDrmConfigurationPtrOutputWithContext(ctx context.Context) CencDrmConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CencDrmConfiguration) *CencDrmConfiguration {
		return &v
	}).(CencDrmConfigurationPtrOutput)
}

// PlayReady configurations
func (o CencDrmConfigurationOutput) PlayReady() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyT(func(v CencDrmConfiguration) *StreamingPolicyPlayReadyConfiguration { return v.PlayReady }).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Widevine configurations
func (o CencDrmConfigurationOutput) Widevine() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyT(func(v CencDrmConfiguration) *StreamingPolicyWidevineConfiguration { return v.Widevine }).(StreamingPolicyWidevineConfigurationPtrOutput)
}

type CencDrmConfigurationPtrOutput struct{ *pulumi.OutputState }

func (CencDrmConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CencDrmConfiguration)(nil)).Elem()
}

func (o CencDrmConfigurationPtrOutput) ToCencDrmConfigurationPtrOutput() CencDrmConfigurationPtrOutput {
	return o
}

func (o CencDrmConfigurationPtrOutput) ToCencDrmConfigurationPtrOutputWithContext(ctx context.Context) CencDrmConfigurationPtrOutput {
	return o
}

func (o CencDrmConfigurationPtrOutput) Elem() CencDrmConfigurationOutput {
	return o.ApplyT(func(v *CencDrmConfiguration) CencDrmConfiguration {
		if v != nil {
			return *v
		}
		var ret CencDrmConfiguration
		return ret
	}).(CencDrmConfigurationOutput)
}

// PlayReady configurations
func (o CencDrmConfigurationPtrOutput) PlayReady() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyT(func(v *CencDrmConfiguration) *StreamingPolicyPlayReadyConfiguration {
		if v == nil {
			return nil
		}
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Widevine configurations
func (o CencDrmConfigurationPtrOutput) Widevine() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyT(func(v *CencDrmConfiguration) *StreamingPolicyWidevineConfiguration {
		if v == nil {
			return nil
		}
		return v.Widevine
	}).(StreamingPolicyWidevineConfigurationPtrOutput)
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfigurationResponse struct {
	// PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfigurationResponse `pulumi:"playReady"`
	// Widevine configurations
	Widevine *StreamingPolicyWidevineConfigurationResponse `pulumi:"widevine"`
}

// Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
type CencDrmConfigurationResponseOutput struct{ *pulumi.OutputState }

func (CencDrmConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CencDrmConfigurationResponse)(nil)).Elem()
}

func (o CencDrmConfigurationResponseOutput) ToCencDrmConfigurationResponseOutput() CencDrmConfigurationResponseOutput {
	return o
}

func (o CencDrmConfigurationResponseOutput) ToCencDrmConfigurationResponseOutputWithContext(ctx context.Context) CencDrmConfigurationResponseOutput {
	return o
}

// PlayReady configurations
func (o CencDrmConfigurationResponseOutput) PlayReady() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CencDrmConfigurationResponse) *StreamingPolicyPlayReadyConfigurationResponse {
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationResponsePtrOutput)
}

// Widevine configurations
func (o CencDrmConfigurationResponseOutput) Widevine() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CencDrmConfigurationResponse) *StreamingPolicyWidevineConfigurationResponse { return v.Widevine }).(StreamingPolicyWidevineConfigurationResponsePtrOutput)
}

type CencDrmConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (CencDrmConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CencDrmConfigurationResponse)(nil)).Elem()
}

func (o CencDrmConfigurationResponsePtrOutput) ToCencDrmConfigurationResponsePtrOutput() CencDrmConfigurationResponsePtrOutput {
	return o
}

func (o CencDrmConfigurationResponsePtrOutput) ToCencDrmConfigurationResponsePtrOutputWithContext(ctx context.Context) CencDrmConfigurationResponsePtrOutput {
	return o
}

func (o CencDrmConfigurationResponsePtrOutput) Elem() CencDrmConfigurationResponseOutput {
	return o.ApplyT(func(v *CencDrmConfigurationResponse) CencDrmConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret CencDrmConfigurationResponse
		return ret
	}).(CencDrmConfigurationResponseOutput)
}

// PlayReady configurations
func (o CencDrmConfigurationResponsePtrOutput) PlayReady() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CencDrmConfigurationResponse) *StreamingPolicyPlayReadyConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.PlayReady
	}).(StreamingPolicyPlayReadyConfigurationResponsePtrOutput)
}

// Widevine configurations
func (o CencDrmConfigurationResponsePtrOutput) Widevine() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CencDrmConfigurationResponse) *StreamingPolicyWidevineConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.Widevine
	}).(StreamingPolicyWidevineConfigurationResponsePtrOutput)
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcs struct {
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelection `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `pulumi:"contentKeys"`
	// Configuration of DRMs for current encryption scheme
	Drm *CbcsDrmConfiguration `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `pulumi:"enabledProtocols"`
}

// CommonEncryptionCbcsInput is an input type that accepts CommonEncryptionCbcsArgs and CommonEncryptionCbcsOutput values.
// You can construct a concrete instance of `CommonEncryptionCbcsInput` via:
//
//	CommonEncryptionCbcsArgs{...}
type CommonEncryptionCbcsInput interface {
	pulumi.Input

	ToCommonEncryptionCbcsOutput() CommonEncryptionCbcsOutput
	ToCommonEncryptionCbcsOutputWithContext(context.Context) CommonEncryptionCbcsOutput
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcsArgs struct {
	// Representing which tracks should not be encrypted
	ClearTracks TrackSelectionArrayInput `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys StreamingPolicyContentKeysPtrInput `pulumi:"contentKeys"`
	// Configuration of DRMs for current encryption scheme
	Drm CbcsDrmConfigurationPtrInput `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols EnabledProtocolsPtrInput `pulumi:"enabledProtocols"`
}

func (CommonEncryptionCbcsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCbcs)(nil)).Elem()
}

func (i CommonEncryptionCbcsArgs) ToCommonEncryptionCbcsOutput() CommonEncryptionCbcsOutput {
	return i.ToCommonEncryptionCbcsOutputWithContext(context.Background())
}

func (i CommonEncryptionCbcsArgs) ToCommonEncryptionCbcsOutputWithContext(ctx context.Context) CommonEncryptionCbcsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCbcsOutput)
}

func (i CommonEncryptionCbcsArgs) ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput {
	return i.ToCommonEncryptionCbcsPtrOutputWithContext(context.Background())
}

func (i CommonEncryptionCbcsArgs) ToCommonEncryptionCbcsPtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCbcsOutput).ToCommonEncryptionCbcsPtrOutputWithContext(ctx)
}

// CommonEncryptionCbcsPtrInput is an input type that accepts CommonEncryptionCbcsArgs, CommonEncryptionCbcsPtr and CommonEncryptionCbcsPtrOutput values.
// You can construct a concrete instance of `CommonEncryptionCbcsPtrInput` via:
//
//	        CommonEncryptionCbcsArgs{...}
//
//	or:
//
//	        nil
type CommonEncryptionCbcsPtrInput interface {
	pulumi.Input

	ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput
	ToCommonEncryptionCbcsPtrOutputWithContext(context.Context) CommonEncryptionCbcsPtrOutput
}

type commonEncryptionCbcsPtrType CommonEncryptionCbcsArgs

func CommonEncryptionCbcsPtr(v *CommonEncryptionCbcsArgs) CommonEncryptionCbcsPtrInput {
	return (*commonEncryptionCbcsPtrType)(v)
}

func (*commonEncryptionCbcsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCbcs)(nil)).Elem()
}

func (i *commonEncryptionCbcsPtrType) ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput {
	return i.ToCommonEncryptionCbcsPtrOutputWithContext(context.Background())
}

func (i *commonEncryptionCbcsPtrType) ToCommonEncryptionCbcsPtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCbcsPtrOutput)
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcsOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCbcsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCbcs)(nil)).Elem()
}

func (o CommonEncryptionCbcsOutput) ToCommonEncryptionCbcsOutput() CommonEncryptionCbcsOutput {
	return o
}

func (o CommonEncryptionCbcsOutput) ToCommonEncryptionCbcsOutputWithContext(ctx context.Context) CommonEncryptionCbcsOutput {
	return o
}

func (o CommonEncryptionCbcsOutput) ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput {
	return o.ToCommonEncryptionCbcsPtrOutputWithContext(context.Background())
}

func (o CommonEncryptionCbcsOutput) ToCommonEncryptionCbcsPtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CommonEncryptionCbcs) *CommonEncryptionCbcs {
		return &v
	}).(CommonEncryptionCbcsPtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCbcsOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v CommonEncryptionCbcs) []TrackSelection { return v.ClearTracks }).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCbcsOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcs) *StreamingPolicyContentKeys { return v.ContentKeys }).(StreamingPolicyContentKeysPtrOutput)
}

// Configuration of DRMs for current encryption scheme
func (o CommonEncryptionCbcsOutput) Drm() CbcsDrmConfigurationPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcs) *CbcsDrmConfiguration { return v.Drm }).(CbcsDrmConfigurationPtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCbcsOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcs) *EnabledProtocols { return v.EnabledProtocols }).(EnabledProtocolsPtrOutput)
}

type CommonEncryptionCbcsPtrOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCbcsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCbcs)(nil)).Elem()
}

func (o CommonEncryptionCbcsPtrOutput) ToCommonEncryptionCbcsPtrOutput() CommonEncryptionCbcsPtrOutput {
	return o
}

func (o CommonEncryptionCbcsPtrOutput) ToCommonEncryptionCbcsPtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsPtrOutput {
	return o
}

func (o CommonEncryptionCbcsPtrOutput) Elem() CommonEncryptionCbcsOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) CommonEncryptionCbcs {
		if v != nil {
			return *v
		}
		var ret CommonEncryptionCbcs
		return ret
	}).(CommonEncryptionCbcsOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCbcsPtrOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) []TrackSelection {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCbcsPtrOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) *StreamingPolicyContentKeys {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysPtrOutput)
}

// Configuration of DRMs for current encryption scheme
func (o CommonEncryptionCbcsPtrOutput) Drm() CbcsDrmConfigurationPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) *CbcsDrmConfiguration {
		if v == nil {
			return nil
		}
		return v.Drm
	}).(CbcsDrmConfigurationPtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCbcsPtrOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcs) *EnabledProtocols {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsPtrOutput)
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcsResponse struct {
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelectionResponse `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeysResponse `pulumi:"contentKeys"`
	// Configuration of DRMs for current encryption scheme
	Drm *CbcsDrmConfigurationResponse `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocolsResponse `pulumi:"enabledProtocols"`
}

// Class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcsResponseOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCbcsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCbcsResponse)(nil)).Elem()
}

func (o CommonEncryptionCbcsResponseOutput) ToCommonEncryptionCbcsResponseOutput() CommonEncryptionCbcsResponseOutput {
	return o
}

func (o CommonEncryptionCbcsResponseOutput) ToCommonEncryptionCbcsResponseOutputWithContext(ctx context.Context) CommonEncryptionCbcsResponseOutput {
	return o
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCbcsResponseOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v CommonEncryptionCbcsResponse) []TrackSelectionResponse { return v.ClearTracks }).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCbcsResponseOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcsResponse) *StreamingPolicyContentKeysResponse { return v.ContentKeys }).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Configuration of DRMs for current encryption scheme
func (o CommonEncryptionCbcsResponseOutput) Drm() CbcsDrmConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcsResponse) *CbcsDrmConfigurationResponse { return v.Drm }).(CbcsDrmConfigurationResponsePtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCbcsResponseOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCbcsResponse) *EnabledProtocolsResponse { return v.EnabledProtocols }).(EnabledProtocolsResponsePtrOutput)
}

type CommonEncryptionCbcsResponsePtrOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCbcsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCbcsResponse)(nil)).Elem()
}

func (o CommonEncryptionCbcsResponsePtrOutput) ToCommonEncryptionCbcsResponsePtrOutput() CommonEncryptionCbcsResponsePtrOutput {
	return o
}

func (o CommonEncryptionCbcsResponsePtrOutput) ToCommonEncryptionCbcsResponsePtrOutputWithContext(ctx context.Context) CommonEncryptionCbcsResponsePtrOutput {
	return o
}

func (o CommonEncryptionCbcsResponsePtrOutput) Elem() CommonEncryptionCbcsResponseOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) CommonEncryptionCbcsResponse {
		if v != nil {
			return *v
		}
		var ret CommonEncryptionCbcsResponse
		return ret
	}).(CommonEncryptionCbcsResponseOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCbcsResponsePtrOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) []TrackSelectionResponse {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCbcsResponsePtrOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) *StreamingPolicyContentKeysResponse {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Configuration of DRMs for current encryption scheme
func (o CommonEncryptionCbcsResponsePtrOutput) Drm() CbcsDrmConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) *CbcsDrmConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.Drm
	}).(CbcsDrmConfigurationResponsePtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCbcsResponsePtrOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCbcsResponse) *EnabledProtocolsResponse {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsResponsePtrOutput)
}

// Class for envelope encryption scheme
type CommonEncryptionCenc struct {
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelection `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `pulumi:"contentKeys"`
	// Configuration of DRMs for CommonEncryptionCenc encryption scheme
	Drm *CencDrmConfiguration `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `pulumi:"enabledProtocols"`
}

// CommonEncryptionCencInput is an input type that accepts CommonEncryptionCencArgs and CommonEncryptionCencOutput values.
// You can construct a concrete instance of `CommonEncryptionCencInput` via:
//
//	CommonEncryptionCencArgs{...}
type CommonEncryptionCencInput interface {
	pulumi.Input

	ToCommonEncryptionCencOutput() CommonEncryptionCencOutput
	ToCommonEncryptionCencOutputWithContext(context.Context) CommonEncryptionCencOutput
}

// Class for envelope encryption scheme
type CommonEncryptionCencArgs struct {
	// Representing which tracks should not be encrypted
	ClearTracks TrackSelectionArrayInput `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys StreamingPolicyContentKeysPtrInput `pulumi:"contentKeys"`
	// Configuration of DRMs for CommonEncryptionCenc encryption scheme
	Drm CencDrmConfigurationPtrInput `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols EnabledProtocolsPtrInput `pulumi:"enabledProtocols"`
}

func (CommonEncryptionCencArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCenc)(nil)).Elem()
}

func (i CommonEncryptionCencArgs) ToCommonEncryptionCencOutput() CommonEncryptionCencOutput {
	return i.ToCommonEncryptionCencOutputWithContext(context.Background())
}

func (i CommonEncryptionCencArgs) ToCommonEncryptionCencOutputWithContext(ctx context.Context) CommonEncryptionCencOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCencOutput)
}

func (i CommonEncryptionCencArgs) ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput {
	return i.ToCommonEncryptionCencPtrOutputWithContext(context.Background())
}

func (i CommonEncryptionCencArgs) ToCommonEncryptionCencPtrOutputWithContext(ctx context.Context) CommonEncryptionCencPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCencOutput).ToCommonEncryptionCencPtrOutputWithContext(ctx)
}

// CommonEncryptionCencPtrInput is an input type that accepts CommonEncryptionCencArgs, CommonEncryptionCencPtr and CommonEncryptionCencPtrOutput values.
// You can construct a concrete instance of `CommonEncryptionCencPtrInput` via:
//
//	        CommonEncryptionCencArgs{...}
//
//	or:
//
//	        nil
type CommonEncryptionCencPtrInput interface {
	pulumi.Input

	ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput
	ToCommonEncryptionCencPtrOutputWithContext(context.Context) CommonEncryptionCencPtrOutput
}

type commonEncryptionCencPtrType CommonEncryptionCencArgs

func CommonEncryptionCencPtr(v *CommonEncryptionCencArgs) CommonEncryptionCencPtrInput {
	return (*commonEncryptionCencPtrType)(v)
}

func (*commonEncryptionCencPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCenc)(nil)).Elem()
}

func (i *commonEncryptionCencPtrType) ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput {
	return i.ToCommonEncryptionCencPtrOutputWithContext(context.Background())
}

func (i *commonEncryptionCencPtrType) ToCommonEncryptionCencPtrOutputWithContext(ctx context.Context) CommonEncryptionCencPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommonEncryptionCencPtrOutput)
}

// Class for envelope encryption scheme
type CommonEncryptionCencOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCencOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCenc)(nil)).Elem()
}

func (o CommonEncryptionCencOutput) ToCommonEncryptionCencOutput() CommonEncryptionCencOutput {
	return o
}

func (o CommonEncryptionCencOutput) ToCommonEncryptionCencOutputWithContext(ctx context.Context) CommonEncryptionCencOutput {
	return o
}

func (o CommonEncryptionCencOutput) ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput {
	return o.ToCommonEncryptionCencPtrOutputWithContext(context.Background())
}

func (o CommonEncryptionCencOutput) ToCommonEncryptionCencPtrOutputWithContext(ctx context.Context) CommonEncryptionCencPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CommonEncryptionCenc) *CommonEncryptionCenc {
		return &v
	}).(CommonEncryptionCencPtrOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCencOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v CommonEncryptionCenc) []TrackSelection { return v.ClearTracks }).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCencOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCenc) *StreamingPolicyContentKeys { return v.ContentKeys }).(StreamingPolicyContentKeysPtrOutput)
}

// Configuration of DRMs for CommonEncryptionCenc encryption scheme
func (o CommonEncryptionCencOutput) Drm() CencDrmConfigurationPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCenc) *CencDrmConfiguration { return v.Drm }).(CencDrmConfigurationPtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCencOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v CommonEncryptionCenc) *EnabledProtocols { return v.EnabledProtocols }).(EnabledProtocolsPtrOutput)
}

type CommonEncryptionCencPtrOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCencPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCenc)(nil)).Elem()
}

func (o CommonEncryptionCencPtrOutput) ToCommonEncryptionCencPtrOutput() CommonEncryptionCencPtrOutput {
	return o
}

func (o CommonEncryptionCencPtrOutput) ToCommonEncryptionCencPtrOutputWithContext(ctx context.Context) CommonEncryptionCencPtrOutput {
	return o
}

func (o CommonEncryptionCencPtrOutput) Elem() CommonEncryptionCencOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) CommonEncryptionCenc {
		if v != nil {
			return *v
		}
		var ret CommonEncryptionCenc
		return ret
	}).(CommonEncryptionCencOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCencPtrOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) []TrackSelection {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCencPtrOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) *StreamingPolicyContentKeys {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysPtrOutput)
}

// Configuration of DRMs for CommonEncryptionCenc encryption scheme
func (o CommonEncryptionCencPtrOutput) Drm() CencDrmConfigurationPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) *CencDrmConfiguration {
		if v == nil {
			return nil
		}
		return v.Drm
	}).(CencDrmConfigurationPtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCencPtrOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCenc) *EnabledProtocols {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsPtrOutput)
}

// Class for envelope encryption scheme
type CommonEncryptionCencResponse struct {
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelectionResponse `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeysResponse `pulumi:"contentKeys"`
	// Configuration of DRMs for CommonEncryptionCenc encryption scheme
	Drm *CencDrmConfigurationResponse `pulumi:"drm"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocolsResponse `pulumi:"enabledProtocols"`
}

// Class for envelope encryption scheme
type CommonEncryptionCencResponseOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCencResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CommonEncryptionCencResponse)(nil)).Elem()
}

func (o CommonEncryptionCencResponseOutput) ToCommonEncryptionCencResponseOutput() CommonEncryptionCencResponseOutput {
	return o
}

func (o CommonEncryptionCencResponseOutput) ToCommonEncryptionCencResponseOutputWithContext(ctx context.Context) CommonEncryptionCencResponseOutput {
	return o
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCencResponseOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v CommonEncryptionCencResponse) []TrackSelectionResponse { return v.ClearTracks }).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCencResponseOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCencResponse) *StreamingPolicyContentKeysResponse { return v.ContentKeys }).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Configuration of DRMs for CommonEncryptionCenc encryption scheme
func (o CommonEncryptionCencResponseOutput) Drm() CencDrmConfigurationResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCencResponse) *CencDrmConfigurationResponse { return v.Drm }).(CencDrmConfigurationResponsePtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCencResponseOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v CommonEncryptionCencResponse) *EnabledProtocolsResponse { return v.EnabledProtocols }).(EnabledProtocolsResponsePtrOutput)
}

type CommonEncryptionCencResponsePtrOutput struct{ *pulumi.OutputState }

func (CommonEncryptionCencResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CommonEncryptionCencResponse)(nil)).Elem()
}

func (o CommonEncryptionCencResponsePtrOutput) ToCommonEncryptionCencResponsePtrOutput() CommonEncryptionCencResponsePtrOutput {
	return o
}

func (o CommonEncryptionCencResponsePtrOutput) ToCommonEncryptionCencResponsePtrOutputWithContext(ctx context.Context) CommonEncryptionCencResponsePtrOutput {
	return o
}

func (o CommonEncryptionCencResponsePtrOutput) Elem() CommonEncryptionCencResponseOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) CommonEncryptionCencResponse {
		if v != nil {
			return *v
		}
		var ret CommonEncryptionCencResponse
		return ret
	}).(CommonEncryptionCencResponseOutput)
}

// Representing which tracks should not be encrypted
func (o CommonEncryptionCencResponsePtrOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) []TrackSelectionResponse {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o CommonEncryptionCencResponsePtrOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) *StreamingPolicyContentKeysResponse {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Configuration of DRMs for CommonEncryptionCenc encryption scheme
func (o CommonEncryptionCencResponsePtrOutput) Drm() CencDrmConfigurationResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) *CencDrmConfigurationResponse {
		if v == nil {
			return nil
		}
		return v.Drm
	}).(CencDrmConfigurationResponsePtrOutput)
}

// Representing supported protocols
func (o CommonEncryptionCencResponsePtrOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v *CommonEncryptionCencResponse) *EnabledProtocolsResponse {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsResponsePtrOutput)
}

// Represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfiguration struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration'.
	OdataType string `pulumi:"odataType"`
}

// Represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfigurationResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration'.
	OdataType string `pulumi:"odataType"`
}

// Specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfiguration struct {
	// The key that must be used as FairPlay Application Secret key.
	Ask string `pulumi:"ask"`
	// The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
	FairPlayPfx string `pulumi:"fairPlayPfx"`
	// The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
	FairPlayPfxPassword string `pulumi:"fairPlayPfxPassword"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration'.
	OdataType string `pulumi:"odataType"`
	// Offline rental policy
	OfflineRentalConfiguration *ContentKeyPolicyFairPlayOfflineRentalConfiguration `pulumi:"offlineRentalConfiguration"`
	// The rental and lease key type.
	RentalAndLeaseKeyType string `pulumi:"rentalAndLeaseKeyType"`
	// The rental duration. Must be greater than or equal to 0.
	RentalDuration float64 `pulumi:"rentalDuration"`
}

// Specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfigurationResponse struct {
	// The key that must be used as FairPlay Application Secret key.
	Ask string `pulumi:"ask"`
	// The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
	FairPlayPfx string `pulumi:"fairPlayPfx"`
	// The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
	FairPlayPfxPassword string `pulumi:"fairPlayPfxPassword"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration'.
	OdataType string `pulumi:"odataType"`
	// Offline rental policy
	OfflineRentalConfiguration *ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse `pulumi:"offlineRentalConfiguration"`
	// The rental and lease key type.
	RentalAndLeaseKeyType string `pulumi:"rentalAndLeaseKeyType"`
	// The rental duration. Must be greater than or equal to 0.
	RentalDuration float64 `pulumi:"rentalDuration"`
}

type ContentKeyPolicyFairPlayOfflineRentalConfiguration struct {
	// Playback duration
	PlaybackDurationSeconds float64 `pulumi:"playbackDurationSeconds"`
	// Storage duration
	StorageDurationSeconds float64 `pulumi:"storageDurationSeconds"`
}

type ContentKeyPolicyFairPlayOfflineRentalConfigurationResponse struct {
	// Playback duration
	PlaybackDurationSeconds float64 `pulumi:"playbackDurationSeconds"`
	// Storage duration
	StorageDurationSeconds float64 `pulumi:"storageDurationSeconds"`
}

// Represents an open restriction. License or key will be delivered on every request.
type ContentKeyPolicyOpenRestriction struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyOpenRestriction'.
	OdataType string `pulumi:"odataType"`
}

// Represents an open restriction. License or key will be delivered on every request.
type ContentKeyPolicyOpenRestrictionResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyOpenRestriction'.
	OdataType string `pulumi:"odataType"`
}

// Represents a policy option.
type ContentKeyPolicyOption struct {
	// The key delivery configuration.
	Configuration interface{} `pulumi:"configuration"`
	// The Policy Option description.
	Name *string `pulumi:"name"`
	// The requirements that must be met to deliver keys with this configuration
	Restriction interface{} `pulumi:"restriction"`
}

// ContentKeyPolicyOptionInput is an input type that accepts ContentKeyPolicyOptionArgs and ContentKeyPolicyOptionOutput values.
// You can construct a concrete instance of `ContentKeyPolicyOptionInput` via:
//
//	ContentKeyPolicyOptionArgs{...}
type ContentKeyPolicyOptionInput interface {
	pulumi.Input

	ToContentKeyPolicyOptionOutput() ContentKeyPolicyOptionOutput
	ToContentKeyPolicyOptionOutputWithContext(context.Context) ContentKeyPolicyOptionOutput
}

// Represents a policy option.
type ContentKeyPolicyOptionArgs struct {
	// The key delivery configuration.
	Configuration pulumi.Input `pulumi:"configuration"`
	// The Policy Option description.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The requirements that must be met to deliver keys with this configuration
	Restriction pulumi.Input `pulumi:"restriction"`
}

func (ContentKeyPolicyOptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyOption)(nil)).Elem()
}

func (i ContentKeyPolicyOptionArgs) ToContentKeyPolicyOptionOutput() ContentKeyPolicyOptionOutput {
	return i.ToContentKeyPolicyOptionOutputWithContext(context.Background())
}

func (i ContentKeyPolicyOptionArgs) ToContentKeyPolicyOptionOutputWithContext(ctx context.Context) ContentKeyPolicyOptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyOptionOutput)
}

// ContentKeyPolicyOptionArrayInput is an input type that accepts ContentKeyPolicyOptionArray and ContentKeyPolicyOptionArrayOutput values.
// You can construct a concrete instance of `ContentKeyPolicyOptionArrayInput` via:
//
//	ContentKeyPolicyOptionArray{ ContentKeyPolicyOptionArgs{...} }
type ContentKeyPolicyOptionArrayInput interface {
	pulumi.Input

	ToContentKeyPolicyOptionArrayOutput() ContentKeyPolicyOptionArrayOutput
	ToContentKeyPolicyOptionArrayOutputWithContext(context.Context) ContentKeyPolicyOptionArrayOutput
}

type ContentKeyPolicyOptionArray []ContentKeyPolicyOptionInput

func (ContentKeyPolicyOptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyOption)(nil)).Elem()
}

func (i ContentKeyPolicyOptionArray) ToContentKeyPolicyOptionArrayOutput() ContentKeyPolicyOptionArrayOutput {
	return i.ToContentKeyPolicyOptionArrayOutputWithContext(context.Background())
}

func (i ContentKeyPolicyOptionArray) ToContentKeyPolicyOptionArrayOutputWithContext(ctx context.Context) ContentKeyPolicyOptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentKeyPolicyOptionArrayOutput)
}

// Represents a policy option.
type ContentKeyPolicyOptionOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyOption)(nil)).Elem()
}

func (o ContentKeyPolicyOptionOutput) ToContentKeyPolicyOptionOutput() ContentKeyPolicyOptionOutput {
	return o
}

func (o ContentKeyPolicyOptionOutput) ToContentKeyPolicyOptionOutputWithContext(ctx context.Context) ContentKeyPolicyOptionOutput {
	return o
}

// The key delivery configuration.
func (o ContentKeyPolicyOptionOutput) Configuration() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyOption) interface{} { return v.Configuration }).(pulumi.AnyOutput)
}

// The Policy Option description.
func (o ContentKeyPolicyOptionOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyOption) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The requirements that must be met to deliver keys with this configuration
func (o ContentKeyPolicyOptionOutput) Restriction() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyOption) interface{} { return v.Restriction }).(pulumi.AnyOutput)
}

type ContentKeyPolicyOptionArrayOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyOption)(nil)).Elem()
}

func (o ContentKeyPolicyOptionArrayOutput) ToContentKeyPolicyOptionArrayOutput() ContentKeyPolicyOptionArrayOutput {
	return o
}

func (o ContentKeyPolicyOptionArrayOutput) ToContentKeyPolicyOptionArrayOutputWithContext(ctx context.Context) ContentKeyPolicyOptionArrayOutput {
	return o
}

func (o ContentKeyPolicyOptionArrayOutput) Index(i pulumi.IntInput) ContentKeyPolicyOptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentKeyPolicyOption {
		return vs[0].([]ContentKeyPolicyOption)[vs[1].(int)]
	}).(ContentKeyPolicyOptionOutput)
}

// Represents a policy option.
type ContentKeyPolicyOptionResponse struct {
	// The key delivery configuration.
	Configuration interface{} `pulumi:"configuration"`
	// The Policy Option description.
	Name *string `pulumi:"name"`
	// The legacy Policy Option ID.
	PolicyOptionId string `pulumi:"policyOptionId"`
	// The requirements that must be met to deliver keys with this configuration
	Restriction interface{} `pulumi:"restriction"`
}

// Represents a policy option.
type ContentKeyPolicyOptionResponseOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentKeyPolicyOptionResponse)(nil)).Elem()
}

func (o ContentKeyPolicyOptionResponseOutput) ToContentKeyPolicyOptionResponseOutput() ContentKeyPolicyOptionResponseOutput {
	return o
}

func (o ContentKeyPolicyOptionResponseOutput) ToContentKeyPolicyOptionResponseOutputWithContext(ctx context.Context) ContentKeyPolicyOptionResponseOutput {
	return o
}

// The key delivery configuration.
func (o ContentKeyPolicyOptionResponseOutput) Configuration() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyOptionResponse) interface{} { return v.Configuration }).(pulumi.AnyOutput)
}

// The Policy Option description.
func (o ContentKeyPolicyOptionResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentKeyPolicyOptionResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The legacy Policy Option ID.
func (o ContentKeyPolicyOptionResponseOutput) PolicyOptionId() pulumi.StringOutput {
	return o.ApplyT(func(v ContentKeyPolicyOptionResponse) string { return v.PolicyOptionId }).(pulumi.StringOutput)
}

// The requirements that must be met to deliver keys with this configuration
func (o ContentKeyPolicyOptionResponseOutput) Restriction() pulumi.AnyOutput {
	return o.ApplyT(func(v ContentKeyPolicyOptionResponse) interface{} { return v.Restriction }).(pulumi.AnyOutput)
}

type ContentKeyPolicyOptionResponseArrayOutput struct{ *pulumi.OutputState }

func (ContentKeyPolicyOptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentKeyPolicyOptionResponse)(nil)).Elem()
}

func (o ContentKeyPolicyOptionResponseArrayOutput) ToContentKeyPolicyOptionResponseArrayOutput() ContentKeyPolicyOptionResponseArrayOutput {
	return o
}

func (o ContentKeyPolicyOptionResponseArrayOutput) ToContentKeyPolicyOptionResponseArrayOutputWithContext(ctx context.Context) ContentKeyPolicyOptionResponseArrayOutput {
	return o
}

func (o ContentKeyPolicyOptionResponseArrayOutput) Index(i pulumi.IntInput) ContentKeyPolicyOptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentKeyPolicyOptionResponse {
		return vs[0].([]ContentKeyPolicyOptionResponse)[vs[1].(int)]
	}).(ContentKeyPolicyOptionResponseOutput)
}

// Specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfiguration struct {
	// The PlayReady licenses.
	Licenses []ContentKeyPolicyPlayReadyLicense `pulumi:"licenses"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration'.
	OdataType string `pulumi:"odataType"`
	// The custom response data.
	ResponseCustomData *string `pulumi:"responseCustomData"`
}

// Specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfigurationResponse struct {
	// The PlayReady licenses.
	Licenses []ContentKeyPolicyPlayReadyLicenseResponse `pulumi:"licenses"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration'.
	OdataType string `pulumi:"odataType"`
	// The custom response data.
	ResponseCustomData *string `pulumi:"responseCustomData"`
}

// Specifies that the content key ID is in the PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader'.
	OdataType string `pulumi:"odataType"`
}

// Specifies that the content key ID is in the PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeaderResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader'.
	OdataType string `pulumi:"odataType"`
}

// Specifies that the content key ID is specified in the PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier struct {
	// The content key ID.
	KeyId string `pulumi:"keyId"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'.
	OdataType string `pulumi:"odataType"`
}

// Specifies that the content key ID is specified in the PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifierResponse struct {
	// The content key ID.
	KeyId string `pulumi:"keyId"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'.
	OdataType string `pulumi:"odataType"`
}

// Configures the Explicit Analog Television Output Restriction control bits. For further details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction struct {
	// Indicates whether this restriction is enforced on a Best Effort basis.
	BestEffort bool `pulumi:"bestEffort"`
	// Configures the restriction control bits. Must be between 0 and 3 inclusive.
	ConfigurationData int `pulumi:"configurationData"`
}

// Configures the Explicit Analog Television Output Restriction control bits. For further details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse struct {
	// Indicates whether this restriction is enforced on a Best Effort basis.
	BestEffort bool `pulumi:"bestEffort"`
	// Configures the restriction control bits. Must be between 0 and 3 inclusive.
	ConfigurationData int `pulumi:"configurationData"`
}

// The PlayReady license
type ContentKeyPolicyPlayReadyLicense struct {
	// A flag indicating whether test devices can use the license.
	AllowTestDevices bool `pulumi:"allowTestDevices"`
	// The begin date of license
	BeginDate *string `pulumi:"beginDate"`
	// The content key location.
	ContentKeyLocation interface{} `pulumi:"contentKeyLocation"`
	// The PlayReady content type.
	ContentType string `pulumi:"contentType"`
	// The expiration date of license.
	ExpirationDate *string `pulumi:"expirationDate"`
	// The grace period of license.
	GracePeriod *string `pulumi:"gracePeriod"`
	// The license type.
	LicenseType string `pulumi:"licenseType"`
	// The license PlayRight
	PlayRight *ContentKeyPolicyPlayReadyPlayRight `pulumi:"playRight"`
	// The relative begin date of license.
	RelativeBeginDate *string `pulumi:"relativeBeginDate"`
	// The relative expiration date of license.
	RelativeExpirationDate *string `pulumi:"relativeExpirationDate"`
}

// The PlayReady license
type ContentKeyPolicyPlayReadyLicenseResponse struct {
	// A flag indicating whether test devices can use the license.
	AllowTestDevices bool `pulumi:"allowTestDevices"`
	// The begin date of license
	BeginDate *string `pulumi:"beginDate"`
	// The content key location.
	ContentKeyLocation interface{} `pulumi:"contentKeyLocation"`
	// The PlayReady content type.
	ContentType string `pulumi:"contentType"`
	// The expiration date of license.
	ExpirationDate *string `pulumi:"expirationDate"`
	// The grace period of license.
	GracePeriod *string `pulumi:"gracePeriod"`
	// The license type.
	LicenseType string `pulumi:"licenseType"`
	// The license PlayRight
	PlayRight *ContentKeyPolicyPlayReadyPlayRightResponse `pulumi:"playRight"`
	// The relative begin date of license.
	RelativeBeginDate *string `pulumi:"relativeBeginDate"`
	// The relative expiration date of license.
	RelativeExpirationDate *string `pulumi:"relativeExpirationDate"`
}

// Configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRight struct {
	// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
	AgcAndColorStripeRestriction *int `pulumi:"agcAndColorStripeRestriction"`
	// Configures Unknown output handling settings of the license.
	AllowPassingVideoContentToUnknownOutput string `pulumi:"allowPassingVideoContentToUnknownOutput"`
	// Specifies the output protection level for compressed digital audio.
	AnalogVideoOpl *int `pulumi:"analogVideoOpl"`
	// Specifies the output protection level for compressed digital audio.
	CompressedDigitalAudioOpl *int `pulumi:"compressedDigitalAudioOpl"`
	// Specifies the output protection level for compressed digital video.
	CompressedDigitalVideoOpl *int `pulumi:"compressedDigitalVideoOpl"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	DigitalVideoOnlyContentRestriction bool `pulumi:"digitalVideoOnlyContentRestriction"`
	// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
	ExplicitAnalogTelevisionOutputRestriction *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction `pulumi:"explicitAnalogTelevisionOutputRestriction"`
	// The amount of time that the license is valid after the license is first used to play content.
	FirstPlayExpiration *string `pulumi:"firstPlayExpiration"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComponentVideoRestriction bool `pulumi:"imageConstraintForAnalogComponentVideoRestriction"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComputerMonitorRestriction bool `pulumi:"imageConstraintForAnalogComputerMonitorRestriction"`
	// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
	ScmsRestriction *int `pulumi:"scmsRestriction"`
	// Specifies the output protection level for uncompressed digital audio.
	UncompressedDigitalAudioOpl *int `pulumi:"uncompressedDigitalAudioOpl"`
	// Specifies the output protection level for uncompressed digital video.
	UncompressedDigitalVideoOpl *int `pulumi:"uncompressedDigitalVideoOpl"`
}

// Configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRightResponse struct {
	// Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
	AgcAndColorStripeRestriction *int `pulumi:"agcAndColorStripeRestriction"`
	// Configures Unknown output handling settings of the license.
	AllowPassingVideoContentToUnknownOutput string `pulumi:"allowPassingVideoContentToUnknownOutput"`
	// Specifies the output protection level for compressed digital audio.
	AnalogVideoOpl *int `pulumi:"analogVideoOpl"`
	// Specifies the output protection level for compressed digital audio.
	CompressedDigitalAudioOpl *int `pulumi:"compressedDigitalAudioOpl"`
	// Specifies the output protection level for compressed digital video.
	CompressedDigitalVideoOpl *int `pulumi:"compressedDigitalVideoOpl"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	DigitalVideoOnlyContentRestriction bool `pulumi:"digitalVideoOnlyContentRestriction"`
	// Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
	ExplicitAnalogTelevisionOutputRestriction *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestrictionResponse `pulumi:"explicitAnalogTelevisionOutputRestriction"`
	// The amount of time that the license is valid after the license is first used to play content.
	FirstPlayExpiration *string `pulumi:"firstPlayExpiration"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComponentVideoRestriction bool `pulumi:"imageConstraintForAnalogComponentVideoRestriction"`
	// Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComputerMonitorRestriction bool `pulumi:"imageConstraintForAnalogComputerMonitorRestriction"`
	// Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
	ScmsRestriction *int `pulumi:"scmsRestriction"`
	// Specifies the output protection level for uncompressed digital audio.
	UncompressedDigitalAudioOpl *int `pulumi:"uncompressedDigitalAudioOpl"`
	// Specifies the output protection level for uncompressed digital video.
	UncompressedDigitalVideoOpl *int `pulumi:"uncompressedDigitalVideoOpl"`
}

// Specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKey struct {
	// The RSA Parameter exponent
	Exponent string `pulumi:"exponent"`
	// The RSA Parameter modulus
	Modulus string `pulumi:"modulus"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyRsaTokenKey'.
	OdataType string `pulumi:"odataType"`
}

// Specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKeyResponse struct {
	// The RSA Parameter exponent
	Exponent string `pulumi:"exponent"`
	// The RSA Parameter modulus
	Modulus string `pulumi:"modulus"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyRsaTokenKey'.
	OdataType string `pulumi:"odataType"`
}

// Specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKey struct {
	// The key value of the key
	KeyValue string `pulumi:"keyValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicySymmetricTokenKey'.
	OdataType string `pulumi:"odataType"`
}

// Specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKeyResponse struct {
	// The key value of the key
	KeyValue string `pulumi:"keyValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicySymmetricTokenKey'.
	OdataType string `pulumi:"odataType"`
}

// Represents a token claim.
type ContentKeyPolicyTokenClaim struct {
	// Token claim type.
	ClaimType *string `pulumi:"claimType"`
	// Token claim value.
	ClaimValue *string `pulumi:"claimValue"`
}

// Represents a token claim.
type ContentKeyPolicyTokenClaimResponse struct {
	// Token claim type.
	ClaimType *string `pulumi:"claimType"`
	// Token claim value.
	ClaimValue *string `pulumi:"claimValue"`
}

// Represents a token restriction. Provided token must match these requirements for successful license or key delivery.
type ContentKeyPolicyTokenRestriction struct {
	// A list of alternative verification keys.
	AlternateVerificationKeys []interface{} `pulumi:"alternateVerificationKeys"`
	// The audience for the token.
	Audience string `pulumi:"audience"`
	// The token issuer.
	Issuer string `pulumi:"issuer"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyTokenRestriction'.
	OdataType string `pulumi:"odataType"`
	// The OpenID connect discovery document.
	OpenIdConnectDiscoveryDocument *string `pulumi:"openIdConnectDiscoveryDocument"`
	// The primary verification key.
	PrimaryVerificationKey interface{} `pulumi:"primaryVerificationKey"`
	// A list of required token claims.
	RequiredClaims []ContentKeyPolicyTokenClaim `pulumi:"requiredClaims"`
	// The type of token.
	RestrictionTokenType string `pulumi:"restrictionTokenType"`
}

// Represents a token restriction. Provided token must match these requirements for successful license or key delivery.
type ContentKeyPolicyTokenRestrictionResponse struct {
	// A list of alternative verification keys.
	AlternateVerificationKeys []interface{} `pulumi:"alternateVerificationKeys"`
	// The audience for the token.
	Audience string `pulumi:"audience"`
	// The token issuer.
	Issuer string `pulumi:"issuer"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyTokenRestriction'.
	OdataType string `pulumi:"odataType"`
	// The OpenID connect discovery document.
	OpenIdConnectDiscoveryDocument *string `pulumi:"openIdConnectDiscoveryDocument"`
	// The primary verification key.
	PrimaryVerificationKey interface{} `pulumi:"primaryVerificationKey"`
	// A list of required token claims.
	RequiredClaims []ContentKeyPolicyTokenClaimResponse `pulumi:"requiredClaims"`
	// The type of token.
	RestrictionTokenType string `pulumi:"restrictionTokenType"`
}

// Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.
type ContentKeyPolicyUnknownConfiguration struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownConfiguration'.
	OdataType string `pulumi:"odataType"`
}

// Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.
type ContentKeyPolicyUnknownConfigurationResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownConfiguration'.
	OdataType string `pulumi:"odataType"`
}

// Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
type ContentKeyPolicyUnknownRestriction struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownRestriction'.
	OdataType string `pulumi:"odataType"`
}

// Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
type ContentKeyPolicyUnknownRestrictionResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyUnknownRestriction'.
	OdataType string `pulumi:"odataType"`
}

// Specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfiguration struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyWidevineConfiguration'.
	OdataType string `pulumi:"odataType"`
	// The Widevine template.
	WidevineTemplate string `pulumi:"widevineTemplate"`
}

// Specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfigurationResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyWidevineConfiguration'.
	OdataType string `pulumi:"odataType"`
	// The Widevine template.
	WidevineTemplate string `pulumi:"widevineTemplate"`
}

// Specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKey struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey'.
	OdataType string `pulumi:"odataType"`
	// The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
	RawBody string `pulumi:"rawBody"`
}

// Specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKeyResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey'.
	OdataType string `pulumi:"odataType"`
	// The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
	RawBody string `pulumi:"rawBody"`
}

// A codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudio struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyAudio'.
	OdataType string `pulumi:"odataType"`
}

// A codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudioResponse struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyAudio'.
	OdataType string `pulumi:"odataType"`
}

// A codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideo struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyVideo'.
	OdataType string `pulumi:"odataType"`
}

// A codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideoResponse struct {
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.CopyVideo'.
	OdataType string `pulumi:"odataType"`
}

// The client access policy.
type CrossSiteAccessPolicies struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy *string `pulumi:"clientAccessPolicy"`
	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy *string `pulumi:"crossDomainPolicy"`
}

// CrossSiteAccessPoliciesInput is an input type that accepts CrossSiteAccessPoliciesArgs and CrossSiteAccessPoliciesOutput values.
// You can construct a concrete instance of `CrossSiteAccessPoliciesInput` via:
//
//	CrossSiteAccessPoliciesArgs{...}
type CrossSiteAccessPoliciesInput interface {
	pulumi.Input

	ToCrossSiteAccessPoliciesOutput() CrossSiteAccessPoliciesOutput
	ToCrossSiteAccessPoliciesOutputWithContext(context.Context) CrossSiteAccessPoliciesOutput
}

// The client access policy.
type CrossSiteAccessPoliciesArgs struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy pulumi.StringPtrInput `pulumi:"clientAccessPolicy"`
	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy pulumi.StringPtrInput `pulumi:"crossDomainPolicy"`
}

func (CrossSiteAccessPoliciesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossSiteAccessPolicies)(nil)).Elem()
}

func (i CrossSiteAccessPoliciesArgs) ToCrossSiteAccessPoliciesOutput() CrossSiteAccessPoliciesOutput {
	return i.ToCrossSiteAccessPoliciesOutputWithContext(context.Background())
}

func (i CrossSiteAccessPoliciesArgs) ToCrossSiteAccessPoliciesOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossSiteAccessPoliciesOutput)
}

func (i CrossSiteAccessPoliciesArgs) ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput {
	return i.ToCrossSiteAccessPoliciesPtrOutputWithContext(context.Background())
}

func (i CrossSiteAccessPoliciesArgs) ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossSiteAccessPoliciesOutput).ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx)
}

// CrossSiteAccessPoliciesPtrInput is an input type that accepts CrossSiteAccessPoliciesArgs, CrossSiteAccessPoliciesPtr and CrossSiteAccessPoliciesPtrOutput values.
// You can construct a concrete instance of `CrossSiteAccessPoliciesPtrInput` via:
//
//	        CrossSiteAccessPoliciesArgs{...}
//
//	or:
//
//	        nil
type CrossSiteAccessPoliciesPtrInput interface {
	pulumi.Input

	ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput
	ToCrossSiteAccessPoliciesPtrOutputWithContext(context.Context) CrossSiteAccessPoliciesPtrOutput
}

type crossSiteAccessPoliciesPtrType CrossSiteAccessPoliciesArgs

func CrossSiteAccessPoliciesPtr(v *CrossSiteAccessPoliciesArgs) CrossSiteAccessPoliciesPtrInput {
	return (*crossSiteAccessPoliciesPtrType)(v)
}

func (*crossSiteAccessPoliciesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CrossSiteAccessPolicies)(nil)).Elem()
}

func (i *crossSiteAccessPoliciesPtrType) ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput {
	return i.ToCrossSiteAccessPoliciesPtrOutputWithContext(context.Background())
}

func (i *crossSiteAccessPoliciesPtrType) ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossSiteAccessPoliciesPtrOutput)
}

// The client access policy.
type CrossSiteAccessPoliciesOutput struct{ *pulumi.OutputState }

func (CrossSiteAccessPoliciesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossSiteAccessPolicies)(nil)).Elem()
}

func (o CrossSiteAccessPoliciesOutput) ToCrossSiteAccessPoliciesOutput() CrossSiteAccessPoliciesOutput {
	return o
}

func (o CrossSiteAccessPoliciesOutput) ToCrossSiteAccessPoliciesOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesOutput {
	return o
}

func (o CrossSiteAccessPoliciesOutput) ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput {
	return o.ToCrossSiteAccessPoliciesPtrOutputWithContext(context.Background())
}

func (o CrossSiteAccessPoliciesOutput) ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CrossSiteAccessPolicies) *CrossSiteAccessPolicies {
		return &v
	}).(CrossSiteAccessPoliciesPtrOutput)
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o CrossSiteAccessPoliciesOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossSiteAccessPolicies) *string { return v.ClientAccessPolicy }).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o CrossSiteAccessPoliciesOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossSiteAccessPolicies) *string { return v.CrossDomainPolicy }).(pulumi.StringPtrOutput)
}

type CrossSiteAccessPoliciesPtrOutput struct{ *pulumi.OutputState }

func (CrossSiteAccessPoliciesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CrossSiteAccessPolicies)(nil)).Elem()
}

func (o CrossSiteAccessPoliciesPtrOutput) ToCrossSiteAccessPoliciesPtrOutput() CrossSiteAccessPoliciesPtrOutput {
	return o
}

func (o CrossSiteAccessPoliciesPtrOutput) ToCrossSiteAccessPoliciesPtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesPtrOutput {
	return o
}

func (o CrossSiteAccessPoliciesPtrOutput) Elem() CrossSiteAccessPoliciesOutput {
	return o.ApplyT(func(v *CrossSiteAccessPolicies) CrossSiteAccessPolicies {
		if v != nil {
			return *v
		}
		var ret CrossSiteAccessPolicies
		return ret
	}).(CrossSiteAccessPoliciesOutput)
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o CrossSiteAccessPoliciesPtrOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CrossSiteAccessPolicies) *string {
		if v == nil {
			return nil
		}
		return v.ClientAccessPolicy
	}).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o CrossSiteAccessPoliciesPtrOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CrossSiteAccessPolicies) *string {
		if v == nil {
			return nil
		}
		return v.CrossDomainPolicy
	}).(pulumi.StringPtrOutput)
}

// The client access policy.
type CrossSiteAccessPoliciesResponse struct {
	// The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy *string `pulumi:"clientAccessPolicy"`
	// The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy *string `pulumi:"crossDomainPolicy"`
}

// The client access policy.
type CrossSiteAccessPoliciesResponseOutput struct{ *pulumi.OutputState }

func (CrossSiteAccessPoliciesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossSiteAccessPoliciesResponse)(nil)).Elem()
}

func (o CrossSiteAccessPoliciesResponseOutput) ToCrossSiteAccessPoliciesResponseOutput() CrossSiteAccessPoliciesResponseOutput {
	return o
}

func (o CrossSiteAccessPoliciesResponseOutput) ToCrossSiteAccessPoliciesResponseOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesResponseOutput {
	return o
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o CrossSiteAccessPoliciesResponseOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossSiteAccessPoliciesResponse) *string { return v.ClientAccessPolicy }).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o CrossSiteAccessPoliciesResponseOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossSiteAccessPoliciesResponse) *string { return v.CrossDomainPolicy }).(pulumi.StringPtrOutput)
}

type CrossSiteAccessPoliciesResponsePtrOutput struct{ *pulumi.OutputState }

func (CrossSiteAccessPoliciesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CrossSiteAccessPoliciesResponse)(nil)).Elem()
}

func (o CrossSiteAccessPoliciesResponsePtrOutput) ToCrossSiteAccessPoliciesResponsePtrOutput() CrossSiteAccessPoliciesResponsePtrOutput {
	return o
}

func (o CrossSiteAccessPoliciesResponsePtrOutput) ToCrossSiteAccessPoliciesResponsePtrOutputWithContext(ctx context.Context) CrossSiteAccessPoliciesResponsePtrOutput {
	return o
}

func (o CrossSiteAccessPoliciesResponsePtrOutput) Elem() CrossSiteAccessPoliciesResponseOutput {
	return o.ApplyT(func(v *CrossSiteAccessPoliciesResponse) CrossSiteAccessPoliciesResponse {
		if v != nil {
			return *v
		}
		var ret CrossSiteAccessPoliciesResponse
		return ret
	}).(CrossSiteAccessPoliciesResponseOutput)
}

// The content of clientaccesspolicy.xml used by Silverlight.
func (o CrossSiteAccessPoliciesResponsePtrOutput) ClientAccessPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CrossSiteAccessPoliciesResponse) *string {
		if v == nil {
			return nil
		}
		return v.ClientAccessPolicy
	}).(pulumi.StringPtrOutput)
}

// The content of crossdomain.xml used by Silverlight.
func (o CrossSiteAccessPoliciesResponsePtrOutput) CrossDomainPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CrossSiteAccessPoliciesResponse) *string {
		if v == nil {
			return nil
		}
		return v.CrossDomainPolicy
	}).(pulumi.StringPtrOutput)
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKey struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `pulumi:"label"`
	// Policy used by Default Key
	PolicyName *string `pulumi:"policyName"`
}

// DefaultKeyInput is an input type that accepts DefaultKeyArgs and DefaultKeyOutput values.
// You can construct a concrete instance of `DefaultKeyInput` via:
//
//	DefaultKeyArgs{...}
type DefaultKeyInput interface {
	pulumi.Input

	ToDefaultKeyOutput() DefaultKeyOutput
	ToDefaultKeyOutputWithContext(context.Context) DefaultKeyOutput
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKeyArgs struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label pulumi.StringPtrInput `pulumi:"label"`
	// Policy used by Default Key
	PolicyName pulumi.StringPtrInput `pulumi:"policyName"`
}

func (DefaultKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DefaultKey)(nil)).Elem()
}

func (i DefaultKeyArgs) ToDefaultKeyOutput() DefaultKeyOutput {
	return i.ToDefaultKeyOutputWithContext(context.Background())
}

func (i DefaultKeyArgs) ToDefaultKeyOutputWithContext(ctx context.Context) DefaultKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DefaultKeyOutput)
}

func (i DefaultKeyArgs) ToDefaultKeyPtrOutput() DefaultKeyPtrOutput {
	return i.ToDefaultKeyPtrOutputWithContext(context.Background())
}

func (i DefaultKeyArgs) ToDefaultKeyPtrOutputWithContext(ctx context.Context) DefaultKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DefaultKeyOutput).ToDefaultKeyPtrOutputWithContext(ctx)
}

// DefaultKeyPtrInput is an input type that accepts DefaultKeyArgs, DefaultKeyPtr and DefaultKeyPtrOutput values.
// You can construct a concrete instance of `DefaultKeyPtrInput` via:
//
//	        DefaultKeyArgs{...}
//
//	or:
//
//	        nil
type DefaultKeyPtrInput interface {
	pulumi.Input

	ToDefaultKeyPtrOutput() DefaultKeyPtrOutput
	ToDefaultKeyPtrOutputWithContext(context.Context) DefaultKeyPtrOutput
}

type defaultKeyPtrType DefaultKeyArgs

func DefaultKeyPtr(v *DefaultKeyArgs) DefaultKeyPtrInput {
	return (*defaultKeyPtrType)(v)
}

func (*defaultKeyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DefaultKey)(nil)).Elem()
}

func (i *defaultKeyPtrType) ToDefaultKeyPtrOutput() DefaultKeyPtrOutput {
	return i.ToDefaultKeyPtrOutputWithContext(context.Background())
}

func (i *defaultKeyPtrType) ToDefaultKeyPtrOutputWithContext(ctx context.Context) DefaultKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DefaultKeyPtrOutput)
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKeyOutput struct{ *pulumi.OutputState }

func (DefaultKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DefaultKey)(nil)).Elem()
}

func (o DefaultKeyOutput) ToDefaultKeyOutput() DefaultKeyOutput {
	return o
}

func (o DefaultKeyOutput) ToDefaultKeyOutputWithContext(ctx context.Context) DefaultKeyOutput {
	return o
}

func (o DefaultKeyOutput) ToDefaultKeyPtrOutput() DefaultKeyPtrOutput {
	return o.ToDefaultKeyPtrOutputWithContext(context.Background())
}

func (o DefaultKeyOutput) ToDefaultKeyPtrOutputWithContext(ctx context.Context) DefaultKeyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DefaultKey) *DefaultKey {
		return &v
	}).(DefaultKeyPtrOutput)
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o DefaultKeyOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DefaultKey) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Policy used by Default Key
func (o DefaultKeyOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DefaultKey) *string { return v.PolicyName }).(pulumi.StringPtrOutput)
}

type DefaultKeyPtrOutput struct{ *pulumi.OutputState }

func (DefaultKeyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DefaultKey)(nil)).Elem()
}

func (o DefaultKeyPtrOutput) ToDefaultKeyPtrOutput() DefaultKeyPtrOutput {
	return o
}

func (o DefaultKeyPtrOutput) ToDefaultKeyPtrOutputWithContext(ctx context.Context) DefaultKeyPtrOutput {
	return o
}

func (o DefaultKeyPtrOutput) Elem() DefaultKeyOutput {
	return o.ApplyT(func(v *DefaultKey) DefaultKey {
		if v != nil {
			return *v
		}
		var ret DefaultKey
		return ret
	}).(DefaultKeyOutput)
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o DefaultKeyPtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DefaultKey) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// Policy used by Default Key
func (o DefaultKeyPtrOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DefaultKey) *string {
		if v == nil {
			return nil
		}
		return v.PolicyName
	}).(pulumi.StringPtrOutput)
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKeyResponse struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `pulumi:"label"`
	// Policy used by Default Key
	PolicyName *string `pulumi:"policyName"`
}

// Class to specify properties of default content key for each encryption scheme
type DefaultKeyResponseOutput struct{ *pulumi.OutputState }

func (DefaultKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DefaultKeyResponse)(nil)).Elem()
}

func (o DefaultKeyResponseOutput) ToDefaultKeyResponseOutput() DefaultKeyResponseOutput {
	return o
}

func (o DefaultKeyResponseOutput) ToDefaultKeyResponseOutputWithContext(ctx context.Context) DefaultKeyResponseOutput {
	return o
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o DefaultKeyResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DefaultKeyResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Policy used by Default Key
func (o DefaultKeyResponseOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DefaultKeyResponse) *string { return v.PolicyName }).(pulumi.StringPtrOutput)
}

type DefaultKeyResponsePtrOutput struct{ *pulumi.OutputState }

func (DefaultKeyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DefaultKeyResponse)(nil)).Elem()
}

func (o DefaultKeyResponsePtrOutput) ToDefaultKeyResponsePtrOutput() DefaultKeyResponsePtrOutput {
	return o
}

func (o DefaultKeyResponsePtrOutput) ToDefaultKeyResponsePtrOutputWithContext(ctx context.Context) DefaultKeyResponsePtrOutput {
	return o
}

func (o DefaultKeyResponsePtrOutput) Elem() DefaultKeyResponseOutput {
	return o.ApplyT(func(v *DefaultKeyResponse) DefaultKeyResponse {
		if v != nil {
			return *v
		}
		var ret DefaultKeyResponse
		return ret
	}).(DefaultKeyResponseOutput)
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o DefaultKeyResponsePtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DefaultKeyResponse) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// Policy used by Default Key
func (o DefaultKeyResponsePtrOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DefaultKeyResponse) *string {
		if v == nil {
			return nil
		}
		return v.PolicyName
	}).(pulumi.StringPtrOutput)
}

// Describes the de-interlacing settings.
type Deinterlace struct {
	// The deinterlacing mode. Defaults to AutoPixelAdaptive.
	Mode *string `pulumi:"mode"`
	// The field parity for de-interlacing, defaults to Auto.
	Parity *string `pulumi:"parity"`
}

// Describes the de-interlacing settings.
type DeinterlaceResponse struct {
	// The deinterlacing mode. Defaults to AutoPixelAdaptive.
	Mode *string `pulumi:"mode"`
	// The field parity for de-interlacing, defaults to Auto.
	Parity *string `pulumi:"parity"`
}

type EdgeUsageDataCollectionPolicyResponse struct {
	// Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataCollectionFrequency *string `pulumi:"dataCollectionFrequency"`
	// Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataReportingFrequency *string `pulumi:"dataReportingFrequency"`
	// Details of Event Hub where the usage will be reported.
	EventHubDetails *EdgeUsageDataEventHubResponse `pulumi:"eventHubDetails"`
	// Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
	MaxAllowedUnreportedUsageDuration *string `pulumi:"maxAllowedUnreportedUsageDuration"`
}

type EdgeUsageDataCollectionPolicyResponseOutput struct{ *pulumi.OutputState }

func (EdgeUsageDataCollectionPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EdgeUsageDataCollectionPolicyResponse)(nil)).Elem()
}

func (o EdgeUsageDataCollectionPolicyResponseOutput) ToEdgeUsageDataCollectionPolicyResponseOutput() EdgeUsageDataCollectionPolicyResponseOutput {
	return o
}

func (o EdgeUsageDataCollectionPolicyResponseOutput) ToEdgeUsageDataCollectionPolicyResponseOutputWithContext(ctx context.Context) EdgeUsageDataCollectionPolicyResponseOutput {
	return o
}

// Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
func (o EdgeUsageDataCollectionPolicyResponseOutput) DataCollectionFrequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataCollectionPolicyResponse) *string { return v.DataCollectionFrequency }).(pulumi.StringPtrOutput)
}

// Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
func (o EdgeUsageDataCollectionPolicyResponseOutput) DataReportingFrequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataCollectionPolicyResponse) *string { return v.DataReportingFrequency }).(pulumi.StringPtrOutput)
}

// Details of Event Hub where the usage will be reported.
func (o EdgeUsageDataCollectionPolicyResponseOutput) EventHubDetails() EdgeUsageDataEventHubResponsePtrOutput {
	return o.ApplyT(func(v EdgeUsageDataCollectionPolicyResponse) *EdgeUsageDataEventHubResponse { return v.EventHubDetails }).(EdgeUsageDataEventHubResponsePtrOutput)
}

// Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
func (o EdgeUsageDataCollectionPolicyResponseOutput) MaxAllowedUnreportedUsageDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataCollectionPolicyResponse) *string { return v.MaxAllowedUnreportedUsageDuration }).(pulumi.StringPtrOutput)
}

type EdgeUsageDataCollectionPolicyResponsePtrOutput struct{ *pulumi.OutputState }

func (EdgeUsageDataCollectionPolicyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EdgeUsageDataCollectionPolicyResponse)(nil)).Elem()
}

func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) ToEdgeUsageDataCollectionPolicyResponsePtrOutput() EdgeUsageDataCollectionPolicyResponsePtrOutput {
	return o
}

func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) ToEdgeUsageDataCollectionPolicyResponsePtrOutputWithContext(ctx context.Context) EdgeUsageDataCollectionPolicyResponsePtrOutput {
	return o
}

func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) Elem() EdgeUsageDataCollectionPolicyResponseOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) EdgeUsageDataCollectionPolicyResponse {
		if v != nil {
			return *v
		}
		var ret EdgeUsageDataCollectionPolicyResponse
		return ret
	}).(EdgeUsageDataCollectionPolicyResponseOutput)
}

// Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) DataCollectionFrequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.DataCollectionFrequency
	}).(pulumi.StringPtrOutput)
}

// Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) DataReportingFrequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.DataReportingFrequency
	}).(pulumi.StringPtrOutput)
}

// Details of Event Hub where the usage will be reported.
func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) EventHubDetails() EdgeUsageDataEventHubResponsePtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) *EdgeUsageDataEventHubResponse {
		if v == nil {
			return nil
		}
		return v.EventHubDetails
	}).(EdgeUsageDataEventHubResponsePtrOutput)
}

// Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
func (o EdgeUsageDataCollectionPolicyResponsePtrOutput) MaxAllowedUnreportedUsageDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataCollectionPolicyResponse) *string {
		if v == nil {
			return nil
		}
		return v.MaxAllowedUnreportedUsageDuration
	}).(pulumi.StringPtrOutput)
}

type EdgeUsageDataEventHubResponse struct {
	// Name of the Event Hub where usage will be reported.
	Name *string `pulumi:"name"`
	// Namespace of the Event Hub where usage will be reported.
	Namespace *string `pulumi:"namespace"`
	// SAS token needed to interact with Event Hub.
	Token *string `pulumi:"token"`
}

type EdgeUsageDataEventHubResponseOutput struct{ *pulumi.OutputState }

func (EdgeUsageDataEventHubResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EdgeUsageDataEventHubResponse)(nil)).Elem()
}

func (o EdgeUsageDataEventHubResponseOutput) ToEdgeUsageDataEventHubResponseOutput() EdgeUsageDataEventHubResponseOutput {
	return o
}

func (o EdgeUsageDataEventHubResponseOutput) ToEdgeUsageDataEventHubResponseOutputWithContext(ctx context.Context) EdgeUsageDataEventHubResponseOutput {
	return o
}

// Name of the Event Hub where usage will be reported.
func (o EdgeUsageDataEventHubResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataEventHubResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the Event Hub where usage will be reported.
func (o EdgeUsageDataEventHubResponseOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataEventHubResponse) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SAS token needed to interact with Event Hub.
func (o EdgeUsageDataEventHubResponseOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EdgeUsageDataEventHubResponse) *string { return v.Token }).(pulumi.StringPtrOutput)
}

type EdgeUsageDataEventHubResponsePtrOutput struct{ *pulumi.OutputState }

func (EdgeUsageDataEventHubResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EdgeUsageDataEventHubResponse)(nil)).Elem()
}

func (o EdgeUsageDataEventHubResponsePtrOutput) ToEdgeUsageDataEventHubResponsePtrOutput() EdgeUsageDataEventHubResponsePtrOutput {
	return o
}

func (o EdgeUsageDataEventHubResponsePtrOutput) ToEdgeUsageDataEventHubResponsePtrOutputWithContext(ctx context.Context) EdgeUsageDataEventHubResponsePtrOutput {
	return o
}

func (o EdgeUsageDataEventHubResponsePtrOutput) Elem() EdgeUsageDataEventHubResponseOutput {
	return o.ApplyT(func(v *EdgeUsageDataEventHubResponse) EdgeUsageDataEventHubResponse {
		if v != nil {
			return *v
		}
		var ret EdgeUsageDataEventHubResponse
		return ret
	}).(EdgeUsageDataEventHubResponseOutput)
}

// Name of the Event Hub where usage will be reported.
func (o EdgeUsageDataEventHubResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataEventHubResponse) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the Event Hub where usage will be reported.
func (o EdgeUsageDataEventHubResponsePtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataEventHubResponse) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// SAS token needed to interact with Event Hub.
func (o EdgeUsageDataEventHubResponsePtrOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EdgeUsageDataEventHubResponse) *string {
		if v == nil {
			return nil
		}
		return v.Token
	}).(pulumi.StringPtrOutput)
}

// Class to specify which protocols are enabled
type EnabledProtocols struct {
	// Enable DASH protocol or not
	Dash bool `pulumi:"dash"`
	// Enable Download protocol or not
	Download bool `pulumi:"download"`
	// Enable HLS protocol or not
	Hls bool `pulumi:"hls"`
	// Enable SmoothStreaming protocol or not
	SmoothStreaming bool `pulumi:"smoothStreaming"`
}

// EnabledProtocolsInput is an input type that accepts EnabledProtocolsArgs and EnabledProtocolsOutput values.
// You can construct a concrete instance of `EnabledProtocolsInput` via:
//
//	EnabledProtocolsArgs{...}
type EnabledProtocolsInput interface {
	pulumi.Input

	ToEnabledProtocolsOutput() EnabledProtocolsOutput
	ToEnabledProtocolsOutputWithContext(context.Context) EnabledProtocolsOutput
}

// Class to specify which protocols are enabled
type EnabledProtocolsArgs struct {
	// Enable DASH protocol or not
	Dash pulumi.BoolInput `pulumi:"dash"`
	// Enable Download protocol or not
	Download pulumi.BoolInput `pulumi:"download"`
	// Enable HLS protocol or not
	Hls pulumi.BoolInput `pulumi:"hls"`
	// Enable SmoothStreaming protocol or not
	SmoothStreaming pulumi.BoolInput `pulumi:"smoothStreaming"`
}

func (EnabledProtocolsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnabledProtocols)(nil)).Elem()
}

func (i EnabledProtocolsArgs) ToEnabledProtocolsOutput() EnabledProtocolsOutput {
	return i.ToEnabledProtocolsOutputWithContext(context.Background())
}

func (i EnabledProtocolsArgs) ToEnabledProtocolsOutputWithContext(ctx context.Context) EnabledProtocolsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnabledProtocolsOutput)
}

func (i EnabledProtocolsArgs) ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput {
	return i.ToEnabledProtocolsPtrOutputWithContext(context.Background())
}

func (i EnabledProtocolsArgs) ToEnabledProtocolsPtrOutputWithContext(ctx context.Context) EnabledProtocolsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnabledProtocolsOutput).ToEnabledProtocolsPtrOutputWithContext(ctx)
}

// EnabledProtocolsPtrInput is an input type that accepts EnabledProtocolsArgs, EnabledProtocolsPtr and EnabledProtocolsPtrOutput values.
// You can construct a concrete instance of `EnabledProtocolsPtrInput` via:
//
//	        EnabledProtocolsArgs{...}
//
//	or:
//
//	        nil
type EnabledProtocolsPtrInput interface {
	pulumi.Input

	ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput
	ToEnabledProtocolsPtrOutputWithContext(context.Context) EnabledProtocolsPtrOutput
}

type enabledProtocolsPtrType EnabledProtocolsArgs

func EnabledProtocolsPtr(v *EnabledProtocolsArgs) EnabledProtocolsPtrInput {
	return (*enabledProtocolsPtrType)(v)
}

func (*enabledProtocolsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EnabledProtocols)(nil)).Elem()
}

func (i *enabledProtocolsPtrType) ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput {
	return i.ToEnabledProtocolsPtrOutputWithContext(context.Background())
}

func (i *enabledProtocolsPtrType) ToEnabledProtocolsPtrOutputWithContext(ctx context.Context) EnabledProtocolsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnabledProtocolsPtrOutput)
}

// Class to specify which protocols are enabled
type EnabledProtocolsOutput struct{ *pulumi.OutputState }

func (EnabledProtocolsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnabledProtocols)(nil)).Elem()
}

func (o EnabledProtocolsOutput) ToEnabledProtocolsOutput() EnabledProtocolsOutput {
	return o
}

func (o EnabledProtocolsOutput) ToEnabledProtocolsOutputWithContext(ctx context.Context) EnabledProtocolsOutput {
	return o
}

func (o EnabledProtocolsOutput) ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput {
	return o.ToEnabledProtocolsPtrOutputWithContext(context.Background())
}

func (o EnabledProtocolsOutput) ToEnabledProtocolsPtrOutputWithContext(ctx context.Context) EnabledProtocolsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EnabledProtocols) *EnabledProtocols {
		return &v
	}).(EnabledProtocolsPtrOutput)
}

// Enable DASH protocol or not
func (o EnabledProtocolsOutput) Dash() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocols) bool { return v.Dash }).(pulumi.BoolOutput)
}

// Enable Download protocol or not
func (o EnabledProtocolsOutput) Download() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocols) bool { return v.Download }).(pulumi.BoolOutput)
}

// Enable HLS protocol or not
func (o EnabledProtocolsOutput) Hls() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocols) bool { return v.Hls }).(pulumi.BoolOutput)
}

// Enable SmoothStreaming protocol or not
func (o EnabledProtocolsOutput) SmoothStreaming() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocols) bool { return v.SmoothStreaming }).(pulumi.BoolOutput)
}

type EnabledProtocolsPtrOutput struct{ *pulumi.OutputState }

func (EnabledProtocolsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnabledProtocols)(nil)).Elem()
}

func (o EnabledProtocolsPtrOutput) ToEnabledProtocolsPtrOutput() EnabledProtocolsPtrOutput {
	return o
}

func (o EnabledProtocolsPtrOutput) ToEnabledProtocolsPtrOutputWithContext(ctx context.Context) EnabledProtocolsPtrOutput {
	return o
}

func (o EnabledProtocolsPtrOutput) Elem() EnabledProtocolsOutput {
	return o.ApplyT(func(v *EnabledProtocols) EnabledProtocols {
		if v != nil {
			return *v
		}
		var ret EnabledProtocols
		return ret
	}).(EnabledProtocolsOutput)
}

// Enable DASH protocol or not
func (o EnabledProtocolsPtrOutput) Dash() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocols) *bool {
		if v == nil {
			return nil
		}
		return &v.Dash
	}).(pulumi.BoolPtrOutput)
}

// Enable Download protocol or not
func (o EnabledProtocolsPtrOutput) Download() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocols) *bool {
		if v == nil {
			return nil
		}
		return &v.Download
	}).(pulumi.BoolPtrOutput)
}

// Enable HLS protocol or not
func (o EnabledProtocolsPtrOutput) Hls() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocols) *bool {
		if v == nil {
			return nil
		}
		return &v.Hls
	}).(pulumi.BoolPtrOutput)
}

// Enable SmoothStreaming protocol or not
func (o EnabledProtocolsPtrOutput) SmoothStreaming() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocols) *bool {
		if v == nil {
			return nil
		}
		return &v.SmoothStreaming
	}).(pulumi.BoolPtrOutput)
}

// Class to specify which protocols are enabled
type EnabledProtocolsResponse struct {
	// Enable DASH protocol or not
	Dash bool `pulumi:"dash"`
	// Enable Download protocol or not
	Download bool `pulumi:"download"`
	// Enable HLS protocol or not
	Hls bool `pulumi:"hls"`
	// Enable SmoothStreaming protocol or not
	SmoothStreaming bool `pulumi:"smoothStreaming"`
}

// Class to specify which protocols are enabled
type EnabledProtocolsResponseOutput struct{ *pulumi.OutputState }

func (EnabledProtocolsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnabledProtocolsResponse)(nil)).Elem()
}

func (o EnabledProtocolsResponseOutput) ToEnabledProtocolsResponseOutput() EnabledProtocolsResponseOutput {
	return o
}

func (o EnabledProtocolsResponseOutput) ToEnabledProtocolsResponseOutputWithContext(ctx context.Context) EnabledProtocolsResponseOutput {
	return o
}

// Enable DASH protocol or not
func (o EnabledProtocolsResponseOutput) Dash() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocolsResponse) bool { return v.Dash }).(pulumi.BoolOutput)
}

// Enable Download protocol or not
func (o EnabledProtocolsResponseOutput) Download() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocolsResponse) bool { return v.Download }).(pulumi.BoolOutput)
}

// Enable HLS protocol or not
func (o EnabledProtocolsResponseOutput) Hls() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocolsResponse) bool { return v.Hls }).(pulumi.BoolOutput)
}

// Enable SmoothStreaming protocol or not
func (o EnabledProtocolsResponseOutput) SmoothStreaming() pulumi.BoolOutput {
	return o.ApplyT(func(v EnabledProtocolsResponse) bool { return v.SmoothStreaming }).(pulumi.BoolOutput)
}

type EnabledProtocolsResponsePtrOutput struct{ *pulumi.OutputState }

func (EnabledProtocolsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnabledProtocolsResponse)(nil)).Elem()
}

func (o EnabledProtocolsResponsePtrOutput) ToEnabledProtocolsResponsePtrOutput() EnabledProtocolsResponsePtrOutput {
	return o
}

func (o EnabledProtocolsResponsePtrOutput) ToEnabledProtocolsResponsePtrOutputWithContext(ctx context.Context) EnabledProtocolsResponsePtrOutput {
	return o
}

func (o EnabledProtocolsResponsePtrOutput) Elem() EnabledProtocolsResponseOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) EnabledProtocolsResponse {
		if v != nil {
			return *v
		}
		var ret EnabledProtocolsResponse
		return ret
	}).(EnabledProtocolsResponseOutput)
}

// Enable DASH protocol or not
func (o EnabledProtocolsResponsePtrOutput) Dash() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.Dash
	}).(pulumi.BoolPtrOutput)
}

// Enable Download protocol or not
func (o EnabledProtocolsResponsePtrOutput) Download() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.Download
	}).(pulumi.BoolPtrOutput)
}

// Enable HLS protocol or not
func (o EnabledProtocolsResponsePtrOutput) Hls() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.Hls
	}).(pulumi.BoolPtrOutput)
}

// Enable SmoothStreaming protocol or not
func (o EnabledProtocolsResponsePtrOutput) SmoothStreaming() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EnabledProtocolsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.SmoothStreaming
	}).(pulumi.BoolPtrOutput)
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryption struct {
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelection `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `pulumi:"contentKeys"`
	// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomKeyAcquisitionUrlTemplate *string `pulumi:"customKeyAcquisitionUrlTemplate"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `pulumi:"enabledProtocols"`
}

// EnvelopeEncryptionInput is an input type that accepts EnvelopeEncryptionArgs and EnvelopeEncryptionOutput values.
// You can construct a concrete instance of `EnvelopeEncryptionInput` via:
//
//	EnvelopeEncryptionArgs{...}
type EnvelopeEncryptionInput interface {
	pulumi.Input

	ToEnvelopeEncryptionOutput() EnvelopeEncryptionOutput
	ToEnvelopeEncryptionOutputWithContext(context.Context) EnvelopeEncryptionOutput
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryptionArgs struct {
	// Representing which tracks should not be encrypted
	ClearTracks TrackSelectionArrayInput `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys StreamingPolicyContentKeysPtrInput `pulumi:"contentKeys"`
	// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomKeyAcquisitionUrlTemplate pulumi.StringPtrInput `pulumi:"customKeyAcquisitionUrlTemplate"`
	// Representing supported protocols
	EnabledProtocols EnabledProtocolsPtrInput `pulumi:"enabledProtocols"`
}

func (EnvelopeEncryptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvelopeEncryption)(nil)).Elem()
}

func (i EnvelopeEncryptionArgs) ToEnvelopeEncryptionOutput() EnvelopeEncryptionOutput {
	return i.ToEnvelopeEncryptionOutputWithContext(context.Background())
}

func (i EnvelopeEncryptionArgs) ToEnvelopeEncryptionOutputWithContext(ctx context.Context) EnvelopeEncryptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvelopeEncryptionOutput)
}

func (i EnvelopeEncryptionArgs) ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput {
	return i.ToEnvelopeEncryptionPtrOutputWithContext(context.Background())
}

func (i EnvelopeEncryptionArgs) ToEnvelopeEncryptionPtrOutputWithContext(ctx context.Context) EnvelopeEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvelopeEncryptionOutput).ToEnvelopeEncryptionPtrOutputWithContext(ctx)
}

// EnvelopeEncryptionPtrInput is an input type that accepts EnvelopeEncryptionArgs, EnvelopeEncryptionPtr and EnvelopeEncryptionPtrOutput values.
// You can construct a concrete instance of `EnvelopeEncryptionPtrInput` via:
//
//	        EnvelopeEncryptionArgs{...}
//
//	or:
//
//	        nil
type EnvelopeEncryptionPtrInput interface {
	pulumi.Input

	ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput
	ToEnvelopeEncryptionPtrOutputWithContext(context.Context) EnvelopeEncryptionPtrOutput
}

type envelopeEncryptionPtrType EnvelopeEncryptionArgs

func EnvelopeEncryptionPtr(v *EnvelopeEncryptionArgs) EnvelopeEncryptionPtrInput {
	return (*envelopeEncryptionPtrType)(v)
}

func (*envelopeEncryptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvelopeEncryption)(nil)).Elem()
}

func (i *envelopeEncryptionPtrType) ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput {
	return i.ToEnvelopeEncryptionPtrOutputWithContext(context.Background())
}

func (i *envelopeEncryptionPtrType) ToEnvelopeEncryptionPtrOutputWithContext(ctx context.Context) EnvelopeEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvelopeEncryptionPtrOutput)
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryptionOutput struct{ *pulumi.OutputState }

func (EnvelopeEncryptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvelopeEncryption)(nil)).Elem()
}

func (o EnvelopeEncryptionOutput) ToEnvelopeEncryptionOutput() EnvelopeEncryptionOutput {
	return o
}

func (o EnvelopeEncryptionOutput) ToEnvelopeEncryptionOutputWithContext(ctx context.Context) EnvelopeEncryptionOutput {
	return o
}

func (o EnvelopeEncryptionOutput) ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput {
	return o.ToEnvelopeEncryptionPtrOutputWithContext(context.Background())
}

func (o EnvelopeEncryptionOutput) ToEnvelopeEncryptionPtrOutputWithContext(ctx context.Context) EnvelopeEncryptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EnvelopeEncryption) *EnvelopeEncryption {
		return &v
	}).(EnvelopeEncryptionPtrOutput)
}

// Representing which tracks should not be encrypted
func (o EnvelopeEncryptionOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v EnvelopeEncryption) []TrackSelection { return v.ClearTracks }).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o EnvelopeEncryptionOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v EnvelopeEncryption) *StreamingPolicyContentKeys { return v.ContentKeys }).(StreamingPolicyContentKeysPtrOutput)
}

// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o EnvelopeEncryptionOutput) CustomKeyAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvelopeEncryption) *string { return v.CustomKeyAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

// Representing supported protocols
func (o EnvelopeEncryptionOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v EnvelopeEncryption) *EnabledProtocols { return v.EnabledProtocols }).(EnabledProtocolsPtrOutput)
}

type EnvelopeEncryptionPtrOutput struct{ *pulumi.OutputState }

func (EnvelopeEncryptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvelopeEncryption)(nil)).Elem()
}

func (o EnvelopeEncryptionPtrOutput) ToEnvelopeEncryptionPtrOutput() EnvelopeEncryptionPtrOutput {
	return o
}

func (o EnvelopeEncryptionPtrOutput) ToEnvelopeEncryptionPtrOutputWithContext(ctx context.Context) EnvelopeEncryptionPtrOutput {
	return o
}

func (o EnvelopeEncryptionPtrOutput) Elem() EnvelopeEncryptionOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) EnvelopeEncryption {
		if v != nil {
			return *v
		}
		var ret EnvelopeEncryption
		return ret
	}).(EnvelopeEncryptionOutput)
}

// Representing which tracks should not be encrypted
func (o EnvelopeEncryptionPtrOutput) ClearTracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) []TrackSelection {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o EnvelopeEncryptionPtrOutput) ContentKeys() StreamingPolicyContentKeysPtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) *StreamingPolicyContentKeys {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysPtrOutput)
}

// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o EnvelopeEncryptionPtrOutput) CustomKeyAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) *string {
		if v == nil {
			return nil
		}
		return v.CustomKeyAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Representing supported protocols
func (o EnvelopeEncryptionPtrOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryption) *EnabledProtocols {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsPtrOutput)
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryptionResponse struct {
	// Representing which tracks should not be encrypted
	ClearTracks []TrackSelectionResponse `pulumi:"clearTracks"`
	// Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeysResponse `pulumi:"contentKeys"`
	// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomKeyAcquisitionUrlTemplate *string `pulumi:"customKeyAcquisitionUrlTemplate"`
	// Representing supported protocols
	EnabledProtocols *EnabledProtocolsResponse `pulumi:"enabledProtocols"`
}

// Class for EnvelopeEncryption encryption scheme
type EnvelopeEncryptionResponseOutput struct{ *pulumi.OutputState }

func (EnvelopeEncryptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvelopeEncryptionResponse)(nil)).Elem()
}

func (o EnvelopeEncryptionResponseOutput) ToEnvelopeEncryptionResponseOutput() EnvelopeEncryptionResponseOutput {
	return o
}

func (o EnvelopeEncryptionResponseOutput) ToEnvelopeEncryptionResponseOutputWithContext(ctx context.Context) EnvelopeEncryptionResponseOutput {
	return o
}

// Representing which tracks should not be encrypted
func (o EnvelopeEncryptionResponseOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v EnvelopeEncryptionResponse) []TrackSelectionResponse { return v.ClearTracks }).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o EnvelopeEncryptionResponseOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v EnvelopeEncryptionResponse) *StreamingPolicyContentKeysResponse { return v.ContentKeys }).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o EnvelopeEncryptionResponseOutput) CustomKeyAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvelopeEncryptionResponse) *string { return v.CustomKeyAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

// Representing supported protocols
func (o EnvelopeEncryptionResponseOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v EnvelopeEncryptionResponse) *EnabledProtocolsResponse { return v.EnabledProtocols }).(EnabledProtocolsResponsePtrOutput)
}

type EnvelopeEncryptionResponsePtrOutput struct{ *pulumi.OutputState }

func (EnvelopeEncryptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvelopeEncryptionResponse)(nil)).Elem()
}

func (o EnvelopeEncryptionResponsePtrOutput) ToEnvelopeEncryptionResponsePtrOutput() EnvelopeEncryptionResponsePtrOutput {
	return o
}

func (o EnvelopeEncryptionResponsePtrOutput) ToEnvelopeEncryptionResponsePtrOutputWithContext(ctx context.Context) EnvelopeEncryptionResponsePtrOutput {
	return o
}

func (o EnvelopeEncryptionResponsePtrOutput) Elem() EnvelopeEncryptionResponseOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) EnvelopeEncryptionResponse {
		if v != nil {
			return *v
		}
		var ret EnvelopeEncryptionResponse
		return ret
	}).(EnvelopeEncryptionResponseOutput)
}

// Representing which tracks should not be encrypted
func (o EnvelopeEncryptionResponsePtrOutput) ClearTracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) []TrackSelectionResponse {
		if v == nil {
			return nil
		}
		return v.ClearTracks
	}).(TrackSelectionResponseArrayOutput)
}

// Representing default content key for each encryption scheme and separate content keys for specific tracks
func (o EnvelopeEncryptionResponsePtrOutput) ContentKeys() StreamingPolicyContentKeysResponsePtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) *StreamingPolicyContentKeysResponse {
		if v == nil {
			return nil
		}
		return v.ContentKeys
	}).(StreamingPolicyContentKeysResponsePtrOutput)
}

// Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o EnvelopeEncryptionResponsePtrOutput) CustomKeyAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomKeyAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Representing supported protocols
func (o EnvelopeEncryptionResponsePtrOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v *EnvelopeEncryptionResponse) *EnabledProtocolsResponse {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsResponsePtrOutput)
}

// Describes all the settings to be used when analyzing a video in order to detect (and optionally redact) all the faces present.
type FaceDetectorPreset struct {
	// Blur type
	BlurType *string `pulumi:"blurType"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking appearances of faces throughout the video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FaceDetectorPreset'.
	OdataType string `pulumi:"odataType"`
	// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
	Resolution *string `pulumi:"resolution"`
}

// Describes all the settings to be used when analyzing a video in order to detect (and optionally redact) all the faces present.
type FaceDetectorPresetResponse struct {
	// Blur type
	BlurType *string `pulumi:"blurType"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// This mode provides the ability to choose between the following settings: 1) Analyze - For detection only.This mode generates a metadata JSON file marking appearances of faces throughout the video.Where possible, appearances of the same person are assigned the same ID. 2) Combined - Additionally redacts(blurs) detected faces. 3) Redact - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces.It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FaceDetectorPreset'.
	OdataType string `pulumi:"odataType"`
	// Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected.
	Resolution *string `pulumi:"resolution"`
}

// The class to specify one track property condition.
type FilterTrackPropertyCondition struct {
	// The track property condition operation.
	Operation string `pulumi:"operation"`
	// The track property type.
	Property string `pulumi:"property"`
	// The track property value.
	Value string `pulumi:"value"`
}

// FilterTrackPropertyConditionInput is an input type that accepts FilterTrackPropertyConditionArgs and FilterTrackPropertyConditionOutput values.
// You can construct a concrete instance of `FilterTrackPropertyConditionInput` via:
//
//	FilterTrackPropertyConditionArgs{...}
type FilterTrackPropertyConditionInput interface {
	pulumi.Input

	ToFilterTrackPropertyConditionOutput() FilterTrackPropertyConditionOutput
	ToFilterTrackPropertyConditionOutputWithContext(context.Context) FilterTrackPropertyConditionOutput
}

// The class to specify one track property condition.
type FilterTrackPropertyConditionArgs struct {
	// The track property condition operation.
	Operation pulumi.StringInput `pulumi:"operation"`
	// The track property type.
	Property pulumi.StringInput `pulumi:"property"`
	// The track property value.
	Value pulumi.StringInput `pulumi:"value"`
}

func (FilterTrackPropertyConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackPropertyCondition)(nil)).Elem()
}

func (i FilterTrackPropertyConditionArgs) ToFilterTrackPropertyConditionOutput() FilterTrackPropertyConditionOutput {
	return i.ToFilterTrackPropertyConditionOutputWithContext(context.Background())
}

func (i FilterTrackPropertyConditionArgs) ToFilterTrackPropertyConditionOutputWithContext(ctx context.Context) FilterTrackPropertyConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterTrackPropertyConditionOutput)
}

// FilterTrackPropertyConditionArrayInput is an input type that accepts FilterTrackPropertyConditionArray and FilterTrackPropertyConditionArrayOutput values.
// You can construct a concrete instance of `FilterTrackPropertyConditionArrayInput` via:
//
//	FilterTrackPropertyConditionArray{ FilterTrackPropertyConditionArgs{...} }
type FilterTrackPropertyConditionArrayInput interface {
	pulumi.Input

	ToFilterTrackPropertyConditionArrayOutput() FilterTrackPropertyConditionArrayOutput
	ToFilterTrackPropertyConditionArrayOutputWithContext(context.Context) FilterTrackPropertyConditionArrayOutput
}

type FilterTrackPropertyConditionArray []FilterTrackPropertyConditionInput

func (FilterTrackPropertyConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackPropertyCondition)(nil)).Elem()
}

func (i FilterTrackPropertyConditionArray) ToFilterTrackPropertyConditionArrayOutput() FilterTrackPropertyConditionArrayOutput {
	return i.ToFilterTrackPropertyConditionArrayOutputWithContext(context.Background())
}

func (i FilterTrackPropertyConditionArray) ToFilterTrackPropertyConditionArrayOutputWithContext(ctx context.Context) FilterTrackPropertyConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterTrackPropertyConditionArrayOutput)
}

// The class to specify one track property condition.
type FilterTrackPropertyConditionOutput struct{ *pulumi.OutputState }

func (FilterTrackPropertyConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackPropertyCondition)(nil)).Elem()
}

func (o FilterTrackPropertyConditionOutput) ToFilterTrackPropertyConditionOutput() FilterTrackPropertyConditionOutput {
	return o
}

func (o FilterTrackPropertyConditionOutput) ToFilterTrackPropertyConditionOutputWithContext(ctx context.Context) FilterTrackPropertyConditionOutput {
	return o
}

// The track property condition operation.
func (o FilterTrackPropertyConditionOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyCondition) string { return v.Operation }).(pulumi.StringOutput)
}

// The track property type.
func (o FilterTrackPropertyConditionOutput) Property() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyCondition) string { return v.Property }).(pulumi.StringOutput)
}

// The track property value.
func (o FilterTrackPropertyConditionOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyCondition) string { return v.Value }).(pulumi.StringOutput)
}

type FilterTrackPropertyConditionArrayOutput struct{ *pulumi.OutputState }

func (FilterTrackPropertyConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackPropertyCondition)(nil)).Elem()
}

func (o FilterTrackPropertyConditionArrayOutput) ToFilterTrackPropertyConditionArrayOutput() FilterTrackPropertyConditionArrayOutput {
	return o
}

func (o FilterTrackPropertyConditionArrayOutput) ToFilterTrackPropertyConditionArrayOutputWithContext(ctx context.Context) FilterTrackPropertyConditionArrayOutput {
	return o
}

func (o FilterTrackPropertyConditionArrayOutput) Index(i pulumi.IntInput) FilterTrackPropertyConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FilterTrackPropertyCondition {
		return vs[0].([]FilterTrackPropertyCondition)[vs[1].(int)]
	}).(FilterTrackPropertyConditionOutput)
}

// The class to specify one track property condition.
type FilterTrackPropertyConditionResponse struct {
	// The track property condition operation.
	Operation string `pulumi:"operation"`
	// The track property type.
	Property string `pulumi:"property"`
	// The track property value.
	Value string `pulumi:"value"`
}

// The class to specify one track property condition.
type FilterTrackPropertyConditionResponseOutput struct{ *pulumi.OutputState }

func (FilterTrackPropertyConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackPropertyConditionResponse)(nil)).Elem()
}

func (o FilterTrackPropertyConditionResponseOutput) ToFilterTrackPropertyConditionResponseOutput() FilterTrackPropertyConditionResponseOutput {
	return o
}

func (o FilterTrackPropertyConditionResponseOutput) ToFilterTrackPropertyConditionResponseOutputWithContext(ctx context.Context) FilterTrackPropertyConditionResponseOutput {
	return o
}

// The track property condition operation.
func (o FilterTrackPropertyConditionResponseOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyConditionResponse) string { return v.Operation }).(pulumi.StringOutput)
}

// The track property type.
func (o FilterTrackPropertyConditionResponseOutput) Property() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyConditionResponse) string { return v.Property }).(pulumi.StringOutput)
}

// The track property value.
func (o FilterTrackPropertyConditionResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v FilterTrackPropertyConditionResponse) string { return v.Value }).(pulumi.StringOutput)
}

type FilterTrackPropertyConditionResponseArrayOutput struct{ *pulumi.OutputState }

func (FilterTrackPropertyConditionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackPropertyConditionResponse)(nil)).Elem()
}

func (o FilterTrackPropertyConditionResponseArrayOutput) ToFilterTrackPropertyConditionResponseArrayOutput() FilterTrackPropertyConditionResponseArrayOutput {
	return o
}

func (o FilterTrackPropertyConditionResponseArrayOutput) ToFilterTrackPropertyConditionResponseArrayOutputWithContext(ctx context.Context) FilterTrackPropertyConditionResponseArrayOutput {
	return o
}

func (o FilterTrackPropertyConditionResponseArrayOutput) Index(i pulumi.IntInput) FilterTrackPropertyConditionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FilterTrackPropertyConditionResponse {
		return vs[0].([]FilterTrackPropertyConditionResponse)[vs[1].(int)]
	}).(FilterTrackPropertyConditionResponseOutput)
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelection struct {
	// The track selections.
	TrackSelections []FilterTrackPropertyCondition `pulumi:"trackSelections"`
}

// FilterTrackSelectionInput is an input type that accepts FilterTrackSelectionArgs and FilterTrackSelectionOutput values.
// You can construct a concrete instance of `FilterTrackSelectionInput` via:
//
//	FilterTrackSelectionArgs{...}
type FilterTrackSelectionInput interface {
	pulumi.Input

	ToFilterTrackSelectionOutput() FilterTrackSelectionOutput
	ToFilterTrackSelectionOutputWithContext(context.Context) FilterTrackSelectionOutput
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelectionArgs struct {
	// The track selections.
	TrackSelections FilterTrackPropertyConditionArrayInput `pulumi:"trackSelections"`
}

func (FilterTrackSelectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackSelection)(nil)).Elem()
}

func (i FilterTrackSelectionArgs) ToFilterTrackSelectionOutput() FilterTrackSelectionOutput {
	return i.ToFilterTrackSelectionOutputWithContext(context.Background())
}

func (i FilterTrackSelectionArgs) ToFilterTrackSelectionOutputWithContext(ctx context.Context) FilterTrackSelectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterTrackSelectionOutput)
}

// FilterTrackSelectionArrayInput is an input type that accepts FilterTrackSelectionArray and FilterTrackSelectionArrayOutput values.
// You can construct a concrete instance of `FilterTrackSelectionArrayInput` via:
//
//	FilterTrackSelectionArray{ FilterTrackSelectionArgs{...} }
type FilterTrackSelectionArrayInput interface {
	pulumi.Input

	ToFilterTrackSelectionArrayOutput() FilterTrackSelectionArrayOutput
	ToFilterTrackSelectionArrayOutputWithContext(context.Context) FilterTrackSelectionArrayOutput
}

type FilterTrackSelectionArray []FilterTrackSelectionInput

func (FilterTrackSelectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackSelection)(nil)).Elem()
}

func (i FilterTrackSelectionArray) ToFilterTrackSelectionArrayOutput() FilterTrackSelectionArrayOutput {
	return i.ToFilterTrackSelectionArrayOutputWithContext(context.Background())
}

func (i FilterTrackSelectionArray) ToFilterTrackSelectionArrayOutputWithContext(ctx context.Context) FilterTrackSelectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterTrackSelectionArrayOutput)
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelectionOutput struct{ *pulumi.OutputState }

func (FilterTrackSelectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackSelection)(nil)).Elem()
}

func (o FilterTrackSelectionOutput) ToFilterTrackSelectionOutput() FilterTrackSelectionOutput {
	return o
}

func (o FilterTrackSelectionOutput) ToFilterTrackSelectionOutputWithContext(ctx context.Context) FilterTrackSelectionOutput {
	return o
}

// The track selections.
func (o FilterTrackSelectionOutput) TrackSelections() FilterTrackPropertyConditionArrayOutput {
	return o.ApplyT(func(v FilterTrackSelection) []FilterTrackPropertyCondition { return v.TrackSelections }).(FilterTrackPropertyConditionArrayOutput)
}

type FilterTrackSelectionArrayOutput struct{ *pulumi.OutputState }

func (FilterTrackSelectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackSelection)(nil)).Elem()
}

func (o FilterTrackSelectionArrayOutput) ToFilterTrackSelectionArrayOutput() FilterTrackSelectionArrayOutput {
	return o
}

func (o FilterTrackSelectionArrayOutput) ToFilterTrackSelectionArrayOutputWithContext(ctx context.Context) FilterTrackSelectionArrayOutput {
	return o
}

func (o FilterTrackSelectionArrayOutput) Index(i pulumi.IntInput) FilterTrackSelectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FilterTrackSelection {
		return vs[0].([]FilterTrackSelection)[vs[1].(int)]
	}).(FilterTrackSelectionOutput)
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelectionResponse struct {
	// The track selections.
	TrackSelections []FilterTrackPropertyConditionResponse `pulumi:"trackSelections"`
}

// Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
type FilterTrackSelectionResponseOutput struct{ *pulumi.OutputState }

func (FilterTrackSelectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterTrackSelectionResponse)(nil)).Elem()
}

func (o FilterTrackSelectionResponseOutput) ToFilterTrackSelectionResponseOutput() FilterTrackSelectionResponseOutput {
	return o
}

func (o FilterTrackSelectionResponseOutput) ToFilterTrackSelectionResponseOutputWithContext(ctx context.Context) FilterTrackSelectionResponseOutput {
	return o
}

// The track selections.
func (o FilterTrackSelectionResponseOutput) TrackSelections() FilterTrackPropertyConditionResponseArrayOutput {
	return o.ApplyT(func(v FilterTrackSelectionResponse) []FilterTrackPropertyConditionResponse { return v.TrackSelections }).(FilterTrackPropertyConditionResponseArrayOutput)
}

type FilterTrackSelectionResponseArrayOutput struct{ *pulumi.OutputState }

func (FilterTrackSelectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterTrackSelectionResponse)(nil)).Elem()
}

func (o FilterTrackSelectionResponseArrayOutput) ToFilterTrackSelectionResponseArrayOutput() FilterTrackSelectionResponseArrayOutput {
	return o
}

func (o FilterTrackSelectionResponseArrayOutput) ToFilterTrackSelectionResponseArrayOutputWithContext(ctx context.Context) FilterTrackSelectionResponseArrayOutput {
	return o
}

func (o FilterTrackSelectionResponseArrayOutput) Index(i pulumi.IntInput) FilterTrackSelectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FilterTrackSelectionResponse {
		return vs[0].([]FilterTrackSelectionResponse)[vs[1].(int)]
	}).(FilterTrackSelectionResponseOutput)
}

// Describes all the filtering operations, such as de-interlacing, rotation etc. that are to be applied to the input media before encoding.
type Filters struct {
	// The parameters for the rectangular window with which to crop the input video.
	Crop *Rectangle `pulumi:"crop"`
	// The de-interlacing settings.
	Deinterlace *Deinterlace `pulumi:"deinterlace"`
	// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
	Overlays []interface{} `pulumi:"overlays"`
	// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
	Rotation *string `pulumi:"rotation"`
}

// Describes all the filtering operations, such as de-interlacing, rotation etc. that are to be applied to the input media before encoding.
type FiltersResponse struct {
	// The parameters for the rectangular window with which to crop the input video.
	Crop *RectangleResponse `pulumi:"crop"`
	// The de-interlacing settings.
	Deinterlace *DeinterlaceResponse `pulumi:"deinterlace"`
	// The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
	Overlays []interface{} `pulumi:"overlays"`
	// The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto
	Rotation *string `pulumi:"rotation"`
}

// Filter First Quality
type FirstQuality struct {
	// The first quality bitrate.
	Bitrate int `pulumi:"bitrate"`
}

// FirstQualityInput is an input type that accepts FirstQualityArgs and FirstQualityOutput values.
// You can construct a concrete instance of `FirstQualityInput` via:
//
//	FirstQualityArgs{...}
type FirstQualityInput interface {
	pulumi.Input

	ToFirstQualityOutput() FirstQualityOutput
	ToFirstQualityOutputWithContext(context.Context) FirstQualityOutput
}

// Filter First Quality
type FirstQualityArgs struct {
	// The first quality bitrate.
	Bitrate pulumi.IntInput `pulumi:"bitrate"`
}

func (FirstQualityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirstQuality)(nil)).Elem()
}

func (i FirstQualityArgs) ToFirstQualityOutput() FirstQualityOutput {
	return i.ToFirstQualityOutputWithContext(context.Background())
}

func (i FirstQualityArgs) ToFirstQualityOutputWithContext(ctx context.Context) FirstQualityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirstQualityOutput)
}

func (i FirstQualityArgs) ToFirstQualityPtrOutput() FirstQualityPtrOutput {
	return i.ToFirstQualityPtrOutputWithContext(context.Background())
}

func (i FirstQualityArgs) ToFirstQualityPtrOutputWithContext(ctx context.Context) FirstQualityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirstQualityOutput).ToFirstQualityPtrOutputWithContext(ctx)
}

// FirstQualityPtrInput is an input type that accepts FirstQualityArgs, FirstQualityPtr and FirstQualityPtrOutput values.
// You can construct a concrete instance of `FirstQualityPtrInput` via:
//
//	        FirstQualityArgs{...}
//
//	or:
//
//	        nil
type FirstQualityPtrInput interface {
	pulumi.Input

	ToFirstQualityPtrOutput() FirstQualityPtrOutput
	ToFirstQualityPtrOutputWithContext(context.Context) FirstQualityPtrOutput
}

type firstQualityPtrType FirstQualityArgs

func FirstQualityPtr(v *FirstQualityArgs) FirstQualityPtrInput {
	return (*firstQualityPtrType)(v)
}

func (*firstQualityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FirstQuality)(nil)).Elem()
}

func (i *firstQualityPtrType) ToFirstQualityPtrOutput() FirstQualityPtrOutput {
	return i.ToFirstQualityPtrOutputWithContext(context.Background())
}

func (i *firstQualityPtrType) ToFirstQualityPtrOutputWithContext(ctx context.Context) FirstQualityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirstQualityPtrOutput)
}

// Filter First Quality
type FirstQualityOutput struct{ *pulumi.OutputState }

func (FirstQualityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirstQuality)(nil)).Elem()
}

func (o FirstQualityOutput) ToFirstQualityOutput() FirstQualityOutput {
	return o
}

func (o FirstQualityOutput) ToFirstQualityOutputWithContext(ctx context.Context) FirstQualityOutput {
	return o
}

func (o FirstQualityOutput) ToFirstQualityPtrOutput() FirstQualityPtrOutput {
	return o.ToFirstQualityPtrOutputWithContext(context.Background())
}

func (o FirstQualityOutput) ToFirstQualityPtrOutputWithContext(ctx context.Context) FirstQualityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FirstQuality) *FirstQuality {
		return &v
	}).(FirstQualityPtrOutput)
}

// The first quality bitrate.
func (o FirstQualityOutput) Bitrate() pulumi.IntOutput {
	return o.ApplyT(func(v FirstQuality) int { return v.Bitrate }).(pulumi.IntOutput)
}

type FirstQualityPtrOutput struct{ *pulumi.OutputState }

func (FirstQualityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirstQuality)(nil)).Elem()
}

func (o FirstQualityPtrOutput) ToFirstQualityPtrOutput() FirstQualityPtrOutput {
	return o
}

func (o FirstQualityPtrOutput) ToFirstQualityPtrOutputWithContext(ctx context.Context) FirstQualityPtrOutput {
	return o
}

func (o FirstQualityPtrOutput) Elem() FirstQualityOutput {
	return o.ApplyT(func(v *FirstQuality) FirstQuality {
		if v != nil {
			return *v
		}
		var ret FirstQuality
		return ret
	}).(FirstQualityOutput)
}

// The first quality bitrate.
func (o FirstQualityPtrOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FirstQuality) *int {
		if v == nil {
			return nil
		}
		return &v.Bitrate
	}).(pulumi.IntPtrOutput)
}

// Filter First Quality
type FirstQualityResponse struct {
	// The first quality bitrate.
	Bitrate int `pulumi:"bitrate"`
}

// Filter First Quality
type FirstQualityResponseOutput struct{ *pulumi.OutputState }

func (FirstQualityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirstQualityResponse)(nil)).Elem()
}

func (o FirstQualityResponseOutput) ToFirstQualityResponseOutput() FirstQualityResponseOutput {
	return o
}

func (o FirstQualityResponseOutput) ToFirstQualityResponseOutputWithContext(ctx context.Context) FirstQualityResponseOutput {
	return o
}

// The first quality bitrate.
func (o FirstQualityResponseOutput) Bitrate() pulumi.IntOutput {
	return o.ApplyT(func(v FirstQualityResponse) int { return v.Bitrate }).(pulumi.IntOutput)
}

type FirstQualityResponsePtrOutput struct{ *pulumi.OutputState }

func (FirstQualityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirstQualityResponse)(nil)).Elem()
}

func (o FirstQualityResponsePtrOutput) ToFirstQualityResponsePtrOutput() FirstQualityResponsePtrOutput {
	return o
}

func (o FirstQualityResponsePtrOutput) ToFirstQualityResponsePtrOutputWithContext(ctx context.Context) FirstQualityResponsePtrOutput {
	return o
}

func (o FirstQualityResponsePtrOutput) Elem() FirstQualityResponseOutput {
	return o.ApplyT(func(v *FirstQualityResponse) FirstQualityResponse {
		if v != nil {
			return *v
		}
		var ret FirstQualityResponse
		return ret
	}).(FirstQualityResponseOutput)
}

// The first quality bitrate.
func (o FirstQualityResponsePtrOutput) Bitrate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FirstQualityResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Bitrate
	}).(pulumi.IntPtrOutput)
}

// An InputDefinition that looks across all of the files provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to allow selection of a single track across a set of input files.
type FromAllInputFile struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromAllInputFile'.
	OdataType string `pulumi:"odataType"`
}

// An InputDefinition that looks across all of the files provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to allow selection of a single track across a set of input files.
type FromAllInputFileResponse struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromAllInputFile'.
	OdataType string `pulumi:"odataType"`
}

// An InputDefinition that looks at each input file provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to select tracks from each file given.
type FromEachInputFile struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromEachInputFile'.
	OdataType string `pulumi:"odataType"`
}

// An InputDefinition that looks at each input file provided to select tracks specified by the IncludedTracks property. Generally used with the AudioTrackByAttribute and VideoTrackByAttribute to select tracks from each file given.
type FromEachInputFileResponse struct {
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.FromEachInputFile'.
	OdataType string `pulumi:"odataType"`
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.264 video codec.
type H264Layer struct {
	// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
	Bitrate int `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow *string `pulumi:"bufferWindow"`
	// The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the profile and level.
	EntropyMode *string `pulumi:"entropyMode"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level *string `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int `pulumi:"maxBitrate"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H264Layer'.
	OdataType string `pulumi:"odataType"`
	// We currently support Baseline, Main, High, High422, High444. Default is Auto.
	Profile *string `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames *int `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.264 video codec.
type H264LayerResponse struct {
	// Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
	Bitrate int `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow *string `pulumi:"bufferWindow"`
	// The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the profile and level.
	EntropyMode *string `pulumi:"entropyMode"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level *string `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int `pulumi:"maxBitrate"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H264Layer'.
	OdataType string `pulumi:"odataType"`
	// We currently support Baseline, Main, High, High422, High444. Default is Auto.
	Profile *string `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames *int `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes all the properties for encoding a video with the H.264 codec.
type H264Video struct {
	// Tells the encoder how to choose its encoding settings. The default value is Balanced.
	Complexity *string `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The collection of output H.264 layers to be produced by the encoder.
	Layers []H264Layer `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H264Video'.
	OdataType string `pulumi:"odataType"`
	// Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection *bool `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes all the properties for encoding a video with the H.264 codec.
type H264VideoResponse struct {
	// Tells the encoder how to choose its encoding settings. The default value is Balanced.
	Complexity *string `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The collection of output H.264 layers to be produced by the encoder.
	Layers []H264LayerResponse `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H264Video'.
	OdataType string `pulumi:"odataType"`
	// Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection *bool `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.265 video codec.
type H265Layer struct {
	// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. For example: a target bitrate of 3000Kbps or 3Mbps means this value should be 3000000 This is a required field.
	Bitrate int `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow *string `pulumi:"bufferWindow"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.265 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level *string `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int `pulumi:"maxBitrate"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H265Layer'.
	OdataType string `pulumi:"odataType"`
	// We currently support Main. Default is Auto.
	Profile *string `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames *int `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes the settings to be used when encoding the input video into a desired output bitrate layer with the H.265 video codec.
type H265LayerResponse struct {
	// Specifies whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `pulumi:"adaptiveBFrame"`
	// The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int `pulumi:"bFrames"`
	// The average bitrate in bits per second at which to encode the input video when generating this layer. For example: a target bitrate of 3000Kbps or 3Mbps means this value should be 3000000 This is a required field.
	Bitrate int `pulumi:"bitrate"`
	// The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow *string `pulumi:"bufferWindow"`
	// The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `pulumi:"frameRate"`
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.265 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level *string `pulumi:"level"`
	// The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int `pulumi:"maxBitrate"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H265Layer'.
	OdataType string `pulumi:"odataType"`
	// We currently support Main. Default is Auto.
	Profile *string `pulumi:"profile"`
	// The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames *int `pulumi:"referenceFrames"`
	// The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int `pulumi:"slices"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes all the properties for encoding a video with the H.265 codec.
type H265Video struct {
	// Tells the encoder how to choose its encoding settings.  Quality will provide for a higher compression ratio but at a higher cost and longer compute time.  Speed will produce a relatively larger file but is faster and more economical. The default value is Balanced.
	Complexity *string `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The collection of output H.265 layers to be produced by the encoder.
	Layers []H265Layer `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H265Video'.
	OdataType string `pulumi:"odataType"`
	// Specifies whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection *bool `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes all the properties for encoding a video with the H.265 codec.
type H265VideoResponse struct {
	// Tells the encoder how to choose its encoding settings.  Quality will provide for a higher compression ratio but at a higher cost and longer compute time.  Speed will produce a relatively larger file but is faster and more economical. The default value is Balanced.
	Complexity *string `pulumi:"complexity"`
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The collection of output H.265 layers to be produced by the encoder.
	Layers []H265LayerResponse `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.H265Video'.
	OdataType string `pulumi:"odataType"`
	// Specifies whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection *bool `pulumi:"sceneChangeDetection"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type Hls struct {
	// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
	FragmentsPerTsSegment *int `pulumi:"fragmentsPerTsSegment"`
}

// HlsInput is an input type that accepts HlsArgs and HlsOutput values.
// You can construct a concrete instance of `HlsInput` via:
//
//	HlsArgs{...}
type HlsInput interface {
	pulumi.Input

	ToHlsOutput() HlsOutput
	ToHlsOutputWithContext(context.Context) HlsOutput
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type HlsArgs struct {
	// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
	FragmentsPerTsSegment pulumi.IntPtrInput `pulumi:"fragmentsPerTsSegment"`
}

func (HlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hls)(nil)).Elem()
}

func (i HlsArgs) ToHlsOutput() HlsOutput {
	return i.ToHlsOutputWithContext(context.Background())
}

func (i HlsArgs) ToHlsOutputWithContext(ctx context.Context) HlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HlsOutput)
}

func (i HlsArgs) ToHlsPtrOutput() HlsPtrOutput {
	return i.ToHlsPtrOutputWithContext(context.Background())
}

func (i HlsArgs) ToHlsPtrOutputWithContext(ctx context.Context) HlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HlsOutput).ToHlsPtrOutputWithContext(ctx)
}

// HlsPtrInput is an input type that accepts HlsArgs, HlsPtr and HlsPtrOutput values.
// You can construct a concrete instance of `HlsPtrInput` via:
//
//	        HlsArgs{...}
//
//	or:
//
//	        nil
type HlsPtrInput interface {
	pulumi.Input

	ToHlsPtrOutput() HlsPtrOutput
	ToHlsPtrOutputWithContext(context.Context) HlsPtrOutput
}

type hlsPtrType HlsArgs

func HlsPtr(v *HlsArgs) HlsPtrInput {
	return (*hlsPtrType)(v)
}

func (*hlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Hls)(nil)).Elem()
}

func (i *hlsPtrType) ToHlsPtrOutput() HlsPtrOutput {
	return i.ToHlsPtrOutputWithContext(context.Background())
}

func (i *hlsPtrType) ToHlsPtrOutputWithContext(ctx context.Context) HlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HlsPtrOutput)
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type HlsOutput struct{ *pulumi.OutputState }

func (HlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hls)(nil)).Elem()
}

func (o HlsOutput) ToHlsOutput() HlsOutput {
	return o
}

func (o HlsOutput) ToHlsOutputWithContext(ctx context.Context) HlsOutput {
	return o
}

func (o HlsOutput) ToHlsPtrOutput() HlsPtrOutput {
	return o.ToHlsPtrOutputWithContext(context.Background())
}

func (o HlsOutput) ToHlsPtrOutputWithContext(ctx context.Context) HlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Hls) *Hls {
		return &v
	}).(HlsPtrOutput)
}

// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
func (o HlsOutput) FragmentsPerTsSegment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Hls) *int { return v.FragmentsPerTsSegment }).(pulumi.IntPtrOutput)
}

type HlsPtrOutput struct{ *pulumi.OutputState }

func (HlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Hls)(nil)).Elem()
}

func (o HlsPtrOutput) ToHlsPtrOutput() HlsPtrOutput {
	return o
}

func (o HlsPtrOutput) ToHlsPtrOutputWithContext(ctx context.Context) HlsPtrOutput {
	return o
}

func (o HlsPtrOutput) Elem() HlsOutput {
	return o.ApplyT(func(v *Hls) Hls {
		if v != nil {
			return *v
		}
		var ret Hls
		return ret
	}).(HlsOutput)
}

// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
func (o HlsPtrOutput) FragmentsPerTsSegment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Hls) *int {
		if v == nil {
			return nil
		}
		return v.FragmentsPerTsSegment
	}).(pulumi.IntPtrOutput)
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type HlsResponse struct {
	// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
	FragmentsPerTsSegment *int `pulumi:"fragmentsPerTsSegment"`
}

// HTTP Live Streaming (HLS) packing setting for the live output.
type HlsResponseOutput struct{ *pulumi.OutputState }

func (HlsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HlsResponse)(nil)).Elem()
}

func (o HlsResponseOutput) ToHlsResponseOutput() HlsResponseOutput {
	return o
}

func (o HlsResponseOutput) ToHlsResponseOutputWithContext(ctx context.Context) HlsResponseOutput {
	return o
}

// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
func (o HlsResponseOutput) FragmentsPerTsSegment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HlsResponse) *int { return v.FragmentsPerTsSegment }).(pulumi.IntPtrOutput)
}

type HlsResponsePtrOutput struct{ *pulumi.OutputState }

func (HlsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HlsResponse)(nil)).Elem()
}

func (o HlsResponsePtrOutput) ToHlsResponsePtrOutput() HlsResponsePtrOutput {
	return o
}

func (o HlsResponsePtrOutput) ToHlsResponsePtrOutputWithContext(ctx context.Context) HlsResponsePtrOutput {
	return o
}

func (o HlsResponsePtrOutput) Elem() HlsResponseOutput {
	return o.ApplyT(func(v *HlsResponse) HlsResponse {
		if v != nil {
			return *v
		}
		var ret HlsResponse
		return ret
	}).(HlsResponseOutput)
}

// The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live event. This value does not affect the packing ratio for HLS CMAF output.
func (o HlsResponsePtrOutput) FragmentsPerTsSegment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HlsResponse) *int {
		if v == nil {
			return nil
		}
		return v.FragmentsPerTsSegment
	}).(pulumi.IntPtrOutput)
}

// The IP access control.
type IPAccessControl struct {
	// The IP allow list.
	Allow []IPRange `pulumi:"allow"`
}

// IPAccessControlInput is an input type that accepts IPAccessControlArgs and IPAccessControlOutput values.
// You can construct a concrete instance of `IPAccessControlInput` via:
//
//	IPAccessControlArgs{...}
type IPAccessControlInput interface {
	pulumi.Input

	ToIPAccessControlOutput() IPAccessControlOutput
	ToIPAccessControlOutputWithContext(context.Context) IPAccessControlOutput
}

// The IP access control.
type IPAccessControlArgs struct {
	// The IP allow list.
	Allow IPRangeArrayInput `pulumi:"allow"`
}

func (IPAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IPAccessControl)(nil)).Elem()
}

func (i IPAccessControlArgs) ToIPAccessControlOutput() IPAccessControlOutput {
	return i.ToIPAccessControlOutputWithContext(context.Background())
}

func (i IPAccessControlArgs) ToIPAccessControlOutputWithContext(ctx context.Context) IPAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPAccessControlOutput)
}

func (i IPAccessControlArgs) ToIPAccessControlPtrOutput() IPAccessControlPtrOutput {
	return i.ToIPAccessControlPtrOutputWithContext(context.Background())
}

func (i IPAccessControlArgs) ToIPAccessControlPtrOutputWithContext(ctx context.Context) IPAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPAccessControlOutput).ToIPAccessControlPtrOutputWithContext(ctx)
}

// IPAccessControlPtrInput is an input type that accepts IPAccessControlArgs, IPAccessControlPtr and IPAccessControlPtrOutput values.
// You can construct a concrete instance of `IPAccessControlPtrInput` via:
//
//	        IPAccessControlArgs{...}
//
//	or:
//
//	        nil
type IPAccessControlPtrInput interface {
	pulumi.Input

	ToIPAccessControlPtrOutput() IPAccessControlPtrOutput
	ToIPAccessControlPtrOutputWithContext(context.Context) IPAccessControlPtrOutput
}

type ipaccessControlPtrType IPAccessControlArgs

func IPAccessControlPtr(v *IPAccessControlArgs) IPAccessControlPtrInput {
	return (*ipaccessControlPtrType)(v)
}

func (*ipaccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IPAccessControl)(nil)).Elem()
}

func (i *ipaccessControlPtrType) ToIPAccessControlPtrOutput() IPAccessControlPtrOutput {
	return i.ToIPAccessControlPtrOutputWithContext(context.Background())
}

func (i *ipaccessControlPtrType) ToIPAccessControlPtrOutputWithContext(ctx context.Context) IPAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPAccessControlPtrOutput)
}

// The IP access control.
type IPAccessControlOutput struct{ *pulumi.OutputState }

func (IPAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPAccessControl)(nil)).Elem()
}

func (o IPAccessControlOutput) ToIPAccessControlOutput() IPAccessControlOutput {
	return o
}

func (o IPAccessControlOutput) ToIPAccessControlOutputWithContext(ctx context.Context) IPAccessControlOutput {
	return o
}

func (o IPAccessControlOutput) ToIPAccessControlPtrOutput() IPAccessControlPtrOutput {
	return o.ToIPAccessControlPtrOutputWithContext(context.Background())
}

func (o IPAccessControlOutput) ToIPAccessControlPtrOutputWithContext(ctx context.Context) IPAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IPAccessControl) *IPAccessControl {
		return &v
	}).(IPAccessControlPtrOutput)
}

// The IP allow list.
func (o IPAccessControlOutput) Allow() IPRangeArrayOutput {
	return o.ApplyT(func(v IPAccessControl) []IPRange { return v.Allow }).(IPRangeArrayOutput)
}

type IPAccessControlPtrOutput struct{ *pulumi.OutputState }

func (IPAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IPAccessControl)(nil)).Elem()
}

func (o IPAccessControlPtrOutput) ToIPAccessControlPtrOutput() IPAccessControlPtrOutput {
	return o
}

func (o IPAccessControlPtrOutput) ToIPAccessControlPtrOutputWithContext(ctx context.Context) IPAccessControlPtrOutput {
	return o
}

func (o IPAccessControlPtrOutput) Elem() IPAccessControlOutput {
	return o.ApplyT(func(v *IPAccessControl) IPAccessControl {
		if v != nil {
			return *v
		}
		var ret IPAccessControl
		return ret
	}).(IPAccessControlOutput)
}

// The IP allow list.
func (o IPAccessControlPtrOutput) Allow() IPRangeArrayOutput {
	return o.ApplyT(func(v *IPAccessControl) []IPRange {
		if v == nil {
			return nil
		}
		return v.Allow
	}).(IPRangeArrayOutput)
}

// The IP access control.
type IPAccessControlResponse struct {
	// The IP allow list.
	Allow []IPRangeResponse `pulumi:"allow"`
}

// The IP access control.
type IPAccessControlResponseOutput struct{ *pulumi.OutputState }

func (IPAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPAccessControlResponse)(nil)).Elem()
}

func (o IPAccessControlResponseOutput) ToIPAccessControlResponseOutput() IPAccessControlResponseOutput {
	return o
}

func (o IPAccessControlResponseOutput) ToIPAccessControlResponseOutputWithContext(ctx context.Context) IPAccessControlResponseOutput {
	return o
}

// The IP allow list.
func (o IPAccessControlResponseOutput) Allow() IPRangeResponseArrayOutput {
	return o.ApplyT(func(v IPAccessControlResponse) []IPRangeResponse { return v.Allow }).(IPRangeResponseArrayOutput)
}

type IPAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (IPAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IPAccessControlResponse)(nil)).Elem()
}

func (o IPAccessControlResponsePtrOutput) ToIPAccessControlResponsePtrOutput() IPAccessControlResponsePtrOutput {
	return o
}

func (o IPAccessControlResponsePtrOutput) ToIPAccessControlResponsePtrOutputWithContext(ctx context.Context) IPAccessControlResponsePtrOutput {
	return o
}

func (o IPAccessControlResponsePtrOutput) Elem() IPAccessControlResponseOutput {
	return o.ApplyT(func(v *IPAccessControlResponse) IPAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret IPAccessControlResponse
		return ret
	}).(IPAccessControlResponseOutput)
}

// The IP allow list.
func (o IPAccessControlResponsePtrOutput) Allow() IPRangeResponseArrayOutput {
	return o.ApplyT(func(v *IPAccessControlResponse) []IPRangeResponse {
		if v == nil {
			return nil
		}
		return v.Allow
	}).(IPRangeResponseArrayOutput)
}

// The IP address range in the CIDR scheme.
type IPRange struct {
	// The IP address.
	Address *string `pulumi:"address"`
	// The friendly name for the IP address range.
	Name *string `pulumi:"name"`
	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength *int `pulumi:"subnetPrefixLength"`
}

// IPRangeInput is an input type that accepts IPRangeArgs and IPRangeOutput values.
// You can construct a concrete instance of `IPRangeInput` via:
//
//	IPRangeArgs{...}
type IPRangeInput interface {
	pulumi.Input

	ToIPRangeOutput() IPRangeOutput
	ToIPRangeOutputWithContext(context.Context) IPRangeOutput
}

// The IP address range in the CIDR scheme.
type IPRangeArgs struct {
	// The IP address.
	Address pulumi.StringPtrInput `pulumi:"address"`
	// The friendly name for the IP address range.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength pulumi.IntPtrInput `pulumi:"subnetPrefixLength"`
}

func (IPRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IPRange)(nil)).Elem()
}

func (i IPRangeArgs) ToIPRangeOutput() IPRangeOutput {
	return i.ToIPRangeOutputWithContext(context.Background())
}

func (i IPRangeArgs) ToIPRangeOutputWithContext(ctx context.Context) IPRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPRangeOutput)
}

// IPRangeArrayInput is an input type that accepts IPRangeArray and IPRangeArrayOutput values.
// You can construct a concrete instance of `IPRangeArrayInput` via:
//
//	IPRangeArray{ IPRangeArgs{...} }
type IPRangeArrayInput interface {
	pulumi.Input

	ToIPRangeArrayOutput() IPRangeArrayOutput
	ToIPRangeArrayOutputWithContext(context.Context) IPRangeArrayOutput
}

type IPRangeArray []IPRangeInput

func (IPRangeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPRange)(nil)).Elem()
}

func (i IPRangeArray) ToIPRangeArrayOutput() IPRangeArrayOutput {
	return i.ToIPRangeArrayOutputWithContext(context.Background())
}

func (i IPRangeArray) ToIPRangeArrayOutputWithContext(ctx context.Context) IPRangeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPRangeArrayOutput)
}

// The IP address range in the CIDR scheme.
type IPRangeOutput struct{ *pulumi.OutputState }

func (IPRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPRange)(nil)).Elem()
}

func (o IPRangeOutput) ToIPRangeOutput() IPRangeOutput {
	return o
}

func (o IPRangeOutput) ToIPRangeOutputWithContext(ctx context.Context) IPRangeOutput {
	return o
}

// The IP address.
func (o IPRangeOutput) Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPRange) *string { return v.Address }).(pulumi.StringPtrOutput)
}

// The friendly name for the IP address range.
func (o IPRangeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPRange) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The subnet mask prefix length (see CIDR notation).
func (o IPRangeOutput) SubnetPrefixLength() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IPRange) *int { return v.SubnetPrefixLength }).(pulumi.IntPtrOutput)
}

type IPRangeArrayOutput struct{ *pulumi.OutputState }

func (IPRangeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPRange)(nil)).Elem()
}

func (o IPRangeArrayOutput) ToIPRangeArrayOutput() IPRangeArrayOutput {
	return o
}

func (o IPRangeArrayOutput) ToIPRangeArrayOutputWithContext(ctx context.Context) IPRangeArrayOutput {
	return o
}

func (o IPRangeArrayOutput) Index(i pulumi.IntInput) IPRangeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IPRange {
		return vs[0].([]IPRange)[vs[1].(int)]
	}).(IPRangeOutput)
}

// The IP address range in the CIDR scheme.
type IPRangeResponse struct {
	// The IP address.
	Address *string `pulumi:"address"`
	// The friendly name for the IP address range.
	Name *string `pulumi:"name"`
	// The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength *int `pulumi:"subnetPrefixLength"`
}

// The IP address range in the CIDR scheme.
type IPRangeResponseOutput struct{ *pulumi.OutputState }

func (IPRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPRangeResponse)(nil)).Elem()
}

func (o IPRangeResponseOutput) ToIPRangeResponseOutput() IPRangeResponseOutput {
	return o
}

func (o IPRangeResponseOutput) ToIPRangeResponseOutputWithContext(ctx context.Context) IPRangeResponseOutput {
	return o
}

// The IP address.
func (o IPRangeResponseOutput) Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPRangeResponse) *string { return v.Address }).(pulumi.StringPtrOutput)
}

// The friendly name for the IP address range.
func (o IPRangeResponseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPRangeResponse) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The subnet mask prefix length (see CIDR notation).
func (o IPRangeResponseOutput) SubnetPrefixLength() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IPRangeResponse) *int { return v.SubnetPrefixLength }).(pulumi.IntPtrOutput)
}

type IPRangeResponseArrayOutput struct{ *pulumi.OutputState }

func (IPRangeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPRangeResponse)(nil)).Elem()
}

func (o IPRangeResponseArrayOutput) ToIPRangeResponseArrayOutput() IPRangeResponseArrayOutput {
	return o
}

func (o IPRangeResponseArrayOutput) ToIPRangeResponseArrayOutputWithContext(ctx context.Context) IPRangeResponseArrayOutput {
	return o
}

func (o IPRangeResponseArrayOutput) Index(i pulumi.IntInput) IPRangeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IPRangeResponse {
		return vs[0].([]IPRangeResponse)[vs[1].(int)]
	}).(IPRangeResponseOutput)
}

// Describes the basic properties for generating thumbnails from the input video
type Image struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Image'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the properties for an output image file.
type ImageFormat struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ImageFormat'.
	OdataType string `pulumi:"odataType"`
}

// Describes the properties for an output image file.
type ImageFormatResponse struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.ImageFormat'.
	OdataType string `pulumi:"odataType"`
}

// Describes the basic properties for generating thumbnails from the input video
type ImageResponse struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Image'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// An InputDefinition for a single file.  TrackSelections are scoped to the file specified.
type InputFile struct {
	// Name of the file that this input definition applies to.
	Filename *string `pulumi:"filename"`
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.InputFile'.
	OdataType string `pulumi:"odataType"`
}

// An InputDefinition for a single file.  TrackSelections are scoped to the file specified.
type InputFileResponse struct {
	// Name of the file that this input definition applies to.
	Filename *string `pulumi:"filename"`
	// The list of TrackDescriptors which define the metadata and selection of tracks in the input.
	IncludedTracks []interface{} `pulumi:"includedTracks"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.InputFile'.
	OdataType string `pulumi:"odataType"`
}

// Details of JobOutput errors.
type JobErrorDetailResponse struct {
	// Code describing the error detail.
	Code string `pulumi:"code"`
	// A human-readable representation of the error.
	Message string `pulumi:"message"`
}

// Details of JobOutput errors.
type JobErrorDetailResponseOutput struct{ *pulumi.OutputState }

func (JobErrorDetailResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobErrorDetailResponse)(nil)).Elem()
}

func (o JobErrorDetailResponseOutput) ToJobErrorDetailResponseOutput() JobErrorDetailResponseOutput {
	return o
}

func (o JobErrorDetailResponseOutput) ToJobErrorDetailResponseOutputWithContext(ctx context.Context) JobErrorDetailResponseOutput {
	return o
}

// Code describing the error detail.
func (o JobErrorDetailResponseOutput) Code() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorDetailResponse) string { return v.Code }).(pulumi.StringOutput)
}

// A human-readable representation of the error.
func (o JobErrorDetailResponseOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorDetailResponse) string { return v.Message }).(pulumi.StringOutput)
}

type JobErrorDetailResponseArrayOutput struct{ *pulumi.OutputState }

func (JobErrorDetailResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobErrorDetailResponse)(nil)).Elem()
}

func (o JobErrorDetailResponseArrayOutput) ToJobErrorDetailResponseArrayOutput() JobErrorDetailResponseArrayOutput {
	return o
}

func (o JobErrorDetailResponseArrayOutput) ToJobErrorDetailResponseArrayOutputWithContext(ctx context.Context) JobErrorDetailResponseArrayOutput {
	return o
}

func (o JobErrorDetailResponseArrayOutput) Index(i pulumi.IntInput) JobErrorDetailResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobErrorDetailResponse {
		return vs[0].([]JobErrorDetailResponse)[vs[1].(int)]
	}).(JobErrorDetailResponseOutput)
}

// Details of JobOutput errors.
type JobErrorResponse struct {
	// Helps with categorization of errors.
	Category string `pulumi:"category"`
	// Error code describing the error.
	Code string `pulumi:"code"`
	// An array of details about specific errors that led to this reported error.
	Details []JobErrorDetailResponse `pulumi:"details"`
	// A human-readable language-dependent representation of the error.
	Message string `pulumi:"message"`
	// Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via Azure Portal.
	Retry string `pulumi:"retry"`
}

// Details of JobOutput errors.
type JobErrorResponseOutput struct{ *pulumi.OutputState }

func (JobErrorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobErrorResponse)(nil)).Elem()
}

func (o JobErrorResponseOutput) ToJobErrorResponseOutput() JobErrorResponseOutput {
	return o
}

func (o JobErrorResponseOutput) ToJobErrorResponseOutputWithContext(ctx context.Context) JobErrorResponseOutput {
	return o
}

// Helps with categorization of errors.
func (o JobErrorResponseOutput) Category() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorResponse) string { return v.Category }).(pulumi.StringOutput)
}

// Error code describing the error.
func (o JobErrorResponseOutput) Code() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorResponse) string { return v.Code }).(pulumi.StringOutput)
}

// An array of details about specific errors that led to this reported error.
func (o JobErrorResponseOutput) Details() JobErrorDetailResponseArrayOutput {
	return o.ApplyT(func(v JobErrorResponse) []JobErrorDetailResponse { return v.Details }).(JobErrorDetailResponseArrayOutput)
}

// A human-readable language-dependent representation of the error.
func (o JobErrorResponseOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorResponse) string { return v.Message }).(pulumi.StringOutput)
}

// Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via Azure Portal.
func (o JobErrorResponseOutput) Retry() pulumi.StringOutput {
	return o.ApplyT(func(v JobErrorResponse) string { return v.Retry }).(pulumi.StringOutput)
}

// Represents an Asset for input into a Job.
type JobInputAsset struct {
	// The name of the input Asset.
	AssetName string `pulumi:"assetName"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputAsset'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// Represents an Asset for input into a Job.
type JobInputAssetResponse struct {
	// The name of the input Asset.
	AssetName string `pulumi:"assetName"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputAsset'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// Represents input files for a Job.
type JobInputClip struct {
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputClip'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// Represents input files for a Job.
type JobInputClipResponse struct {
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputClip'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// Represents HTTPS job input.
type JobInputHttp struct {
	// Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided file list is assumed to be fully qualified uris. Maximum length of 4000 characters.
	BaseUri *string `pulumi:"baseUri"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputHttp'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// Represents HTTPS job input.
type JobInputHttpResponse struct {
	// Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided file list is assumed to be fully qualified uris. Maximum length of 4000 characters.
	BaseUri *string `pulumi:"baseUri"`
	// Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End interface{} `pulumi:"end"`
	// List of files. Required for JobInputHttp. Maximum of 4000 characters each.
	Files []string `pulumi:"files"`
	// Defines a list of InputDefinitions. For each InputDefinition, it defines a list of track selections and related metadata.
	InputDefinitions []interface{} `pulumi:"inputDefinitions"`
	// A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputHttp'.
	OdataType string `pulumi:"odataType"`
	// Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start interface{} `pulumi:"start"`
}

// A Sequence contains an ordered list of Clips where each clip is a JobInput.  The Sequence will be treated as a single input.
type JobInputSequence struct {
	// JobInputs that make up the timeline.
	Inputs []JobInputClip `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputSequence'.
	OdataType string `pulumi:"odataType"`
}

// A Sequence contains an ordered list of Clips where each clip is a JobInput.  The Sequence will be treated as a single input.
type JobInputSequenceResponse struct {
	// JobInputs that make up the timeline.
	Inputs []JobInputClipResponse `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputSequence'.
	OdataType string `pulumi:"odataType"`
}

// Describes a list of inputs to a Job.
type JobInputs struct {
	// List of inputs to a Job.
	Inputs []interface{} `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputs'.
	OdataType string `pulumi:"odataType"`
}

// Describes a list of inputs to a Job.
type JobInputsResponse struct {
	// List of inputs to a Job.
	Inputs []interface{} `pulumi:"inputs"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobInputs'.
	OdataType string `pulumi:"odataType"`
}

// Represents an Asset used as a JobOutput.
type JobOutputAsset struct {
	// The name of the output Asset.
	AssetName string `pulumi:"assetName"`
	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobOutputAsset'.
	OdataType string `pulumi:"odataType"`
}

// JobOutputAssetInput is an input type that accepts JobOutputAssetArgs and JobOutputAssetOutput values.
// You can construct a concrete instance of `JobOutputAssetInput` via:
//
//	JobOutputAssetArgs{...}
type JobOutputAssetInput interface {
	pulumi.Input

	ToJobOutputAssetOutput() JobOutputAssetOutput
	ToJobOutputAssetOutputWithContext(context.Context) JobOutputAssetOutput
}

// Represents an Asset used as a JobOutput.
type JobOutputAssetArgs struct {
	// The name of the output Asset.
	AssetName pulumi.StringInput `pulumi:"assetName"`
	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobOutputAsset'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (JobOutputAssetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobOutputAsset)(nil)).Elem()
}

func (i JobOutputAssetArgs) ToJobOutputAssetOutput() JobOutputAssetOutput {
	return i.ToJobOutputAssetOutputWithContext(context.Background())
}

func (i JobOutputAssetArgs) ToJobOutputAssetOutputWithContext(ctx context.Context) JobOutputAssetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobOutputAssetOutput)
}

// JobOutputAssetArrayInput is an input type that accepts JobOutputAssetArray and JobOutputAssetArrayOutput values.
// You can construct a concrete instance of `JobOutputAssetArrayInput` via:
//
//	JobOutputAssetArray{ JobOutputAssetArgs{...} }
type JobOutputAssetArrayInput interface {
	pulumi.Input

	ToJobOutputAssetArrayOutput() JobOutputAssetArrayOutput
	ToJobOutputAssetArrayOutputWithContext(context.Context) JobOutputAssetArrayOutput
}

type JobOutputAssetArray []JobOutputAssetInput

func (JobOutputAssetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobOutputAsset)(nil)).Elem()
}

func (i JobOutputAssetArray) ToJobOutputAssetArrayOutput() JobOutputAssetArrayOutput {
	return i.ToJobOutputAssetArrayOutputWithContext(context.Background())
}

func (i JobOutputAssetArray) ToJobOutputAssetArrayOutputWithContext(ctx context.Context) JobOutputAssetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobOutputAssetArrayOutput)
}

// Represents an Asset used as a JobOutput.
type JobOutputAssetOutput struct{ *pulumi.OutputState }

func (JobOutputAssetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobOutputAsset)(nil)).Elem()
}

func (o JobOutputAssetOutput) ToJobOutputAssetOutput() JobOutputAssetOutput {
	return o
}

func (o JobOutputAssetOutput) ToJobOutputAssetOutputWithContext(ctx context.Context) JobOutputAssetOutput {
	return o
}

// The name of the output Asset.
func (o JobOutputAssetOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAsset) string { return v.AssetName }).(pulumi.StringOutput)
}

// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
func (o JobOutputAssetOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobOutputAsset) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobOutputAsset'.
func (o JobOutputAssetOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAsset) string { return v.OdataType }).(pulumi.StringOutput)
}

type JobOutputAssetArrayOutput struct{ *pulumi.OutputState }

func (JobOutputAssetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobOutputAsset)(nil)).Elem()
}

func (o JobOutputAssetArrayOutput) ToJobOutputAssetArrayOutput() JobOutputAssetArrayOutput {
	return o
}

func (o JobOutputAssetArrayOutput) ToJobOutputAssetArrayOutputWithContext(ctx context.Context) JobOutputAssetArrayOutput {
	return o
}

func (o JobOutputAssetArrayOutput) Index(i pulumi.IntInput) JobOutputAssetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobOutputAsset {
		return vs[0].([]JobOutputAsset)[vs[1].(int)]
	}).(JobOutputAssetOutput)
}

// Represents an Asset used as a JobOutput.
type JobOutputAssetResponse struct {
	// The name of the output Asset.
	AssetName string `pulumi:"assetName"`
	// The UTC date and time at which this Job Output finished processing.
	EndTime string `pulumi:"endTime"`
	// If the JobOutput is in the Error state, it contains the details of the error.
	Error JobErrorResponse `pulumi:"error"`
	// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JobOutputAsset'.
	OdataType string `pulumi:"odataType"`
	// If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used to predict Job completion times. To determine if the JobOutput is complete, use the State property.
	Progress int `pulumi:"progress"`
	// The UTC date and time at which this Job Output began processing.
	StartTime string `pulumi:"startTime"`
	// Describes the state of the JobOutput.
	State string `pulumi:"state"`
}

// Represents an Asset used as a JobOutput.
type JobOutputAssetResponseOutput struct{ *pulumi.OutputState }

func (JobOutputAssetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobOutputAssetResponse)(nil)).Elem()
}

func (o JobOutputAssetResponseOutput) ToJobOutputAssetResponseOutput() JobOutputAssetResponseOutput {
	return o
}

func (o JobOutputAssetResponseOutput) ToJobOutputAssetResponseOutputWithContext(ctx context.Context) JobOutputAssetResponseOutput {
	return o
}

// The name of the output Asset.
func (o JobOutputAssetResponseOutput) AssetName() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.AssetName }).(pulumi.StringOutput)
}

// The UTC date and time at which this Job Output finished processing.
func (o JobOutputAssetResponseOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.EndTime }).(pulumi.StringOutput)
}

// If the JobOutput is in the Error state, it contains the details of the error.
func (o JobOutputAssetResponseOutput) Error() JobErrorResponseOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) JobErrorResponse { return v.Error }).(JobErrorResponseOutput)
}

// A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
func (o JobOutputAssetResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.Media.JobOutputAsset'.
func (o JobOutputAssetResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used to predict Job completion times. To determine if the JobOutput is complete, use the State property.
func (o JobOutputAssetResponseOutput) Progress() pulumi.IntOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) int { return v.Progress }).(pulumi.IntOutput)
}

// The UTC date and time at which this Job Output began processing.
func (o JobOutputAssetResponseOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.StartTime }).(pulumi.StringOutput)
}

// Describes the state of the JobOutput.
func (o JobOutputAssetResponseOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v JobOutputAssetResponse) string { return v.State }).(pulumi.StringOutput)
}

type JobOutputAssetResponseArrayOutput struct{ *pulumi.OutputState }

func (JobOutputAssetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobOutputAssetResponse)(nil)).Elem()
}

func (o JobOutputAssetResponseArrayOutput) ToJobOutputAssetResponseArrayOutput() JobOutputAssetResponseArrayOutput {
	return o
}

func (o JobOutputAssetResponseArrayOutput) ToJobOutputAssetResponseArrayOutputWithContext(ctx context.Context) JobOutputAssetResponseArrayOutput {
	return o
}

func (o JobOutputAssetResponseArrayOutput) Index(i pulumi.IntInput) JobOutputAssetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobOutputAssetResponse {
		return vs[0].([]JobOutputAssetResponse)[vs[1].(int)]
	}).(JobOutputAssetResponseOutput)
}

// Describes the settings for producing JPEG thumbnails.
type JpgFormat struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgFormat'.
	OdataType string `pulumi:"odataType"`
}

// Describes the settings for producing JPEG thumbnails.
type JpgFormatResponse struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgFormat'.
	OdataType string `pulumi:"odataType"`
}

// Describes the properties for producing a series of JPEG images from the input video.
type JpgImage struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// A collection of output JPEG image layers to be produced by the encoder.
	Layers []JpgLayer `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgImage'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// Sets the number of columns used in thumbnail sprite image.  The number of rows are automatically calculated and a VTT file is generated with the coordinate mappings for each thumbnail in the sprite. Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will not go beyond JPEG maximum pixel resolution limit 65535x65535.
	SpriteColumn *int `pulumi:"spriteColumn"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the properties for producing a series of JPEG images from the input video.
type JpgImageResponse struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// A collection of output JPEG image layers to be produced by the encoder.
	Layers []JpgLayerResponse `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgImage'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// Sets the number of columns used in thumbnail sprite image.  The number of rows are automatically calculated and a VTT file is generated with the coordinate mappings for each thumbnail in the sprite. Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will not go beyond JPEG maximum pixel resolution limit 65535x65535.
	SpriteColumn *int `pulumi:"spriteColumn"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the settings to produce a JPEG image from the input video.
type JpgLayer struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgLayer'.
	OdataType string `pulumi:"odataType"`
	// The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
	Quality *int `pulumi:"quality"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes the settings to produce a JPEG image from the input video.
type JpgLayerResponse struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.JpgLayer'.
	OdataType string `pulumi:"odataType"`
	// The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
	Quality *int `pulumi:"quality"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

type KeyVaultProperties struct {
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
	KeyIdentifier *string `pulumi:"keyIdentifier"`
}

// KeyVaultPropertiesInput is an input type that accepts KeyVaultPropertiesArgs and KeyVaultPropertiesOutput values.
// You can construct a concrete instance of `KeyVaultPropertiesInput` via:
//
//	KeyVaultPropertiesArgs{...}
type KeyVaultPropertiesInput interface {
	pulumi.Input

	ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput
	ToKeyVaultPropertiesOutputWithContext(context.Context) KeyVaultPropertiesOutput
}

type KeyVaultPropertiesArgs struct {
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
	KeyIdentifier pulumi.StringPtrInput `pulumi:"keyIdentifier"`
}

func (KeyVaultPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultProperties)(nil)).Elem()
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput {
	return i.ToKeyVaultPropertiesOutputWithContext(context.Background())
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesOutputWithContext(ctx context.Context) KeyVaultPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesOutput)
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return i.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesOutput).ToKeyVaultPropertiesPtrOutputWithContext(ctx)
}

// KeyVaultPropertiesPtrInput is an input type that accepts KeyVaultPropertiesArgs, KeyVaultPropertiesPtr and KeyVaultPropertiesPtrOutput values.
// You can construct a concrete instance of `KeyVaultPropertiesPtrInput` via:
//
//	        KeyVaultPropertiesArgs{...}
//
//	or:
//
//	        nil
type KeyVaultPropertiesPtrInput interface {
	pulumi.Input

	ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput
	ToKeyVaultPropertiesPtrOutputWithContext(context.Context) KeyVaultPropertiesPtrOutput
}

type keyVaultPropertiesPtrType KeyVaultPropertiesArgs

func KeyVaultPropertiesPtr(v *KeyVaultPropertiesArgs) KeyVaultPropertiesPtrInput {
	return (*keyVaultPropertiesPtrType)(v)
}

func (*keyVaultPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultProperties)(nil)).Elem()
}

func (i *keyVaultPropertiesPtrType) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return i.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i *keyVaultPropertiesPtrType) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesPtrOutput)
}

type KeyVaultPropertiesOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultProperties)(nil)).Elem()
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput {
	return o
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesOutputWithContext(ctx context.Context) KeyVaultPropertiesOutput {
	return o
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return o.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeyVaultProperties) *KeyVaultProperties {
		return &v
	}).(KeyVaultPropertiesPtrOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyVaultProperties) *string { return v.KeyIdentifier }).(pulumi.StringPtrOutput)
}

type KeyVaultPropertiesPtrOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultProperties)(nil)).Elem()
}

func (o KeyVaultPropertiesPtrOutput) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return o
}

func (o KeyVaultPropertiesPtrOutput) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return o
}

func (o KeyVaultPropertiesPtrOutput) Elem() KeyVaultPropertiesOutput {
	return o.ApplyT(func(v *KeyVaultProperties) KeyVaultProperties {
		if v != nil {
			return *v
		}
		var ret KeyVaultProperties
		return ret
	}).(KeyVaultPropertiesOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesPtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultProperties) *string {
		if v == nil {
			return nil
		}
		return v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

type KeyVaultPropertiesResponse struct {
	// The current key used to encrypt the Media Services account, including the key version.
	CurrentKeyIdentifier string `pulumi:"currentKeyIdentifier"`
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
	KeyIdentifier *string `pulumi:"keyIdentifier"`
}

type KeyVaultPropertiesResponseOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultPropertiesResponse)(nil)).Elem()
}

func (o KeyVaultPropertiesResponseOutput) ToKeyVaultPropertiesResponseOutput() KeyVaultPropertiesResponseOutput {
	return o
}

func (o KeyVaultPropertiesResponseOutput) ToKeyVaultPropertiesResponseOutputWithContext(ctx context.Context) KeyVaultPropertiesResponseOutput {
	return o
}

// The current key used to encrypt the Media Services account, including the key version.
func (o KeyVaultPropertiesResponseOutput) CurrentKeyIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v KeyVaultPropertiesResponse) string { return v.CurrentKeyIdentifier }).(pulumi.StringOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesResponseOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyVaultPropertiesResponse) *string { return v.KeyIdentifier }).(pulumi.StringPtrOutput)
}

type KeyVaultPropertiesResponsePtrOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultPropertiesResponse)(nil)).Elem()
}

func (o KeyVaultPropertiesResponsePtrOutput) ToKeyVaultPropertiesResponsePtrOutput() KeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o KeyVaultPropertiesResponsePtrOutput) ToKeyVaultPropertiesResponsePtrOutputWithContext(ctx context.Context) KeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o KeyVaultPropertiesResponsePtrOutput) Elem() KeyVaultPropertiesResponseOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) KeyVaultPropertiesResponse {
		if v != nil {
			return *v
		}
		var ret KeyVaultPropertiesResponse
		return ret
	}).(KeyVaultPropertiesResponseOutput)
}

// The current key used to encrypt the Media Services account, including the key version.
func (o KeyVaultPropertiesResponsePtrOutput) CurrentKeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CurrentKeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesResponsePtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncoding struct {
	// Live event type. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
	EncodingType *string `pulumi:"encodingType"`
	// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
	PresetName *string `pulumi:"presetName"`
	// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
	StretchMode *string `pulumi:"stretchMode"`
}

// LiveEventEncodingInput is an input type that accepts LiveEventEncodingArgs and LiveEventEncodingOutput values.
// You can construct a concrete instance of `LiveEventEncodingInput` via:
//
//	LiveEventEncodingArgs{...}
type LiveEventEncodingInput interface {
	pulumi.Input

	ToLiveEventEncodingOutput() LiveEventEncodingOutput
	ToLiveEventEncodingOutputWithContext(context.Context) LiveEventEncodingOutput
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncodingArgs struct {
	// Live event type. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
	EncodingType pulumi.StringPtrInput `pulumi:"encodingType"`
	// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
	KeyFrameInterval pulumi.StringPtrInput `pulumi:"keyFrameInterval"`
	// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
	PresetName pulumi.StringPtrInput `pulumi:"presetName"`
	// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
	StretchMode pulumi.StringPtrInput `pulumi:"stretchMode"`
}

func (LiveEventEncodingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEncoding)(nil)).Elem()
}

func (i LiveEventEncodingArgs) ToLiveEventEncodingOutput() LiveEventEncodingOutput {
	return i.ToLiveEventEncodingOutputWithContext(context.Background())
}

func (i LiveEventEncodingArgs) ToLiveEventEncodingOutputWithContext(ctx context.Context) LiveEventEncodingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEncodingOutput)
}

func (i LiveEventEncodingArgs) ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput {
	return i.ToLiveEventEncodingPtrOutputWithContext(context.Background())
}

func (i LiveEventEncodingArgs) ToLiveEventEncodingPtrOutputWithContext(ctx context.Context) LiveEventEncodingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEncodingOutput).ToLiveEventEncodingPtrOutputWithContext(ctx)
}

// LiveEventEncodingPtrInput is an input type that accepts LiveEventEncodingArgs, LiveEventEncodingPtr and LiveEventEncodingPtrOutput values.
// You can construct a concrete instance of `LiveEventEncodingPtrInput` via:
//
//	        LiveEventEncodingArgs{...}
//
//	or:
//
//	        nil
type LiveEventEncodingPtrInput interface {
	pulumi.Input

	ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput
	ToLiveEventEncodingPtrOutputWithContext(context.Context) LiveEventEncodingPtrOutput
}

type liveEventEncodingPtrType LiveEventEncodingArgs

func LiveEventEncodingPtr(v *LiveEventEncodingArgs) LiveEventEncodingPtrInput {
	return (*liveEventEncodingPtrType)(v)
}

func (*liveEventEncodingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventEncoding)(nil)).Elem()
}

func (i *liveEventEncodingPtrType) ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput {
	return i.ToLiveEventEncodingPtrOutputWithContext(context.Background())
}

func (i *liveEventEncodingPtrType) ToLiveEventEncodingPtrOutputWithContext(ctx context.Context) LiveEventEncodingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEncodingPtrOutput)
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncodingOutput struct{ *pulumi.OutputState }

func (LiveEventEncodingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEncoding)(nil)).Elem()
}

func (o LiveEventEncodingOutput) ToLiveEventEncodingOutput() LiveEventEncodingOutput {
	return o
}

func (o LiveEventEncodingOutput) ToLiveEventEncodingOutputWithContext(ctx context.Context) LiveEventEncodingOutput {
	return o
}

func (o LiveEventEncodingOutput) ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput {
	return o.ToLiveEventEncodingPtrOutputWithContext(context.Background())
}

func (o LiveEventEncodingOutput) ToLiveEventEncodingPtrOutputWithContext(ctx context.Context) LiveEventEncodingPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventEncoding) *LiveEventEncoding {
		return &v
	}).(LiveEventEncodingPtrOutput)
}

// Live event type. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
func (o LiveEventEncodingOutput) EncodingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncoding) *string { return v.EncodingType }).(pulumi.StringPtrOutput)
}

// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
func (o LiveEventEncodingOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncoding) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
func (o LiveEventEncodingOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncoding) *string { return v.PresetName }).(pulumi.StringPtrOutput)
}

// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
func (o LiveEventEncodingOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncoding) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

type LiveEventEncodingPtrOutput struct{ *pulumi.OutputState }

func (LiveEventEncodingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventEncoding)(nil)).Elem()
}

func (o LiveEventEncodingPtrOutput) ToLiveEventEncodingPtrOutput() LiveEventEncodingPtrOutput {
	return o
}

func (o LiveEventEncodingPtrOutput) ToLiveEventEncodingPtrOutputWithContext(ctx context.Context) LiveEventEncodingPtrOutput {
	return o
}

func (o LiveEventEncodingPtrOutput) Elem() LiveEventEncodingOutput {
	return o.ApplyT(func(v *LiveEventEncoding) LiveEventEncoding {
		if v != nil {
			return *v
		}
		var ret LiveEventEncoding
		return ret
	}).(LiveEventEncodingOutput)
}

// Live event type. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
func (o LiveEventEncodingPtrOutput) EncodingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncoding) *string {
		if v == nil {
			return nil
		}
		return v.EncodingType
	}).(pulumi.StringPtrOutput)
}

// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
func (o LiveEventEncodingPtrOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncoding) *string {
		if v == nil {
			return nil
		}
		return v.KeyFrameInterval
	}).(pulumi.StringPtrOutput)
}

// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
func (o LiveEventEncodingPtrOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncoding) *string {
		if v == nil {
			return nil
		}
		return v.PresetName
	}).(pulumi.StringPtrOutput)
}

// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
func (o LiveEventEncodingPtrOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncoding) *string {
		if v == nil {
			return nil
		}
		return v.StretchMode
	}).(pulumi.StringPtrOutput)
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncodingResponse struct {
	// Live event type. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
	EncodingType *string `pulumi:"encodingType"`
	// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
	PresetName *string `pulumi:"presetName"`
	// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
	StretchMode *string `pulumi:"stretchMode"`
}

// Specifies the live event type and optional encoding settings for encoding live events.
type LiveEventEncodingResponseOutput struct{ *pulumi.OutputState }

func (LiveEventEncodingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEncodingResponse)(nil)).Elem()
}

func (o LiveEventEncodingResponseOutput) ToLiveEventEncodingResponseOutput() LiveEventEncodingResponseOutput {
	return o
}

func (o LiveEventEncodingResponseOutput) ToLiveEventEncodingResponseOutputWithContext(ctx context.Context) LiveEventEncodingResponseOutput {
	return o
}

// Live event type. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
func (o LiveEventEncodingResponseOutput) EncodingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncodingResponse) *string { return v.EncodingType }).(pulumi.StringPtrOutput)
}

// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
func (o LiveEventEncodingResponseOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncodingResponse) *string { return v.KeyFrameInterval }).(pulumi.StringPtrOutput)
}

// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
func (o LiveEventEncodingResponseOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncodingResponse) *string { return v.PresetName }).(pulumi.StringPtrOutput)
}

// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
func (o LiveEventEncodingResponseOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEncodingResponse) *string { return v.StretchMode }).(pulumi.StringPtrOutput)
}

type LiveEventEncodingResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventEncodingResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventEncodingResponse)(nil)).Elem()
}

func (o LiveEventEncodingResponsePtrOutput) ToLiveEventEncodingResponsePtrOutput() LiveEventEncodingResponsePtrOutput {
	return o
}

func (o LiveEventEncodingResponsePtrOutput) ToLiveEventEncodingResponsePtrOutputWithContext(ctx context.Context) LiveEventEncodingResponsePtrOutput {
	return o
}

func (o LiveEventEncodingResponsePtrOutput) Elem() LiveEventEncodingResponseOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) LiveEventEncodingResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventEncodingResponse
		return ret
	}).(LiveEventEncodingResponseOutput)
}

// Live event type. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot be modified after the live event is created.
func (o LiveEventEncodingResponsePtrOutput) EncodingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) *string {
		if v == nil {
			return nil
		}
		return v.EncodingType
	}).(pulumi.StringPtrOutput)
}

// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures).   If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
func (o LiveEventEncodingResponsePtrOutput) KeyFrameInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) *string {
		if v == nil {
			return nil
		}
		return v.KeyFrameInterval
	}).(pulumi.StringPtrOutput)
}

// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
func (o LiveEventEncodingResponsePtrOutput) PresetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) *string {
		if v == nil {
			return nil
		}
		return v.PresetName
	}).(pulumi.StringPtrOutput)
}

// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
func (o LiveEventEncodingResponsePtrOutput) StretchMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventEncodingResponse) *string {
		if v == nil {
			return nil
		}
		return v.StretchMode
	}).(pulumi.StringPtrOutput)
}

// The live event endpoint.
type LiveEventEndpoint struct {
	// The endpoint protocol.
	Protocol *string `pulumi:"protocol"`
	// The endpoint URL.
	Url *string `pulumi:"url"`
}

// LiveEventEndpointInput is an input type that accepts LiveEventEndpointArgs and LiveEventEndpointOutput values.
// You can construct a concrete instance of `LiveEventEndpointInput` via:
//
//	LiveEventEndpointArgs{...}
type LiveEventEndpointInput interface {
	pulumi.Input

	ToLiveEventEndpointOutput() LiveEventEndpointOutput
	ToLiveEventEndpointOutputWithContext(context.Context) LiveEventEndpointOutput
}

// The live event endpoint.
type LiveEventEndpointArgs struct {
	// The endpoint protocol.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// The endpoint URL.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (LiveEventEndpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEndpoint)(nil)).Elem()
}

func (i LiveEventEndpointArgs) ToLiveEventEndpointOutput() LiveEventEndpointOutput {
	return i.ToLiveEventEndpointOutputWithContext(context.Background())
}

func (i LiveEventEndpointArgs) ToLiveEventEndpointOutputWithContext(ctx context.Context) LiveEventEndpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEndpointOutput)
}

// LiveEventEndpointArrayInput is an input type that accepts LiveEventEndpointArray and LiveEventEndpointArrayOutput values.
// You can construct a concrete instance of `LiveEventEndpointArrayInput` via:
//
//	LiveEventEndpointArray{ LiveEventEndpointArgs{...} }
type LiveEventEndpointArrayInput interface {
	pulumi.Input

	ToLiveEventEndpointArrayOutput() LiveEventEndpointArrayOutput
	ToLiveEventEndpointArrayOutputWithContext(context.Context) LiveEventEndpointArrayOutput
}

type LiveEventEndpointArray []LiveEventEndpointInput

func (LiveEventEndpointArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventEndpoint)(nil)).Elem()
}

func (i LiveEventEndpointArray) ToLiveEventEndpointArrayOutput() LiveEventEndpointArrayOutput {
	return i.ToLiveEventEndpointArrayOutputWithContext(context.Background())
}

func (i LiveEventEndpointArray) ToLiveEventEndpointArrayOutputWithContext(ctx context.Context) LiveEventEndpointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventEndpointArrayOutput)
}

// The live event endpoint.
type LiveEventEndpointOutput struct{ *pulumi.OutputState }

func (LiveEventEndpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEndpoint)(nil)).Elem()
}

func (o LiveEventEndpointOutput) ToLiveEventEndpointOutput() LiveEventEndpointOutput {
	return o
}

func (o LiveEventEndpointOutput) ToLiveEventEndpointOutputWithContext(ctx context.Context) LiveEventEndpointOutput {
	return o
}

// The endpoint protocol.
func (o LiveEventEndpointOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEndpoint) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// The endpoint URL.
func (o LiveEventEndpointOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEndpoint) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type LiveEventEndpointArrayOutput struct{ *pulumi.OutputState }

func (LiveEventEndpointArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventEndpoint)(nil)).Elem()
}

func (o LiveEventEndpointArrayOutput) ToLiveEventEndpointArrayOutput() LiveEventEndpointArrayOutput {
	return o
}

func (o LiveEventEndpointArrayOutput) ToLiveEventEndpointArrayOutputWithContext(ctx context.Context) LiveEventEndpointArrayOutput {
	return o
}

func (o LiveEventEndpointArrayOutput) Index(i pulumi.IntInput) LiveEventEndpointOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventEndpoint {
		return vs[0].([]LiveEventEndpoint)[vs[1].(int)]
	}).(LiveEventEndpointOutput)
}

// The live event endpoint.
type LiveEventEndpointResponse struct {
	// The endpoint protocol.
	Protocol *string `pulumi:"protocol"`
	// The endpoint URL.
	Url *string `pulumi:"url"`
}

// The live event endpoint.
type LiveEventEndpointResponseOutput struct{ *pulumi.OutputState }

func (LiveEventEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventEndpointResponse)(nil)).Elem()
}

func (o LiveEventEndpointResponseOutput) ToLiveEventEndpointResponseOutput() LiveEventEndpointResponseOutput {
	return o
}

func (o LiveEventEndpointResponseOutput) ToLiveEventEndpointResponseOutputWithContext(ctx context.Context) LiveEventEndpointResponseOutput {
	return o
}

// The endpoint protocol.
func (o LiveEventEndpointResponseOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEndpointResponse) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// The endpoint URL.
func (o LiveEventEndpointResponseOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventEndpointResponse) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type LiveEventEndpointResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventEndpointResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventEndpointResponse)(nil)).Elem()
}

func (o LiveEventEndpointResponseArrayOutput) ToLiveEventEndpointResponseArrayOutput() LiveEventEndpointResponseArrayOutput {
	return o
}

func (o LiveEventEndpointResponseArrayOutput) ToLiveEventEndpointResponseArrayOutputWithContext(ctx context.Context) LiveEventEndpointResponseArrayOutput {
	return o
}

func (o LiveEventEndpointResponseArrayOutput) Index(i pulumi.IntInput) LiveEventEndpointResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventEndpointResponse {
		return vs[0].([]LiveEventEndpointResponse)[vs[1].(int)]
	}).(LiveEventEndpointResponseOutput)
}

// The live event input.
type LiveEventInputType struct {
	// Access control for live event input.
	AccessControl *LiveEventInputAccessControl `pulumi:"accessControl"`
	// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
	AccessToken *string `pulumi:"accessToken"`
	// The input endpoints for the live event.
	Endpoints []LiveEventEndpoint `pulumi:"endpoints"`
	// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
	KeyFrameIntervalDuration *string `pulumi:"keyFrameIntervalDuration"`
	// The input protocol for the live event. This is specified at creation time and cannot be updated.
	StreamingProtocol string `pulumi:"streamingProtocol"`
}

// LiveEventInputTypeInput is an input type that accepts LiveEventInputTypeArgs and LiveEventInputTypeOutput values.
// You can construct a concrete instance of `LiveEventInputTypeInput` via:
//
//	LiveEventInputTypeArgs{...}
type LiveEventInputTypeInput interface {
	pulumi.Input

	ToLiveEventInputTypeOutput() LiveEventInputTypeOutput
	ToLiveEventInputTypeOutputWithContext(context.Context) LiveEventInputTypeOutput
}

// The live event input.
type LiveEventInputTypeArgs struct {
	// Access control for live event input.
	AccessControl LiveEventInputAccessControlPtrInput `pulumi:"accessControl"`
	// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
	AccessToken pulumi.StringPtrInput `pulumi:"accessToken"`
	// The input endpoints for the live event.
	Endpoints LiveEventEndpointArrayInput `pulumi:"endpoints"`
	// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
	KeyFrameIntervalDuration pulumi.StringPtrInput `pulumi:"keyFrameIntervalDuration"`
	// The input protocol for the live event. This is specified at creation time and cannot be updated.
	StreamingProtocol pulumi.StringInput `pulumi:"streamingProtocol"`
}

func (LiveEventInputTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputType)(nil)).Elem()
}

func (i LiveEventInputTypeArgs) ToLiveEventInputTypeOutput() LiveEventInputTypeOutput {
	return i.ToLiveEventInputTypeOutputWithContext(context.Background())
}

func (i LiveEventInputTypeArgs) ToLiveEventInputTypeOutputWithContext(ctx context.Context) LiveEventInputTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputTypeOutput)
}

// The live event input.
type LiveEventInputTypeOutput struct{ *pulumi.OutputState }

func (LiveEventInputTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputType)(nil)).Elem()
}

func (o LiveEventInputTypeOutput) ToLiveEventInputTypeOutput() LiveEventInputTypeOutput {
	return o
}

func (o LiveEventInputTypeOutput) ToLiveEventInputTypeOutputWithContext(ctx context.Context) LiveEventInputTypeOutput {
	return o
}

// Access control for live event input.
func (o LiveEventInputTypeOutput) AccessControl() LiveEventInputAccessControlPtrOutput {
	return o.ApplyT(func(v LiveEventInputType) *LiveEventInputAccessControl { return v.AccessControl }).(LiveEventInputAccessControlPtrOutput)
}

// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
func (o LiveEventInputTypeOutput) AccessToken() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputType) *string { return v.AccessToken }).(pulumi.StringPtrOutput)
}

// The input endpoints for the live event.
func (o LiveEventInputTypeOutput) Endpoints() LiveEventEndpointArrayOutput {
	return o.ApplyT(func(v LiveEventInputType) []LiveEventEndpoint { return v.Endpoints }).(LiveEventEndpointArrayOutput)
}

// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
func (o LiveEventInputTypeOutput) KeyFrameIntervalDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputType) *string { return v.KeyFrameIntervalDuration }).(pulumi.StringPtrOutput)
}

// The input protocol for the live event. This is specified at creation time and cannot be updated.
func (o LiveEventInputTypeOutput) StreamingProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LiveEventInputType) string { return v.StreamingProtocol }).(pulumi.StringOutput)
}

// The IP access control for live event input.
type LiveEventInputAccessControl struct {
	// The IP access control properties.
	Ip *IPAccessControl `pulumi:"ip"`
}

// LiveEventInputAccessControlInput is an input type that accepts LiveEventInputAccessControlArgs and LiveEventInputAccessControlOutput values.
// You can construct a concrete instance of `LiveEventInputAccessControlInput` via:
//
//	LiveEventInputAccessControlArgs{...}
type LiveEventInputAccessControlInput interface {
	pulumi.Input

	ToLiveEventInputAccessControlOutput() LiveEventInputAccessControlOutput
	ToLiveEventInputAccessControlOutputWithContext(context.Context) LiveEventInputAccessControlOutput
}

// The IP access control for live event input.
type LiveEventInputAccessControlArgs struct {
	// The IP access control properties.
	Ip IPAccessControlPtrInput `pulumi:"ip"`
}

func (LiveEventInputAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputAccessControl)(nil)).Elem()
}

func (i LiveEventInputAccessControlArgs) ToLiveEventInputAccessControlOutput() LiveEventInputAccessControlOutput {
	return i.ToLiveEventInputAccessControlOutputWithContext(context.Background())
}

func (i LiveEventInputAccessControlArgs) ToLiveEventInputAccessControlOutputWithContext(ctx context.Context) LiveEventInputAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputAccessControlOutput)
}

func (i LiveEventInputAccessControlArgs) ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput {
	return i.ToLiveEventInputAccessControlPtrOutputWithContext(context.Background())
}

func (i LiveEventInputAccessControlArgs) ToLiveEventInputAccessControlPtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputAccessControlOutput).ToLiveEventInputAccessControlPtrOutputWithContext(ctx)
}

// LiveEventInputAccessControlPtrInput is an input type that accepts LiveEventInputAccessControlArgs, LiveEventInputAccessControlPtr and LiveEventInputAccessControlPtrOutput values.
// You can construct a concrete instance of `LiveEventInputAccessControlPtrInput` via:
//
//	        LiveEventInputAccessControlArgs{...}
//
//	or:
//
//	        nil
type LiveEventInputAccessControlPtrInput interface {
	pulumi.Input

	ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput
	ToLiveEventInputAccessControlPtrOutputWithContext(context.Context) LiveEventInputAccessControlPtrOutput
}

type liveEventInputAccessControlPtrType LiveEventInputAccessControlArgs

func LiveEventInputAccessControlPtr(v *LiveEventInputAccessControlArgs) LiveEventInputAccessControlPtrInput {
	return (*liveEventInputAccessControlPtrType)(v)
}

func (*liveEventInputAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventInputAccessControl)(nil)).Elem()
}

func (i *liveEventInputAccessControlPtrType) ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput {
	return i.ToLiveEventInputAccessControlPtrOutputWithContext(context.Background())
}

func (i *liveEventInputAccessControlPtrType) ToLiveEventInputAccessControlPtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputAccessControlPtrOutput)
}

// The IP access control for live event input.
type LiveEventInputAccessControlOutput struct{ *pulumi.OutputState }

func (LiveEventInputAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputAccessControl)(nil)).Elem()
}

func (o LiveEventInputAccessControlOutput) ToLiveEventInputAccessControlOutput() LiveEventInputAccessControlOutput {
	return o
}

func (o LiveEventInputAccessControlOutput) ToLiveEventInputAccessControlOutputWithContext(ctx context.Context) LiveEventInputAccessControlOutput {
	return o
}

func (o LiveEventInputAccessControlOutput) ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput {
	return o.ToLiveEventInputAccessControlPtrOutputWithContext(context.Background())
}

func (o LiveEventInputAccessControlOutput) ToLiveEventInputAccessControlPtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventInputAccessControl) *LiveEventInputAccessControl {
		return &v
	}).(LiveEventInputAccessControlPtrOutput)
}

// The IP access control properties.
func (o LiveEventInputAccessControlOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v LiveEventInputAccessControl) *IPAccessControl { return v.Ip }).(IPAccessControlPtrOutput)
}

type LiveEventInputAccessControlPtrOutput struct{ *pulumi.OutputState }

func (LiveEventInputAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventInputAccessControl)(nil)).Elem()
}

func (o LiveEventInputAccessControlPtrOutput) ToLiveEventInputAccessControlPtrOutput() LiveEventInputAccessControlPtrOutput {
	return o
}

func (o LiveEventInputAccessControlPtrOutput) ToLiveEventInputAccessControlPtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlPtrOutput {
	return o
}

func (o LiveEventInputAccessControlPtrOutput) Elem() LiveEventInputAccessControlOutput {
	return o.ApplyT(func(v *LiveEventInputAccessControl) LiveEventInputAccessControl {
		if v != nil {
			return *v
		}
		var ret LiveEventInputAccessControl
		return ret
	}).(LiveEventInputAccessControlOutput)
}

// The IP access control properties.
func (o LiveEventInputAccessControlPtrOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v *LiveEventInputAccessControl) *IPAccessControl {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlPtrOutput)
}

// The IP access control for live event input.
type LiveEventInputAccessControlResponse struct {
	// The IP access control properties.
	Ip *IPAccessControlResponse `pulumi:"ip"`
}

// The IP access control for live event input.
type LiveEventInputAccessControlResponseOutput struct{ *pulumi.OutputState }

func (LiveEventInputAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputAccessControlResponse)(nil)).Elem()
}

func (o LiveEventInputAccessControlResponseOutput) ToLiveEventInputAccessControlResponseOutput() LiveEventInputAccessControlResponseOutput {
	return o
}

func (o LiveEventInputAccessControlResponseOutput) ToLiveEventInputAccessControlResponseOutputWithContext(ctx context.Context) LiveEventInputAccessControlResponseOutput {
	return o
}

// The IP access control properties.
func (o LiveEventInputAccessControlResponseOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v LiveEventInputAccessControlResponse) *IPAccessControlResponse { return v.Ip }).(IPAccessControlResponsePtrOutput)
}

type LiveEventInputAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventInputAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventInputAccessControlResponse)(nil)).Elem()
}

func (o LiveEventInputAccessControlResponsePtrOutput) ToLiveEventInputAccessControlResponsePtrOutput() LiveEventInputAccessControlResponsePtrOutput {
	return o
}

func (o LiveEventInputAccessControlResponsePtrOutput) ToLiveEventInputAccessControlResponsePtrOutputWithContext(ctx context.Context) LiveEventInputAccessControlResponsePtrOutput {
	return o
}

func (o LiveEventInputAccessControlResponsePtrOutput) Elem() LiveEventInputAccessControlResponseOutput {
	return o.ApplyT(func(v *LiveEventInputAccessControlResponse) LiveEventInputAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventInputAccessControlResponse
		return ret
	}).(LiveEventInputAccessControlResponseOutput)
}

// The IP access control properties.
func (o LiveEventInputAccessControlResponsePtrOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *LiveEventInputAccessControlResponse) *IPAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlResponsePtrOutput)
}

// The live event input.
type LiveEventInputResponse struct {
	// Access control for live event input.
	AccessControl *LiveEventInputAccessControlResponse `pulumi:"accessControl"`
	// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
	AccessToken *string `pulumi:"accessToken"`
	// The input endpoints for the live event.
	Endpoints []LiveEventEndpointResponse `pulumi:"endpoints"`
	// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
	KeyFrameIntervalDuration *string `pulumi:"keyFrameIntervalDuration"`
	// The input protocol for the live event. This is specified at creation time and cannot be updated.
	StreamingProtocol string `pulumi:"streamingProtocol"`
}

// The live event input.
type LiveEventInputResponseOutput struct{ *pulumi.OutputState }

func (LiveEventInputResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputResponse)(nil)).Elem()
}

func (o LiveEventInputResponseOutput) ToLiveEventInputResponseOutput() LiveEventInputResponseOutput {
	return o
}

func (o LiveEventInputResponseOutput) ToLiveEventInputResponseOutputWithContext(ctx context.Context) LiveEventInputResponseOutput {
	return o
}

// Access control for live event input.
func (o LiveEventInputResponseOutput) AccessControl() LiveEventInputAccessControlResponsePtrOutput {
	return o.ApplyT(func(v LiveEventInputResponse) *LiveEventInputAccessControlResponse { return v.AccessControl }).(LiveEventInputAccessControlResponsePtrOutput)
}

// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.
func (o LiveEventInputResponseOutput) AccessToken() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputResponse) *string { return v.AccessToken }).(pulumi.StringPtrOutput)
}

// The input endpoints for the live event.
func (o LiveEventInputResponseOutput) Endpoints() LiveEventEndpointResponseArrayOutput {
	return o.ApplyT(func(v LiveEventInputResponse) []LiveEventEndpointResponse { return v.Endpoints }).(LiveEventEndpointResponseArrayOutput)
}

// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
func (o LiveEventInputResponseOutput) KeyFrameIntervalDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputResponse) *string { return v.KeyFrameIntervalDuration }).(pulumi.StringPtrOutput)
}

// The input protocol for the live event. This is specified at creation time and cannot be updated.
func (o LiveEventInputResponseOutput) StreamingProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v LiveEventInputResponse) string { return v.StreamingProtocol }).(pulumi.StringOutput)
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelection struct {
	// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
	Operation *string `pulumi:"operation"`
	// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
	Property *string `pulumi:"property"`
	// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
	Value *string `pulumi:"value"`
}

// LiveEventInputTrackSelectionInput is an input type that accepts LiveEventInputTrackSelectionArgs and LiveEventInputTrackSelectionOutput values.
// You can construct a concrete instance of `LiveEventInputTrackSelectionInput` via:
//
//	LiveEventInputTrackSelectionArgs{...}
type LiveEventInputTrackSelectionInput interface {
	pulumi.Input

	ToLiveEventInputTrackSelectionOutput() LiveEventInputTrackSelectionOutput
	ToLiveEventInputTrackSelectionOutputWithContext(context.Context) LiveEventInputTrackSelectionOutput
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelectionArgs struct {
	// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
	Operation pulumi.StringPtrInput `pulumi:"operation"`
	// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
	Property pulumi.StringPtrInput `pulumi:"property"`
	// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (LiveEventInputTrackSelectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputTrackSelection)(nil)).Elem()
}

func (i LiveEventInputTrackSelectionArgs) ToLiveEventInputTrackSelectionOutput() LiveEventInputTrackSelectionOutput {
	return i.ToLiveEventInputTrackSelectionOutputWithContext(context.Background())
}

func (i LiveEventInputTrackSelectionArgs) ToLiveEventInputTrackSelectionOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputTrackSelectionOutput)
}

// LiveEventInputTrackSelectionArrayInput is an input type that accepts LiveEventInputTrackSelectionArray and LiveEventInputTrackSelectionArrayOutput values.
// You can construct a concrete instance of `LiveEventInputTrackSelectionArrayInput` via:
//
//	LiveEventInputTrackSelectionArray{ LiveEventInputTrackSelectionArgs{...} }
type LiveEventInputTrackSelectionArrayInput interface {
	pulumi.Input

	ToLiveEventInputTrackSelectionArrayOutput() LiveEventInputTrackSelectionArrayOutput
	ToLiveEventInputTrackSelectionArrayOutputWithContext(context.Context) LiveEventInputTrackSelectionArrayOutput
}

type LiveEventInputTrackSelectionArray []LiveEventInputTrackSelectionInput

func (LiveEventInputTrackSelectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventInputTrackSelection)(nil)).Elem()
}

func (i LiveEventInputTrackSelectionArray) ToLiveEventInputTrackSelectionArrayOutput() LiveEventInputTrackSelectionArrayOutput {
	return i.ToLiveEventInputTrackSelectionArrayOutputWithContext(context.Background())
}

func (i LiveEventInputTrackSelectionArray) ToLiveEventInputTrackSelectionArrayOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventInputTrackSelectionArrayOutput)
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelectionOutput struct{ *pulumi.OutputState }

func (LiveEventInputTrackSelectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputTrackSelection)(nil)).Elem()
}

func (o LiveEventInputTrackSelectionOutput) ToLiveEventInputTrackSelectionOutput() LiveEventInputTrackSelectionOutput {
	return o
}

func (o LiveEventInputTrackSelectionOutput) ToLiveEventInputTrackSelectionOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionOutput {
	return o
}

// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionOutput) Operation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelection) *string { return v.Operation }).(pulumi.StringPtrOutput)
}

// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionOutput) Property() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelection) *string { return v.Property }).(pulumi.StringPtrOutput)
}

// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelection) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type LiveEventInputTrackSelectionArrayOutput struct{ *pulumi.OutputState }

func (LiveEventInputTrackSelectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventInputTrackSelection)(nil)).Elem()
}

func (o LiveEventInputTrackSelectionArrayOutput) ToLiveEventInputTrackSelectionArrayOutput() LiveEventInputTrackSelectionArrayOutput {
	return o
}

func (o LiveEventInputTrackSelectionArrayOutput) ToLiveEventInputTrackSelectionArrayOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionArrayOutput {
	return o
}

func (o LiveEventInputTrackSelectionArrayOutput) Index(i pulumi.IntInput) LiveEventInputTrackSelectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventInputTrackSelection {
		return vs[0].([]LiveEventInputTrackSelection)[vs[1].(int)]
	}).(LiveEventInputTrackSelectionOutput)
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelectionResponse struct {
	// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
	Operation *string `pulumi:"operation"`
	// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
	Property *string `pulumi:"property"`
	// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
	Value *string `pulumi:"value"`
}

// A track selection condition. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventInputTrackSelectionResponseOutput struct{ *pulumi.OutputState }

func (LiveEventInputTrackSelectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventInputTrackSelectionResponse)(nil)).Elem()
}

func (o LiveEventInputTrackSelectionResponseOutput) ToLiveEventInputTrackSelectionResponseOutput() LiveEventInputTrackSelectionResponseOutput {
	return o
}

func (o LiveEventInputTrackSelectionResponseOutput) ToLiveEventInputTrackSelectionResponseOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionResponseOutput {
	return o
}

// Comparing operation. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionResponseOutput) Operation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelectionResponse) *string { return v.Operation }).(pulumi.StringPtrOutput)
}

// Property name to select. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionResponseOutput) Property() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelectionResponse) *string { return v.Property }).(pulumi.StringPtrOutput)
}

// Property value to select. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventInputTrackSelectionResponseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventInputTrackSelectionResponse) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type LiveEventInputTrackSelectionResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventInputTrackSelectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventInputTrackSelectionResponse)(nil)).Elem()
}

func (o LiveEventInputTrackSelectionResponseArrayOutput) ToLiveEventInputTrackSelectionResponseArrayOutput() LiveEventInputTrackSelectionResponseArrayOutput {
	return o
}

func (o LiveEventInputTrackSelectionResponseArrayOutput) ToLiveEventInputTrackSelectionResponseArrayOutputWithContext(ctx context.Context) LiveEventInputTrackSelectionResponseArrayOutput {
	return o
}

func (o LiveEventInputTrackSelectionResponseArrayOutput) Index(i pulumi.IntInput) LiveEventInputTrackSelectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventInputTrackSelectionResponse {
		return vs[0].([]LiveEventInputTrackSelectionResponse)[vs[1].(int)]
	}).(LiveEventInputTrackSelectionResponseOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrack struct {
	// The output track name. This property is reserved for future use, any value set on this property will be ignored.
	TrackName string `pulumi:"trackName"`
}

// LiveEventOutputTranscriptionTrackInput is an input type that accepts LiveEventOutputTranscriptionTrackArgs and LiveEventOutputTranscriptionTrackOutput values.
// You can construct a concrete instance of `LiveEventOutputTranscriptionTrackInput` via:
//
//	LiveEventOutputTranscriptionTrackArgs{...}
type LiveEventOutputTranscriptionTrackInput interface {
	pulumi.Input

	ToLiveEventOutputTranscriptionTrackOutput() LiveEventOutputTranscriptionTrackOutput
	ToLiveEventOutputTranscriptionTrackOutputWithContext(context.Context) LiveEventOutputTranscriptionTrackOutput
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrackArgs struct {
	// The output track name. This property is reserved for future use, any value set on this property will be ignored.
	TrackName pulumi.StringInput `pulumi:"trackName"`
}

func (LiveEventOutputTranscriptionTrackArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventOutputTranscriptionTrack)(nil)).Elem()
}

func (i LiveEventOutputTranscriptionTrackArgs) ToLiveEventOutputTranscriptionTrackOutput() LiveEventOutputTranscriptionTrackOutput {
	return i.ToLiveEventOutputTranscriptionTrackOutputWithContext(context.Background())
}

func (i LiveEventOutputTranscriptionTrackArgs) ToLiveEventOutputTranscriptionTrackOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventOutputTranscriptionTrackOutput)
}

func (i LiveEventOutputTranscriptionTrackArgs) ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput {
	return i.ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(context.Background())
}

func (i LiveEventOutputTranscriptionTrackArgs) ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventOutputTranscriptionTrackOutput).ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx)
}

// LiveEventOutputTranscriptionTrackPtrInput is an input type that accepts LiveEventOutputTranscriptionTrackArgs, LiveEventOutputTranscriptionTrackPtr and LiveEventOutputTranscriptionTrackPtrOutput values.
// You can construct a concrete instance of `LiveEventOutputTranscriptionTrackPtrInput` via:
//
//	        LiveEventOutputTranscriptionTrackArgs{...}
//
//	or:
//
//	        nil
type LiveEventOutputTranscriptionTrackPtrInput interface {
	pulumi.Input

	ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput
	ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(context.Context) LiveEventOutputTranscriptionTrackPtrOutput
}

type liveEventOutputTranscriptionTrackPtrType LiveEventOutputTranscriptionTrackArgs

func LiveEventOutputTranscriptionTrackPtr(v *LiveEventOutputTranscriptionTrackArgs) LiveEventOutputTranscriptionTrackPtrInput {
	return (*liveEventOutputTranscriptionTrackPtrType)(v)
}

func (*liveEventOutputTranscriptionTrackPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventOutputTranscriptionTrack)(nil)).Elem()
}

func (i *liveEventOutputTranscriptionTrackPtrType) ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput {
	return i.ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(context.Background())
}

func (i *liveEventOutputTranscriptionTrackPtrType) ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventOutputTranscriptionTrackPtrOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrackOutput struct{ *pulumi.OutputState }

func (LiveEventOutputTranscriptionTrackOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventOutputTranscriptionTrack)(nil)).Elem()
}

func (o LiveEventOutputTranscriptionTrackOutput) ToLiveEventOutputTranscriptionTrackOutput() LiveEventOutputTranscriptionTrackOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackOutput) ToLiveEventOutputTranscriptionTrackOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackOutput) ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput {
	return o.ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(context.Background())
}

func (o LiveEventOutputTranscriptionTrackOutput) ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventOutputTranscriptionTrack) *LiveEventOutputTranscriptionTrack {
		return &v
	}).(LiveEventOutputTranscriptionTrackPtrOutput)
}

// The output track name. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventOutputTranscriptionTrackOutput) TrackName() pulumi.StringOutput {
	return o.ApplyT(func(v LiveEventOutputTranscriptionTrack) string { return v.TrackName }).(pulumi.StringOutput)
}

type LiveEventOutputTranscriptionTrackPtrOutput struct{ *pulumi.OutputState }

func (LiveEventOutputTranscriptionTrackPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventOutputTranscriptionTrack)(nil)).Elem()
}

func (o LiveEventOutputTranscriptionTrackPtrOutput) ToLiveEventOutputTranscriptionTrackPtrOutput() LiveEventOutputTranscriptionTrackPtrOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackPtrOutput) ToLiveEventOutputTranscriptionTrackPtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackPtrOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackPtrOutput) Elem() LiveEventOutputTranscriptionTrackOutput {
	return o.ApplyT(func(v *LiveEventOutputTranscriptionTrack) LiveEventOutputTranscriptionTrack {
		if v != nil {
			return *v
		}
		var ret LiveEventOutputTranscriptionTrack
		return ret
	}).(LiveEventOutputTranscriptionTrackOutput)
}

// The output track name. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventOutputTranscriptionTrackPtrOutput) TrackName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventOutputTranscriptionTrack) *string {
		if v == nil {
			return nil
		}
		return &v.TrackName
	}).(pulumi.StringPtrOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrackResponse struct {
	// The output track name. This property is reserved for future use, any value set on this property will be ignored.
	TrackName string `pulumi:"trackName"`
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventOutputTranscriptionTrackResponseOutput struct{ *pulumi.OutputState }

func (LiveEventOutputTranscriptionTrackResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventOutputTranscriptionTrackResponse)(nil)).Elem()
}

func (o LiveEventOutputTranscriptionTrackResponseOutput) ToLiveEventOutputTranscriptionTrackResponseOutput() LiveEventOutputTranscriptionTrackResponseOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackResponseOutput) ToLiveEventOutputTranscriptionTrackResponseOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackResponseOutput {
	return o
}

// The output track name. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventOutputTranscriptionTrackResponseOutput) TrackName() pulumi.StringOutput {
	return o.ApplyT(func(v LiveEventOutputTranscriptionTrackResponse) string { return v.TrackName }).(pulumi.StringOutput)
}

type LiveEventOutputTranscriptionTrackResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventOutputTranscriptionTrackResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventOutputTranscriptionTrackResponse)(nil)).Elem()
}

func (o LiveEventOutputTranscriptionTrackResponsePtrOutput) ToLiveEventOutputTranscriptionTrackResponsePtrOutput() LiveEventOutputTranscriptionTrackResponsePtrOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackResponsePtrOutput) ToLiveEventOutputTranscriptionTrackResponsePtrOutputWithContext(ctx context.Context) LiveEventOutputTranscriptionTrackResponsePtrOutput {
	return o
}

func (o LiveEventOutputTranscriptionTrackResponsePtrOutput) Elem() LiveEventOutputTranscriptionTrackResponseOutput {
	return o.ApplyT(func(v *LiveEventOutputTranscriptionTrackResponse) LiveEventOutputTranscriptionTrackResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventOutputTranscriptionTrackResponse
		return ret
	}).(LiveEventOutputTranscriptionTrackResponseOutput)
}

// The output track name. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventOutputTranscriptionTrackResponsePtrOutput) TrackName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventOutputTranscriptionTrackResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TrackName
	}).(pulumi.StringPtrOutput)
}

// Live event preview settings.
type LiveEventPreview struct {
	// The access control for live event preview.
	AccessControl *LiveEventPreviewAccessControl `pulumi:"accessControl"`
	// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
	AlternativeMediaId *string `pulumi:"alternativeMediaId"`
	// The endpoints for preview. Do not share the preview URL with the live event audience.
	Endpoints []LiveEventEndpoint `pulumi:"endpoints"`
	// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
	PreviewLocator *string `pulumi:"previewLocator"`
	// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
	StreamingPolicyName *string `pulumi:"streamingPolicyName"`
}

// LiveEventPreviewInput is an input type that accepts LiveEventPreviewArgs and LiveEventPreviewOutput values.
// You can construct a concrete instance of `LiveEventPreviewInput` via:
//
//	LiveEventPreviewArgs{...}
type LiveEventPreviewInput interface {
	pulumi.Input

	ToLiveEventPreviewOutput() LiveEventPreviewOutput
	ToLiveEventPreviewOutputWithContext(context.Context) LiveEventPreviewOutput
}

// Live event preview settings.
type LiveEventPreviewArgs struct {
	// The access control for live event preview.
	AccessControl LiveEventPreviewAccessControlPtrInput `pulumi:"accessControl"`
	// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
	AlternativeMediaId pulumi.StringPtrInput `pulumi:"alternativeMediaId"`
	// The endpoints for preview. Do not share the preview URL with the live event audience.
	Endpoints LiveEventEndpointArrayInput `pulumi:"endpoints"`
	// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
	PreviewLocator pulumi.StringPtrInput `pulumi:"previewLocator"`
	// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
	StreamingPolicyName pulumi.StringPtrInput `pulumi:"streamingPolicyName"`
}

func (LiveEventPreviewArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreview)(nil)).Elem()
}

func (i LiveEventPreviewArgs) ToLiveEventPreviewOutput() LiveEventPreviewOutput {
	return i.ToLiveEventPreviewOutputWithContext(context.Background())
}

func (i LiveEventPreviewArgs) ToLiveEventPreviewOutputWithContext(ctx context.Context) LiveEventPreviewOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewOutput)
}

func (i LiveEventPreviewArgs) ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput {
	return i.ToLiveEventPreviewPtrOutputWithContext(context.Background())
}

func (i LiveEventPreviewArgs) ToLiveEventPreviewPtrOutputWithContext(ctx context.Context) LiveEventPreviewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewOutput).ToLiveEventPreviewPtrOutputWithContext(ctx)
}

// LiveEventPreviewPtrInput is an input type that accepts LiveEventPreviewArgs, LiveEventPreviewPtr and LiveEventPreviewPtrOutput values.
// You can construct a concrete instance of `LiveEventPreviewPtrInput` via:
//
//	        LiveEventPreviewArgs{...}
//
//	or:
//
//	        nil
type LiveEventPreviewPtrInput interface {
	pulumi.Input

	ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput
	ToLiveEventPreviewPtrOutputWithContext(context.Context) LiveEventPreviewPtrOutput
}

type liveEventPreviewPtrType LiveEventPreviewArgs

func LiveEventPreviewPtr(v *LiveEventPreviewArgs) LiveEventPreviewPtrInput {
	return (*liveEventPreviewPtrType)(v)
}

func (*liveEventPreviewPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreview)(nil)).Elem()
}

func (i *liveEventPreviewPtrType) ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput {
	return i.ToLiveEventPreviewPtrOutputWithContext(context.Background())
}

func (i *liveEventPreviewPtrType) ToLiveEventPreviewPtrOutputWithContext(ctx context.Context) LiveEventPreviewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewPtrOutput)
}

// Live event preview settings.
type LiveEventPreviewOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreview)(nil)).Elem()
}

func (o LiveEventPreviewOutput) ToLiveEventPreviewOutput() LiveEventPreviewOutput {
	return o
}

func (o LiveEventPreviewOutput) ToLiveEventPreviewOutputWithContext(ctx context.Context) LiveEventPreviewOutput {
	return o
}

func (o LiveEventPreviewOutput) ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput {
	return o.ToLiveEventPreviewPtrOutputWithContext(context.Background())
}

func (o LiveEventPreviewOutput) ToLiveEventPreviewPtrOutputWithContext(ctx context.Context) LiveEventPreviewPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventPreview) *LiveEventPreview {
		return &v
	}).(LiveEventPreviewPtrOutput)
}

// The access control for live event preview.
func (o LiveEventPreviewOutput) AccessControl() LiveEventPreviewAccessControlPtrOutput {
	return o.ApplyT(func(v LiveEventPreview) *LiveEventPreviewAccessControl { return v.AccessControl }).(LiveEventPreviewAccessControlPtrOutput)
}

// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
func (o LiveEventPreviewOutput) AlternativeMediaId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreview) *string { return v.AlternativeMediaId }).(pulumi.StringPtrOutput)
}

// The endpoints for preview. Do not share the preview URL with the live event audience.
func (o LiveEventPreviewOutput) Endpoints() LiveEventEndpointArrayOutput {
	return o.ApplyT(func(v LiveEventPreview) []LiveEventEndpoint { return v.Endpoints }).(LiveEventEndpointArrayOutput)
}

// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
func (o LiveEventPreviewOutput) PreviewLocator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreview) *string { return v.PreviewLocator }).(pulumi.StringPtrOutput)
}

// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
func (o LiveEventPreviewOutput) StreamingPolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreview) *string { return v.StreamingPolicyName }).(pulumi.StringPtrOutput)
}

type LiveEventPreviewPtrOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreview)(nil)).Elem()
}

func (o LiveEventPreviewPtrOutput) ToLiveEventPreviewPtrOutput() LiveEventPreviewPtrOutput {
	return o
}

func (o LiveEventPreviewPtrOutput) ToLiveEventPreviewPtrOutputWithContext(ctx context.Context) LiveEventPreviewPtrOutput {
	return o
}

func (o LiveEventPreviewPtrOutput) Elem() LiveEventPreviewOutput {
	return o.ApplyT(func(v *LiveEventPreview) LiveEventPreview {
		if v != nil {
			return *v
		}
		var ret LiveEventPreview
		return ret
	}).(LiveEventPreviewOutput)
}

// The access control for live event preview.
func (o LiveEventPreviewPtrOutput) AccessControl() LiveEventPreviewAccessControlPtrOutput {
	return o.ApplyT(func(v *LiveEventPreview) *LiveEventPreviewAccessControl {
		if v == nil {
			return nil
		}
		return v.AccessControl
	}).(LiveEventPreviewAccessControlPtrOutput)
}

// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
func (o LiveEventPreviewPtrOutput) AlternativeMediaId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreview) *string {
		if v == nil {
			return nil
		}
		return v.AlternativeMediaId
	}).(pulumi.StringPtrOutput)
}

// The endpoints for preview. Do not share the preview URL with the live event audience.
func (o LiveEventPreviewPtrOutput) Endpoints() LiveEventEndpointArrayOutput {
	return o.ApplyT(func(v *LiveEventPreview) []LiveEventEndpoint {
		if v == nil {
			return nil
		}
		return v.Endpoints
	}).(LiveEventEndpointArrayOutput)
}

// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
func (o LiveEventPreviewPtrOutput) PreviewLocator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreview) *string {
		if v == nil {
			return nil
		}
		return v.PreviewLocator
	}).(pulumi.StringPtrOutput)
}

// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
func (o LiveEventPreviewPtrOutput) StreamingPolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreview) *string {
		if v == nil {
			return nil
		}
		return v.StreamingPolicyName
	}).(pulumi.StringPtrOutput)
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControl struct {
	// The IP access control properties.
	Ip *IPAccessControl `pulumi:"ip"`
}

// LiveEventPreviewAccessControlInput is an input type that accepts LiveEventPreviewAccessControlArgs and LiveEventPreviewAccessControlOutput values.
// You can construct a concrete instance of `LiveEventPreviewAccessControlInput` via:
//
//	LiveEventPreviewAccessControlArgs{...}
type LiveEventPreviewAccessControlInput interface {
	pulumi.Input

	ToLiveEventPreviewAccessControlOutput() LiveEventPreviewAccessControlOutput
	ToLiveEventPreviewAccessControlOutputWithContext(context.Context) LiveEventPreviewAccessControlOutput
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControlArgs struct {
	// The IP access control properties.
	Ip IPAccessControlPtrInput `pulumi:"ip"`
}

func (LiveEventPreviewAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreviewAccessControl)(nil)).Elem()
}

func (i LiveEventPreviewAccessControlArgs) ToLiveEventPreviewAccessControlOutput() LiveEventPreviewAccessControlOutput {
	return i.ToLiveEventPreviewAccessControlOutputWithContext(context.Background())
}

func (i LiveEventPreviewAccessControlArgs) ToLiveEventPreviewAccessControlOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewAccessControlOutput)
}

func (i LiveEventPreviewAccessControlArgs) ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput {
	return i.ToLiveEventPreviewAccessControlPtrOutputWithContext(context.Background())
}

func (i LiveEventPreviewAccessControlArgs) ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewAccessControlOutput).ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx)
}

// LiveEventPreviewAccessControlPtrInput is an input type that accepts LiveEventPreviewAccessControlArgs, LiveEventPreviewAccessControlPtr and LiveEventPreviewAccessControlPtrOutput values.
// You can construct a concrete instance of `LiveEventPreviewAccessControlPtrInput` via:
//
//	        LiveEventPreviewAccessControlArgs{...}
//
//	or:
//
//	        nil
type LiveEventPreviewAccessControlPtrInput interface {
	pulumi.Input

	ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput
	ToLiveEventPreviewAccessControlPtrOutputWithContext(context.Context) LiveEventPreviewAccessControlPtrOutput
}

type liveEventPreviewAccessControlPtrType LiveEventPreviewAccessControlArgs

func LiveEventPreviewAccessControlPtr(v *LiveEventPreviewAccessControlArgs) LiveEventPreviewAccessControlPtrInput {
	return (*liveEventPreviewAccessControlPtrType)(v)
}

func (*liveEventPreviewAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreviewAccessControl)(nil)).Elem()
}

func (i *liveEventPreviewAccessControlPtrType) ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput {
	return i.ToLiveEventPreviewAccessControlPtrOutputWithContext(context.Background())
}

func (i *liveEventPreviewAccessControlPtrType) ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventPreviewAccessControlPtrOutput)
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControlOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreviewAccessControl)(nil)).Elem()
}

func (o LiveEventPreviewAccessControlOutput) ToLiveEventPreviewAccessControlOutput() LiveEventPreviewAccessControlOutput {
	return o
}

func (o LiveEventPreviewAccessControlOutput) ToLiveEventPreviewAccessControlOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlOutput {
	return o
}

func (o LiveEventPreviewAccessControlOutput) ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput {
	return o.ToLiveEventPreviewAccessControlPtrOutputWithContext(context.Background())
}

func (o LiveEventPreviewAccessControlOutput) ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LiveEventPreviewAccessControl) *LiveEventPreviewAccessControl {
		return &v
	}).(LiveEventPreviewAccessControlPtrOutput)
}

// The IP access control properties.
func (o LiveEventPreviewAccessControlOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v LiveEventPreviewAccessControl) *IPAccessControl { return v.Ip }).(IPAccessControlPtrOutput)
}

type LiveEventPreviewAccessControlPtrOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreviewAccessControl)(nil)).Elem()
}

func (o LiveEventPreviewAccessControlPtrOutput) ToLiveEventPreviewAccessControlPtrOutput() LiveEventPreviewAccessControlPtrOutput {
	return o
}

func (o LiveEventPreviewAccessControlPtrOutput) ToLiveEventPreviewAccessControlPtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlPtrOutput {
	return o
}

func (o LiveEventPreviewAccessControlPtrOutput) Elem() LiveEventPreviewAccessControlOutput {
	return o.ApplyT(func(v *LiveEventPreviewAccessControl) LiveEventPreviewAccessControl {
		if v != nil {
			return *v
		}
		var ret LiveEventPreviewAccessControl
		return ret
	}).(LiveEventPreviewAccessControlOutput)
}

// The IP access control properties.
func (o LiveEventPreviewAccessControlPtrOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewAccessControl) *IPAccessControl {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlPtrOutput)
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControlResponse struct {
	// The IP access control properties.
	Ip *IPAccessControlResponse `pulumi:"ip"`
}

// The IP access control for the live event preview endpoint.
type LiveEventPreviewAccessControlResponseOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreviewAccessControlResponse)(nil)).Elem()
}

func (o LiveEventPreviewAccessControlResponseOutput) ToLiveEventPreviewAccessControlResponseOutput() LiveEventPreviewAccessControlResponseOutput {
	return o
}

func (o LiveEventPreviewAccessControlResponseOutput) ToLiveEventPreviewAccessControlResponseOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlResponseOutput {
	return o
}

// The IP access control properties.
func (o LiveEventPreviewAccessControlResponseOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v LiveEventPreviewAccessControlResponse) *IPAccessControlResponse { return v.Ip }).(IPAccessControlResponsePtrOutput)
}

type LiveEventPreviewAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreviewAccessControlResponse)(nil)).Elem()
}

func (o LiveEventPreviewAccessControlResponsePtrOutput) ToLiveEventPreviewAccessControlResponsePtrOutput() LiveEventPreviewAccessControlResponsePtrOutput {
	return o
}

func (o LiveEventPreviewAccessControlResponsePtrOutput) ToLiveEventPreviewAccessControlResponsePtrOutputWithContext(ctx context.Context) LiveEventPreviewAccessControlResponsePtrOutput {
	return o
}

func (o LiveEventPreviewAccessControlResponsePtrOutput) Elem() LiveEventPreviewAccessControlResponseOutput {
	return o.ApplyT(func(v *LiveEventPreviewAccessControlResponse) LiveEventPreviewAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventPreviewAccessControlResponse
		return ret
	}).(LiveEventPreviewAccessControlResponseOutput)
}

// The IP access control properties.
func (o LiveEventPreviewAccessControlResponsePtrOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewAccessControlResponse) *IPAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlResponsePtrOutput)
}

// Live event preview settings.
type LiveEventPreviewResponse struct {
	// The access control for live event preview.
	AccessControl *LiveEventPreviewAccessControlResponse `pulumi:"accessControl"`
	// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
	AlternativeMediaId *string `pulumi:"alternativeMediaId"`
	// The endpoints for preview. Do not share the preview URL with the live event audience.
	Endpoints []LiveEventEndpointResponse `pulumi:"endpoints"`
	// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
	PreviewLocator *string `pulumi:"previewLocator"`
	// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
	StreamingPolicyName *string `pulumi:"streamingPolicyName"`
}

// Live event preview settings.
type LiveEventPreviewResponseOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventPreviewResponse)(nil)).Elem()
}

func (o LiveEventPreviewResponseOutput) ToLiveEventPreviewResponseOutput() LiveEventPreviewResponseOutput {
	return o
}

func (o LiveEventPreviewResponseOutput) ToLiveEventPreviewResponseOutputWithContext(ctx context.Context) LiveEventPreviewResponseOutput {
	return o
}

// The access control for live event preview.
func (o LiveEventPreviewResponseOutput) AccessControl() LiveEventPreviewAccessControlResponsePtrOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) *LiveEventPreviewAccessControlResponse { return v.AccessControl }).(LiveEventPreviewAccessControlResponsePtrOutput)
}

// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
func (o LiveEventPreviewResponseOutput) AlternativeMediaId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) *string { return v.AlternativeMediaId }).(pulumi.StringPtrOutput)
}

// The endpoints for preview. Do not share the preview URL with the live event audience.
func (o LiveEventPreviewResponseOutput) Endpoints() LiveEventEndpointResponseArrayOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) []LiveEventEndpointResponse { return v.Endpoints }).(LiveEventEndpointResponseArrayOutput)
}

// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
func (o LiveEventPreviewResponseOutput) PreviewLocator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) *string { return v.PreviewLocator }).(pulumi.StringPtrOutput)
}

// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
func (o LiveEventPreviewResponseOutput) StreamingPolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventPreviewResponse) *string { return v.StreamingPolicyName }).(pulumi.StringPtrOutput)
}

type LiveEventPreviewResponsePtrOutput struct{ *pulumi.OutputState }

func (LiveEventPreviewResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LiveEventPreviewResponse)(nil)).Elem()
}

func (o LiveEventPreviewResponsePtrOutput) ToLiveEventPreviewResponsePtrOutput() LiveEventPreviewResponsePtrOutput {
	return o
}

func (o LiveEventPreviewResponsePtrOutput) ToLiveEventPreviewResponsePtrOutputWithContext(ctx context.Context) LiveEventPreviewResponsePtrOutput {
	return o
}

func (o LiveEventPreviewResponsePtrOutput) Elem() LiveEventPreviewResponseOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) LiveEventPreviewResponse {
		if v != nil {
			return *v
		}
		var ret LiveEventPreviewResponse
		return ret
	}).(LiveEventPreviewResponseOutput)
}

// The access control for live event preview.
func (o LiveEventPreviewResponsePtrOutput) AccessControl() LiveEventPreviewAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) *LiveEventPreviewAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.AccessControl
	}).(LiveEventPreviewAccessControlResponsePtrOutput)
}

// An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
func (o LiveEventPreviewResponsePtrOutput) AlternativeMediaId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) *string {
		if v == nil {
			return nil
		}
		return v.AlternativeMediaId
	}).(pulumi.StringPtrOutput)
}

// The endpoints for preview. Do not share the preview URL with the live event audience.
func (o LiveEventPreviewResponsePtrOutput) Endpoints() LiveEventEndpointResponseArrayOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) []LiveEventEndpointResponse {
		if v == nil {
			return nil
		}
		return v.Endpoints
	}).(LiveEventEndpointResponseArrayOutput)
}

// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.
func (o LiveEventPreviewResponsePtrOutput) PreviewLocator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) *string {
		if v == nil {
			return nil
		}
		return v.PreviewLocator
	}).(pulumi.StringPtrOutput)
}

// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
func (o LiveEventPreviewResponsePtrOutput) StreamingPolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LiveEventPreviewResponse) *string {
		if v == nil {
			return nil
		}
		return v.StreamingPolicyName
	}).(pulumi.StringPtrOutput)
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscription struct {
	// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
	InputTrackSelection []LiveEventInputTrackSelection `pulumi:"inputTrackSelection"`
	// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
	Language *string `pulumi:"language"`
	// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
	OutputTranscriptionTrack *LiveEventOutputTranscriptionTrack `pulumi:"outputTranscriptionTrack"`
}

// LiveEventTranscriptionInput is an input type that accepts LiveEventTranscriptionArgs and LiveEventTranscriptionOutput values.
// You can construct a concrete instance of `LiveEventTranscriptionInput` via:
//
//	LiveEventTranscriptionArgs{...}
type LiveEventTranscriptionInput interface {
	pulumi.Input

	ToLiveEventTranscriptionOutput() LiveEventTranscriptionOutput
	ToLiveEventTranscriptionOutputWithContext(context.Context) LiveEventTranscriptionOutput
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscriptionArgs struct {
	// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
	InputTrackSelection LiveEventInputTrackSelectionArrayInput `pulumi:"inputTrackSelection"`
	// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
	Language pulumi.StringPtrInput `pulumi:"language"`
	// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
	OutputTranscriptionTrack LiveEventOutputTranscriptionTrackPtrInput `pulumi:"outputTranscriptionTrack"`
}

func (LiveEventTranscriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTranscription)(nil)).Elem()
}

func (i LiveEventTranscriptionArgs) ToLiveEventTranscriptionOutput() LiveEventTranscriptionOutput {
	return i.ToLiveEventTranscriptionOutputWithContext(context.Background())
}

func (i LiveEventTranscriptionArgs) ToLiveEventTranscriptionOutputWithContext(ctx context.Context) LiveEventTranscriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventTranscriptionOutput)
}

// LiveEventTranscriptionArrayInput is an input type that accepts LiveEventTranscriptionArray and LiveEventTranscriptionArrayOutput values.
// You can construct a concrete instance of `LiveEventTranscriptionArrayInput` via:
//
//	LiveEventTranscriptionArray{ LiveEventTranscriptionArgs{...} }
type LiveEventTranscriptionArrayInput interface {
	pulumi.Input

	ToLiveEventTranscriptionArrayOutput() LiveEventTranscriptionArrayOutput
	ToLiveEventTranscriptionArrayOutputWithContext(context.Context) LiveEventTranscriptionArrayOutput
}

type LiveEventTranscriptionArray []LiveEventTranscriptionInput

func (LiveEventTranscriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTranscription)(nil)).Elem()
}

func (i LiveEventTranscriptionArray) ToLiveEventTranscriptionArrayOutput() LiveEventTranscriptionArrayOutput {
	return i.ToLiveEventTranscriptionArrayOutputWithContext(context.Background())
}

func (i LiveEventTranscriptionArray) ToLiveEventTranscriptionArrayOutputWithContext(ctx context.Context) LiveEventTranscriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LiveEventTranscriptionArrayOutput)
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscriptionOutput struct{ *pulumi.OutputState }

func (LiveEventTranscriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTranscription)(nil)).Elem()
}

func (o LiveEventTranscriptionOutput) ToLiveEventTranscriptionOutput() LiveEventTranscriptionOutput {
	return o
}

func (o LiveEventTranscriptionOutput) ToLiveEventTranscriptionOutputWithContext(ctx context.Context) LiveEventTranscriptionOutput {
	return o
}

// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventTranscriptionOutput) InputTrackSelection() LiveEventInputTrackSelectionArrayOutput {
	return o.ApplyT(func(v LiveEventTranscription) []LiveEventInputTrackSelection { return v.InputTrackSelection }).(LiveEventInputTrackSelectionArrayOutput)
}

// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
func (o LiveEventTranscriptionOutput) Language() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTranscription) *string { return v.Language }).(pulumi.StringPtrOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventTranscriptionOutput) OutputTranscriptionTrack() LiveEventOutputTranscriptionTrackPtrOutput {
	return o.ApplyT(func(v LiveEventTranscription) *LiveEventOutputTranscriptionTrack { return v.OutputTranscriptionTrack }).(LiveEventOutputTranscriptionTrackPtrOutput)
}

type LiveEventTranscriptionArrayOutput struct{ *pulumi.OutputState }

func (LiveEventTranscriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTranscription)(nil)).Elem()
}

func (o LiveEventTranscriptionArrayOutput) ToLiveEventTranscriptionArrayOutput() LiveEventTranscriptionArrayOutput {
	return o
}

func (o LiveEventTranscriptionArrayOutput) ToLiveEventTranscriptionArrayOutputWithContext(ctx context.Context) LiveEventTranscriptionArrayOutput {
	return o
}

func (o LiveEventTranscriptionArrayOutput) Index(i pulumi.IntInput) LiveEventTranscriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventTranscription {
		return vs[0].([]LiveEventTranscription)[vs[1].(int)]
	}).(LiveEventTranscriptionOutput)
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscriptionResponse struct {
	// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
	InputTrackSelection []LiveEventInputTrackSelectionResponse `pulumi:"inputTrackSelection"`
	// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
	Language *string `pulumi:"language"`
	// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
	OutputTranscriptionTrack *LiveEventOutputTranscriptionTrackResponse `pulumi:"outputTranscriptionTrack"`
}

// Describes the transcription tracks in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
type LiveEventTranscriptionResponseOutput struct{ *pulumi.OutputState }

func (LiveEventTranscriptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LiveEventTranscriptionResponse)(nil)).Elem()
}

func (o LiveEventTranscriptionResponseOutput) ToLiveEventTranscriptionResponseOutput() LiveEventTranscriptionResponseOutput {
	return o
}

func (o LiveEventTranscriptionResponseOutput) ToLiveEventTranscriptionResponseOutputWithContext(ctx context.Context) LiveEventTranscriptionResponseOutput {
	return o
}

// Provides a mechanism to select the audio track in the input live feed, to which speech-to-text transcription is applied. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventTranscriptionResponseOutput) InputTrackSelection() LiveEventInputTrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v LiveEventTranscriptionResponse) []LiveEventInputTrackSelectionResponse {
		return v.InputTrackSelection
	}).(LiveEventInputTrackSelectionResponseArrayOutput)
}

// Specifies the language (locale) to be used for speech-to-text transcription – it should match the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US'). See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live transcription feature and the list of supported languages.
func (o LiveEventTranscriptionResponseOutput) Language() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LiveEventTranscriptionResponse) *string { return v.Language }).(pulumi.StringPtrOutput)
}

// Describes a transcription track in the output of a live event, generated using speech-to-text transcription. This property is reserved for future use, any value set on this property will be ignored.
func (o LiveEventTranscriptionResponseOutput) OutputTranscriptionTrack() LiveEventOutputTranscriptionTrackResponsePtrOutput {
	return o.ApplyT(func(v LiveEventTranscriptionResponse) *LiveEventOutputTranscriptionTrackResponse {
		return v.OutputTranscriptionTrack
	}).(LiveEventOutputTranscriptionTrackResponsePtrOutput)
}

type LiveEventTranscriptionResponseArrayOutput struct{ *pulumi.OutputState }

func (LiveEventTranscriptionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LiveEventTranscriptionResponse)(nil)).Elem()
}

func (o LiveEventTranscriptionResponseArrayOutput) ToLiveEventTranscriptionResponseArrayOutput() LiveEventTranscriptionResponseArrayOutput {
	return o
}

func (o LiveEventTranscriptionResponseArrayOutput) ToLiveEventTranscriptionResponseArrayOutputWithContext(ctx context.Context) LiveEventTranscriptionResponseArrayOutput {
	return o
}

func (o LiveEventTranscriptionResponseArrayOutput) Index(i pulumi.IntInput) LiveEventTranscriptionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LiveEventTranscriptionResponse {
		return vs[0].([]LiveEventTranscriptionResponse)[vs[1].(int)]
	}).(LiveEventTranscriptionResponseOutput)
}

type MediaServiceIdentity struct {
	// The identity type.
	Type string `pulumi:"type"`
}

// MediaServiceIdentityInput is an input type that accepts MediaServiceIdentityArgs and MediaServiceIdentityOutput values.
// You can construct a concrete instance of `MediaServiceIdentityInput` via:
//
//	MediaServiceIdentityArgs{...}
type MediaServiceIdentityInput interface {
	pulumi.Input

	ToMediaServiceIdentityOutput() MediaServiceIdentityOutput
	ToMediaServiceIdentityOutputWithContext(context.Context) MediaServiceIdentityOutput
}

type MediaServiceIdentityArgs struct {
	// The identity type.
	Type pulumi.StringInput `pulumi:"type"`
}

func (MediaServiceIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaServiceIdentity)(nil)).Elem()
}

func (i MediaServiceIdentityArgs) ToMediaServiceIdentityOutput() MediaServiceIdentityOutput {
	return i.ToMediaServiceIdentityOutputWithContext(context.Background())
}

func (i MediaServiceIdentityArgs) ToMediaServiceIdentityOutputWithContext(ctx context.Context) MediaServiceIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaServiceIdentityOutput)
}

func (i MediaServiceIdentityArgs) ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput {
	return i.ToMediaServiceIdentityPtrOutputWithContext(context.Background())
}

func (i MediaServiceIdentityArgs) ToMediaServiceIdentityPtrOutputWithContext(ctx context.Context) MediaServiceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaServiceIdentityOutput).ToMediaServiceIdentityPtrOutputWithContext(ctx)
}

// MediaServiceIdentityPtrInput is an input type that accepts MediaServiceIdentityArgs, MediaServiceIdentityPtr and MediaServiceIdentityPtrOutput values.
// You can construct a concrete instance of `MediaServiceIdentityPtrInput` via:
//
//	        MediaServiceIdentityArgs{...}
//
//	or:
//
//	        nil
type MediaServiceIdentityPtrInput interface {
	pulumi.Input

	ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput
	ToMediaServiceIdentityPtrOutputWithContext(context.Context) MediaServiceIdentityPtrOutput
}

type mediaServiceIdentityPtrType MediaServiceIdentityArgs

func MediaServiceIdentityPtr(v *MediaServiceIdentityArgs) MediaServiceIdentityPtrInput {
	return (*mediaServiceIdentityPtrType)(v)
}

func (*mediaServiceIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaServiceIdentity)(nil)).Elem()
}

func (i *mediaServiceIdentityPtrType) ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput {
	return i.ToMediaServiceIdentityPtrOutputWithContext(context.Background())
}

func (i *mediaServiceIdentityPtrType) ToMediaServiceIdentityPtrOutputWithContext(ctx context.Context) MediaServiceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MediaServiceIdentityPtrOutput)
}

type MediaServiceIdentityOutput struct{ *pulumi.OutputState }

func (MediaServiceIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaServiceIdentity)(nil)).Elem()
}

func (o MediaServiceIdentityOutput) ToMediaServiceIdentityOutput() MediaServiceIdentityOutput {
	return o
}

func (o MediaServiceIdentityOutput) ToMediaServiceIdentityOutputWithContext(ctx context.Context) MediaServiceIdentityOutput {
	return o
}

func (o MediaServiceIdentityOutput) ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput {
	return o.ToMediaServiceIdentityPtrOutputWithContext(context.Background())
}

func (o MediaServiceIdentityOutput) ToMediaServiceIdentityPtrOutputWithContext(ctx context.Context) MediaServiceIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MediaServiceIdentity) *MediaServiceIdentity {
		return &v
	}).(MediaServiceIdentityPtrOutput)
}

// The identity type.
func (o MediaServiceIdentityOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MediaServiceIdentity) string { return v.Type }).(pulumi.StringOutput)
}

type MediaServiceIdentityPtrOutput struct{ *pulumi.OutputState }

func (MediaServiceIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaServiceIdentity)(nil)).Elem()
}

func (o MediaServiceIdentityPtrOutput) ToMediaServiceIdentityPtrOutput() MediaServiceIdentityPtrOutput {
	return o
}

func (o MediaServiceIdentityPtrOutput) ToMediaServiceIdentityPtrOutputWithContext(ctx context.Context) MediaServiceIdentityPtrOutput {
	return o
}

func (o MediaServiceIdentityPtrOutput) Elem() MediaServiceIdentityOutput {
	return o.ApplyT(func(v *MediaServiceIdentity) MediaServiceIdentity {
		if v != nil {
			return *v
		}
		var ret MediaServiceIdentity
		return ret
	}).(MediaServiceIdentityOutput)
}

// The identity type.
func (o MediaServiceIdentityPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaServiceIdentity) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

type MediaServiceIdentityResponse struct {
	// The Principal ID of the identity.
	PrincipalId string `pulumi:"principalId"`
	// The Tenant ID of the identity.
	TenantId string `pulumi:"tenantId"`
	// The identity type.
	Type string `pulumi:"type"`
}

type MediaServiceIdentityResponseOutput struct{ *pulumi.OutputState }

func (MediaServiceIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MediaServiceIdentityResponse)(nil)).Elem()
}

func (o MediaServiceIdentityResponseOutput) ToMediaServiceIdentityResponseOutput() MediaServiceIdentityResponseOutput {
	return o
}

func (o MediaServiceIdentityResponseOutput) ToMediaServiceIdentityResponseOutputWithContext(ctx context.Context) MediaServiceIdentityResponseOutput {
	return o
}

// The Principal ID of the identity.
func (o MediaServiceIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v MediaServiceIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

// The Tenant ID of the identity.
func (o MediaServiceIdentityResponseOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v MediaServiceIdentityResponse) string { return v.TenantId }).(pulumi.StringOutput)
}

// The identity type.
func (o MediaServiceIdentityResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MediaServiceIdentityResponse) string { return v.Type }).(pulumi.StringOutput)
}

type MediaServiceIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (MediaServiceIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MediaServiceIdentityResponse)(nil)).Elem()
}

func (o MediaServiceIdentityResponsePtrOutput) ToMediaServiceIdentityResponsePtrOutput() MediaServiceIdentityResponsePtrOutput {
	return o
}

func (o MediaServiceIdentityResponsePtrOutput) ToMediaServiceIdentityResponsePtrOutputWithContext(ctx context.Context) MediaServiceIdentityResponsePtrOutput {
	return o
}

func (o MediaServiceIdentityResponsePtrOutput) Elem() MediaServiceIdentityResponseOutput {
	return o.ApplyT(func(v *MediaServiceIdentityResponse) MediaServiceIdentityResponse {
		if v != nil {
			return *v
		}
		var ret MediaServiceIdentityResponse
		return ret
	}).(MediaServiceIdentityResponseOutput)
}

// The Principal ID of the identity.
func (o MediaServiceIdentityResponsePtrOutput) PrincipalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PrincipalId
	}).(pulumi.StringPtrOutput)
}

// The Tenant ID of the identity.
func (o MediaServiceIdentityResponsePtrOutput) TenantId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TenantId
	}).(pulumi.StringPtrOutput)
}

// The identity type.
func (o MediaServiceIdentityResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MediaServiceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// Describes the properties for an output ISO MP4 file.
type Mp4Format struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Mp4Format'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFile `pulumi:"outputFiles"`
}

// Describes the properties for an output ISO MP4 file.
type Mp4FormatResponse struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Mp4Format'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFileResponse `pulumi:"outputFiles"`
}

// Describes the properties for producing a collection of GOP aligned multi-bitrate files. The default behavior is to produce one output file for each video layer which is muxed together with all the audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormat struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MultiBitrateFormat'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFile `pulumi:"outputFiles"`
}

// Describes the properties for producing a collection of GOP aligned multi-bitrate files. The default behavior is to produce one output file for each video layer which is muxed together with all the audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormatResponse struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.MultiBitrateFormat'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFileResponse `pulumi:"outputFiles"`
}

// Class for NoEncryption scheme
type NoEncryption struct {
	// Representing supported protocols
	EnabledProtocols *EnabledProtocols `pulumi:"enabledProtocols"`
}

// NoEncryptionInput is an input type that accepts NoEncryptionArgs and NoEncryptionOutput values.
// You can construct a concrete instance of `NoEncryptionInput` via:
//
//	NoEncryptionArgs{...}
type NoEncryptionInput interface {
	pulumi.Input

	ToNoEncryptionOutput() NoEncryptionOutput
	ToNoEncryptionOutputWithContext(context.Context) NoEncryptionOutput
}

// Class for NoEncryption scheme
type NoEncryptionArgs struct {
	// Representing supported protocols
	EnabledProtocols EnabledProtocolsPtrInput `pulumi:"enabledProtocols"`
}

func (NoEncryptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NoEncryption)(nil)).Elem()
}

func (i NoEncryptionArgs) ToNoEncryptionOutput() NoEncryptionOutput {
	return i.ToNoEncryptionOutputWithContext(context.Background())
}

func (i NoEncryptionArgs) ToNoEncryptionOutputWithContext(ctx context.Context) NoEncryptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoEncryptionOutput)
}

func (i NoEncryptionArgs) ToNoEncryptionPtrOutput() NoEncryptionPtrOutput {
	return i.ToNoEncryptionPtrOutputWithContext(context.Background())
}

func (i NoEncryptionArgs) ToNoEncryptionPtrOutputWithContext(ctx context.Context) NoEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoEncryptionOutput).ToNoEncryptionPtrOutputWithContext(ctx)
}

// NoEncryptionPtrInput is an input type that accepts NoEncryptionArgs, NoEncryptionPtr and NoEncryptionPtrOutput values.
// You can construct a concrete instance of `NoEncryptionPtrInput` via:
//
//	        NoEncryptionArgs{...}
//
//	or:
//
//	        nil
type NoEncryptionPtrInput interface {
	pulumi.Input

	ToNoEncryptionPtrOutput() NoEncryptionPtrOutput
	ToNoEncryptionPtrOutputWithContext(context.Context) NoEncryptionPtrOutput
}

type noEncryptionPtrType NoEncryptionArgs

func NoEncryptionPtr(v *NoEncryptionArgs) NoEncryptionPtrInput {
	return (*noEncryptionPtrType)(v)
}

func (*noEncryptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NoEncryption)(nil)).Elem()
}

func (i *noEncryptionPtrType) ToNoEncryptionPtrOutput() NoEncryptionPtrOutput {
	return i.ToNoEncryptionPtrOutputWithContext(context.Background())
}

func (i *noEncryptionPtrType) ToNoEncryptionPtrOutputWithContext(ctx context.Context) NoEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoEncryptionPtrOutput)
}

// Class for NoEncryption scheme
type NoEncryptionOutput struct{ *pulumi.OutputState }

func (NoEncryptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NoEncryption)(nil)).Elem()
}

func (o NoEncryptionOutput) ToNoEncryptionOutput() NoEncryptionOutput {
	return o
}

func (o NoEncryptionOutput) ToNoEncryptionOutputWithContext(ctx context.Context) NoEncryptionOutput {
	return o
}

func (o NoEncryptionOutput) ToNoEncryptionPtrOutput() NoEncryptionPtrOutput {
	return o.ToNoEncryptionPtrOutputWithContext(context.Background())
}

func (o NoEncryptionOutput) ToNoEncryptionPtrOutputWithContext(ctx context.Context) NoEncryptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NoEncryption) *NoEncryption {
		return &v
	}).(NoEncryptionPtrOutput)
}

// Representing supported protocols
func (o NoEncryptionOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v NoEncryption) *EnabledProtocols { return v.EnabledProtocols }).(EnabledProtocolsPtrOutput)
}

type NoEncryptionPtrOutput struct{ *pulumi.OutputState }

func (NoEncryptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NoEncryption)(nil)).Elem()
}

func (o NoEncryptionPtrOutput) ToNoEncryptionPtrOutput() NoEncryptionPtrOutput {
	return o
}

func (o NoEncryptionPtrOutput) ToNoEncryptionPtrOutputWithContext(ctx context.Context) NoEncryptionPtrOutput {
	return o
}

func (o NoEncryptionPtrOutput) Elem() NoEncryptionOutput {
	return o.ApplyT(func(v *NoEncryption) NoEncryption {
		if v != nil {
			return *v
		}
		var ret NoEncryption
		return ret
	}).(NoEncryptionOutput)
}

// Representing supported protocols
func (o NoEncryptionPtrOutput) EnabledProtocols() EnabledProtocolsPtrOutput {
	return o.ApplyT(func(v *NoEncryption) *EnabledProtocols {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsPtrOutput)
}

// Class for NoEncryption scheme
type NoEncryptionResponse struct {
	// Representing supported protocols
	EnabledProtocols *EnabledProtocolsResponse `pulumi:"enabledProtocols"`
}

// Class for NoEncryption scheme
type NoEncryptionResponseOutput struct{ *pulumi.OutputState }

func (NoEncryptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NoEncryptionResponse)(nil)).Elem()
}

func (o NoEncryptionResponseOutput) ToNoEncryptionResponseOutput() NoEncryptionResponseOutput {
	return o
}

func (o NoEncryptionResponseOutput) ToNoEncryptionResponseOutputWithContext(ctx context.Context) NoEncryptionResponseOutput {
	return o
}

// Representing supported protocols
func (o NoEncryptionResponseOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v NoEncryptionResponse) *EnabledProtocolsResponse { return v.EnabledProtocols }).(EnabledProtocolsResponsePtrOutput)
}

type NoEncryptionResponsePtrOutput struct{ *pulumi.OutputState }

func (NoEncryptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NoEncryptionResponse)(nil)).Elem()
}

func (o NoEncryptionResponsePtrOutput) ToNoEncryptionResponsePtrOutput() NoEncryptionResponsePtrOutput {
	return o
}

func (o NoEncryptionResponsePtrOutput) ToNoEncryptionResponsePtrOutputWithContext(ctx context.Context) NoEncryptionResponsePtrOutput {
	return o
}

func (o NoEncryptionResponsePtrOutput) Elem() NoEncryptionResponseOutput {
	return o.ApplyT(func(v *NoEncryptionResponse) NoEncryptionResponse {
		if v != nil {
			return *v
		}
		var ret NoEncryptionResponse
		return ret
	}).(NoEncryptionResponseOutput)
}

// Representing supported protocols
func (o NoEncryptionResponsePtrOutput) EnabledProtocols() EnabledProtocolsResponsePtrOutput {
	return o.ApplyT(func(v *NoEncryptionResponse) *EnabledProtocolsResponse {
		if v == nil {
			return nil
		}
		return v.EnabledProtocols
	}).(EnabledProtocolsResponsePtrOutput)
}

// Represents an output file produced.
type OutputFile struct {
	// The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels v1 and v2, and one audio layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented by v1 and the audio track represented by a1.
	Labels []string `pulumi:"labels"`
}

// Represents an output file produced.
type OutputFileResponse struct {
	// The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels v1 and v2, and one audio layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented by v1 and the audio track represented by a1.
	Labels []string `pulumi:"labels"`
}

// Describes the settings for producing PNG thumbnails.
type PngFormat struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngFormat'.
	OdataType string `pulumi:"odataType"`
}

// Describes the settings for producing PNG thumbnails.
type PngFormatResponse struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngFormat'.
	OdataType string `pulumi:"odataType"`
}

// Describes the properties for producing a series of PNG images from the input video.
type PngImage struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// A collection of output PNG image layers to be produced by the encoder.
	Layers []PngLayer `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngImage'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the properties for producing a series of PNG images from the input video.
type PngImageResponse struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// A collection of output PNG image layers to be produced by the encoder.
	Layers []PngLayerResponse `pulumi:"layers"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngImage'.
	OdataType string `pulumi:"odataType"`
	// The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, PT5M30S to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, 300 to stop at the 300th frame from the frame at start time. If this value is 1, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, 50% to stop at half of stream duration from start time). The default value is 100%, which means to stop at the end of the stream.
	Range *string `pulumi:"range"`
	// The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, PT05S to start at 5 seconds), or a frame count (For example, 10 to start at the 10th frame), or a relative value to stream duration (For example, 10% to start at 10% of stream duration). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for Step and Range. The default value is macro {Best}.
	Start string `pulumi:"start"`
	// The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, PT05S for one image every 5 seconds), or a frame count (For example, 30 for one image every 30 frames), or a relative value to stream duration (For example, 10% for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is 10%, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at 1 if only one thumbnail is needed at start time.
	Step *string `pulumi:"step"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// Describes the settings to produce a PNG image from the input video.
type PngLayer struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngLayer'.
	OdataType string `pulumi:"odataType"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// Describes the settings to produce a PNG image from the input video.
type PngLayerResponse struct {
	// The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `pulumi:"height"`
	// The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.PngLayer'.
	OdataType string `pulumi:"odataType"`
	// The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `pulumi:"width"`
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRange struct {
	// The absolute end time boundary.
	EndTimestamp *float64 `pulumi:"endTimestamp"`
	// The indicator of forcing existing of end time stamp.
	ForceEndTimestamp *bool `pulumi:"forceEndTimestamp"`
	// The relative to end right edge.
	LiveBackoffDuration *float64 `pulumi:"liveBackoffDuration"`
	// The relative to end sliding window.
	PresentationWindowDuration *float64 `pulumi:"presentationWindowDuration"`
	// The absolute start time boundary.
	StartTimestamp *float64 `pulumi:"startTimestamp"`
	// The time scale of time stamps.
	Timescale *float64 `pulumi:"timescale"`
}

// PresentationTimeRangeInput is an input type that accepts PresentationTimeRangeArgs and PresentationTimeRangeOutput values.
// You can construct a concrete instance of `PresentationTimeRangeInput` via:
//
//	PresentationTimeRangeArgs{...}
type PresentationTimeRangeInput interface {
	pulumi.Input

	ToPresentationTimeRangeOutput() PresentationTimeRangeOutput
	ToPresentationTimeRangeOutputWithContext(context.Context) PresentationTimeRangeOutput
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRangeArgs struct {
	// The absolute end time boundary.
	EndTimestamp pulumi.Float64PtrInput `pulumi:"endTimestamp"`
	// The indicator of forcing existing of end time stamp.
	ForceEndTimestamp pulumi.BoolPtrInput `pulumi:"forceEndTimestamp"`
	// The relative to end right edge.
	LiveBackoffDuration pulumi.Float64PtrInput `pulumi:"liveBackoffDuration"`
	// The relative to end sliding window.
	PresentationWindowDuration pulumi.Float64PtrInput `pulumi:"presentationWindowDuration"`
	// The absolute start time boundary.
	StartTimestamp pulumi.Float64PtrInput `pulumi:"startTimestamp"`
	// The time scale of time stamps.
	Timescale pulumi.Float64PtrInput `pulumi:"timescale"`
}

func (PresentationTimeRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PresentationTimeRange)(nil)).Elem()
}

func (i PresentationTimeRangeArgs) ToPresentationTimeRangeOutput() PresentationTimeRangeOutput {
	return i.ToPresentationTimeRangeOutputWithContext(context.Background())
}

func (i PresentationTimeRangeArgs) ToPresentationTimeRangeOutputWithContext(ctx context.Context) PresentationTimeRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PresentationTimeRangeOutput)
}

func (i PresentationTimeRangeArgs) ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput {
	return i.ToPresentationTimeRangePtrOutputWithContext(context.Background())
}

func (i PresentationTimeRangeArgs) ToPresentationTimeRangePtrOutputWithContext(ctx context.Context) PresentationTimeRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PresentationTimeRangeOutput).ToPresentationTimeRangePtrOutputWithContext(ctx)
}

// PresentationTimeRangePtrInput is an input type that accepts PresentationTimeRangeArgs, PresentationTimeRangePtr and PresentationTimeRangePtrOutput values.
// You can construct a concrete instance of `PresentationTimeRangePtrInput` via:
//
//	        PresentationTimeRangeArgs{...}
//
//	or:
//
//	        nil
type PresentationTimeRangePtrInput interface {
	pulumi.Input

	ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput
	ToPresentationTimeRangePtrOutputWithContext(context.Context) PresentationTimeRangePtrOutput
}

type presentationTimeRangePtrType PresentationTimeRangeArgs

func PresentationTimeRangePtr(v *PresentationTimeRangeArgs) PresentationTimeRangePtrInput {
	return (*presentationTimeRangePtrType)(v)
}

func (*presentationTimeRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PresentationTimeRange)(nil)).Elem()
}

func (i *presentationTimeRangePtrType) ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput {
	return i.ToPresentationTimeRangePtrOutputWithContext(context.Background())
}

func (i *presentationTimeRangePtrType) ToPresentationTimeRangePtrOutputWithContext(ctx context.Context) PresentationTimeRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PresentationTimeRangePtrOutput)
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRangeOutput struct{ *pulumi.OutputState }

func (PresentationTimeRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PresentationTimeRange)(nil)).Elem()
}

func (o PresentationTimeRangeOutput) ToPresentationTimeRangeOutput() PresentationTimeRangeOutput {
	return o
}

func (o PresentationTimeRangeOutput) ToPresentationTimeRangeOutputWithContext(ctx context.Context) PresentationTimeRangeOutput {
	return o
}

func (o PresentationTimeRangeOutput) ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput {
	return o.ToPresentationTimeRangePtrOutputWithContext(context.Background())
}

func (o PresentationTimeRangeOutput) ToPresentationTimeRangePtrOutputWithContext(ctx context.Context) PresentationTimeRangePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PresentationTimeRange) *PresentationTimeRange {
		return &v
	}).(PresentationTimeRangePtrOutput)
}

// The absolute end time boundary.
func (o PresentationTimeRangeOutput) EndTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.EndTimestamp }).(pulumi.Float64PtrOutput)
}

// The indicator of forcing existing of end time stamp.
func (o PresentationTimeRangeOutput) ForceEndTimestamp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *bool { return v.ForceEndTimestamp }).(pulumi.BoolPtrOutput)
}

// The relative to end right edge.
func (o PresentationTimeRangeOutput) LiveBackoffDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.LiveBackoffDuration }).(pulumi.Float64PtrOutput)
}

// The relative to end sliding window.
func (o PresentationTimeRangeOutput) PresentationWindowDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.PresentationWindowDuration }).(pulumi.Float64PtrOutput)
}

// The absolute start time boundary.
func (o PresentationTimeRangeOutput) StartTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.StartTimestamp }).(pulumi.Float64PtrOutput)
}

// The time scale of time stamps.
func (o PresentationTimeRangeOutput) Timescale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRange) *float64 { return v.Timescale }).(pulumi.Float64PtrOutput)
}

type PresentationTimeRangePtrOutput struct{ *pulumi.OutputState }

func (PresentationTimeRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PresentationTimeRange)(nil)).Elem()
}

func (o PresentationTimeRangePtrOutput) ToPresentationTimeRangePtrOutput() PresentationTimeRangePtrOutput {
	return o
}

func (o PresentationTimeRangePtrOutput) ToPresentationTimeRangePtrOutputWithContext(ctx context.Context) PresentationTimeRangePtrOutput {
	return o
}

func (o PresentationTimeRangePtrOutput) Elem() PresentationTimeRangeOutput {
	return o.ApplyT(func(v *PresentationTimeRange) PresentationTimeRange {
		if v != nil {
			return *v
		}
		var ret PresentationTimeRange
		return ret
	}).(PresentationTimeRangeOutput)
}

// The absolute end time boundary.
func (o PresentationTimeRangePtrOutput) EndTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.EndTimestamp
	}).(pulumi.Float64PtrOutput)
}

// The indicator of forcing existing of end time stamp.
func (o PresentationTimeRangePtrOutput) ForceEndTimestamp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *bool {
		if v == nil {
			return nil
		}
		return v.ForceEndTimestamp
	}).(pulumi.BoolPtrOutput)
}

// The relative to end right edge.
func (o PresentationTimeRangePtrOutput) LiveBackoffDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.LiveBackoffDuration
	}).(pulumi.Float64PtrOutput)
}

// The relative to end sliding window.
func (o PresentationTimeRangePtrOutput) PresentationWindowDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.PresentationWindowDuration
	}).(pulumi.Float64PtrOutput)
}

// The absolute start time boundary.
func (o PresentationTimeRangePtrOutput) StartTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.StartTimestamp
	}).(pulumi.Float64PtrOutput)
}

// The time scale of time stamps.
func (o PresentationTimeRangePtrOutput) Timescale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRange) *float64 {
		if v == nil {
			return nil
		}
		return v.Timescale
	}).(pulumi.Float64PtrOutput)
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRangeResponse struct {
	// The absolute end time boundary.
	EndTimestamp *float64 `pulumi:"endTimestamp"`
	// The indicator of forcing existing of end time stamp.
	ForceEndTimestamp *bool `pulumi:"forceEndTimestamp"`
	// The relative to end right edge.
	LiveBackoffDuration *float64 `pulumi:"liveBackoffDuration"`
	// The relative to end sliding window.
	PresentationWindowDuration *float64 `pulumi:"presentationWindowDuration"`
	// The absolute start time boundary.
	StartTimestamp *float64 `pulumi:"startTimestamp"`
	// The time scale of time stamps.
	Timescale *float64 `pulumi:"timescale"`
}

// The presentation time range, this is asset related and not recommended for Account Filter.
type PresentationTimeRangeResponseOutput struct{ *pulumi.OutputState }

func (PresentationTimeRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PresentationTimeRangeResponse)(nil)).Elem()
}

func (o PresentationTimeRangeResponseOutput) ToPresentationTimeRangeResponseOutput() PresentationTimeRangeResponseOutput {
	return o
}

func (o PresentationTimeRangeResponseOutput) ToPresentationTimeRangeResponseOutputWithContext(ctx context.Context) PresentationTimeRangeResponseOutput {
	return o
}

// The absolute end time boundary.
func (o PresentationTimeRangeResponseOutput) EndTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.EndTimestamp }).(pulumi.Float64PtrOutput)
}

// The indicator of forcing existing of end time stamp.
func (o PresentationTimeRangeResponseOutput) ForceEndTimestamp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *bool { return v.ForceEndTimestamp }).(pulumi.BoolPtrOutput)
}

// The relative to end right edge.
func (o PresentationTimeRangeResponseOutput) LiveBackoffDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.LiveBackoffDuration }).(pulumi.Float64PtrOutput)
}

// The relative to end sliding window.
func (o PresentationTimeRangeResponseOutput) PresentationWindowDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.PresentationWindowDuration }).(pulumi.Float64PtrOutput)
}

// The absolute start time boundary.
func (o PresentationTimeRangeResponseOutput) StartTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.StartTimestamp }).(pulumi.Float64PtrOutput)
}

// The time scale of time stamps.
func (o PresentationTimeRangeResponseOutput) Timescale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PresentationTimeRangeResponse) *float64 { return v.Timescale }).(pulumi.Float64PtrOutput)
}

type PresentationTimeRangeResponsePtrOutput struct{ *pulumi.OutputState }

func (PresentationTimeRangeResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PresentationTimeRangeResponse)(nil)).Elem()
}

func (o PresentationTimeRangeResponsePtrOutput) ToPresentationTimeRangeResponsePtrOutput() PresentationTimeRangeResponsePtrOutput {
	return o
}

func (o PresentationTimeRangeResponsePtrOutput) ToPresentationTimeRangeResponsePtrOutputWithContext(ctx context.Context) PresentationTimeRangeResponsePtrOutput {
	return o
}

func (o PresentationTimeRangeResponsePtrOutput) Elem() PresentationTimeRangeResponseOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) PresentationTimeRangeResponse {
		if v != nil {
			return *v
		}
		var ret PresentationTimeRangeResponse
		return ret
	}).(PresentationTimeRangeResponseOutput)
}

// The absolute end time boundary.
func (o PresentationTimeRangeResponsePtrOutput) EndTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.EndTimestamp
	}).(pulumi.Float64PtrOutput)
}

// The indicator of forcing existing of end time stamp.
func (o PresentationTimeRangeResponsePtrOutput) ForceEndTimestamp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *bool {
		if v == nil {
			return nil
		}
		return v.ForceEndTimestamp
	}).(pulumi.BoolPtrOutput)
}

// The relative to end right edge.
func (o PresentationTimeRangeResponsePtrOutput) LiveBackoffDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.LiveBackoffDuration
	}).(pulumi.Float64PtrOutput)
}

// The relative to end sliding window.
func (o PresentationTimeRangeResponsePtrOutput) PresentationWindowDuration() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.PresentationWindowDuration
	}).(pulumi.Float64PtrOutput)
}

// The absolute start time boundary.
func (o PresentationTimeRangeResponsePtrOutput) StartTimestamp() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.StartTimestamp
	}).(pulumi.Float64PtrOutput)
}

// The time scale of time stamps.
func (o PresentationTimeRangeResponsePtrOutput) Timescale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PresentationTimeRangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.Timescale
	}).(pulumi.Float64PtrOutput)
}

// The Private Endpoint resource.
type PrivateEndpointResponse struct {
	// The ARM identifier for Private Endpoint
	Id string `pulumi:"id"`
}

// The Private Endpoint resource.
type PrivateEndpointResponseOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointResponse)(nil)).Elem()
}

func (o PrivateEndpointResponseOutput) ToPrivateEndpointResponseOutput() PrivateEndpointResponseOutput {
	return o
}

func (o PrivateEndpointResponseOutput) ToPrivateEndpointResponseOutputWithContext(ctx context.Context) PrivateEndpointResponseOutput {
	return o
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointResponse) string { return v.Id }).(pulumi.StringOutput)
}

type PrivateEndpointResponsePtrOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateEndpointResponse)(nil)).Elem()
}

func (o PrivateEndpointResponsePtrOutput) ToPrivateEndpointResponsePtrOutput() PrivateEndpointResponsePtrOutput {
	return o
}

func (o PrivateEndpointResponsePtrOutput) ToPrivateEndpointResponsePtrOutputWithContext(ctx context.Context) PrivateEndpointResponsePtrOutput {
	return o
}

func (o PrivateEndpointResponsePtrOutput) Elem() PrivateEndpointResponseOutput {
	return o.ApplyT(func(v *PrivateEndpointResponse) PrivateEndpointResponse {
		if v != nil {
			return *v
		}
		var ret PrivateEndpointResponse
		return ret
	}).(PrivateEndpointResponseOutput)
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResponsePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateEndpointResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Id
	}).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description *string `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

// PrivateLinkServiceConnectionStateInput is an input type that accepts PrivateLinkServiceConnectionStateArgs and PrivateLinkServiceConnectionStateOutput values.
// You can construct a concrete instance of `PrivateLinkServiceConnectionStateInput` via:
//
//	PrivateLinkServiceConnectionStateArgs{...}
type PrivateLinkServiceConnectionStateInput interface {
	pulumi.Input

	ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput
	ToPrivateLinkServiceConnectionStateOutputWithContext(context.Context) PrivateLinkServiceConnectionStateOutput
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateArgs struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired pulumi.StringPtrInput `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (PrivateLinkServiceConnectionStateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return i.ToPrivateLinkServiceConnectionStateOutputWithContext(context.Background())
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateLinkServiceConnectionStateOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return o
}

// A message indicating if changes on the service provider require any updates on the consumer.
func (o PrivateLinkServiceConnectionStateOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// The reason for approval/rejection of the connection.
func (o PrivateLinkServiceConnectionStateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o PrivateLinkServiceConnectionStateOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponse struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description *string `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponseOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionStateResponse)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutput() PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

// A message indicating if changes on the service provider require any updates on the consumer.
func (o PrivateLinkServiceConnectionStateResponseOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// The reason for approval/rejection of the connection.
func (o PrivateLinkServiceConnectionStateResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o PrivateLinkServiceConnectionStateResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// Describes the properties of a rectangular window applied to the input media before processing it.
type Rectangle struct {
	// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Height *string `pulumi:"height"`
	// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Left *string `pulumi:"left"`
	// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Top *string `pulumi:"top"`
	// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Width *string `pulumi:"width"`
}

// Describes the properties of a rectangular window applied to the input media before processing it.
type RectangleResponse struct {
	// The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Height *string `pulumi:"height"`
	// The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Left *string `pulumi:"left"`
	// The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Top *string `pulumi:"top"`
	// The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Width *string `pulumi:"width"`
}

// Select audio tracks from the input by specifying an attribute and an attribute filter.
type SelectAudioTrackByAttribute struct {
	// The TrackAttribute to filter the tracks by.
	Attribute string `pulumi:"attribute"`
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter string `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property.
	FilterValue *string `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackByAttribute'.
	OdataType string `pulumi:"odataType"`
}

// Select audio tracks from the input by specifying an attribute and an attribute filter.
type SelectAudioTrackByAttributeResponse struct {
	// The TrackAttribute to filter the tracks by.
	Attribute string `pulumi:"attribute"`
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter string `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property.
	FilterValue *string `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackByAttribute'.
	OdataType string `pulumi:"odataType"`
}

// Select audio tracks from the input by specifying a track identifier.
type SelectAudioTrackById struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackById'.
	OdataType string `pulumi:"odataType"`
	// Track identifier to select
	TrackId float64 `pulumi:"trackId"`
}

// Select audio tracks from the input by specifying a track identifier.
type SelectAudioTrackByIdResponse struct {
	// Optional designation for single channel audio tracks.  Can be used to combine the tracks into stereo or multi-channel audio tracks.
	ChannelMapping *string `pulumi:"channelMapping"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectAudioTrackById'.
	OdataType string `pulumi:"odataType"`
	// Track identifier to select
	TrackId float64 `pulumi:"trackId"`
}

// Select video tracks from the input by specifying an attribute and an attribute filter.
type SelectVideoTrackByAttribute struct {
	// The TrackAttribute to filter the tracks by.
	Attribute string `pulumi:"attribute"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter string `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property. For TrackAttribute.Bitrate, this should be an integer value in bits per second (e.g: '1500000').  The TrackAttribute.Language is not supported for video tracks.
	FilterValue *string `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackByAttribute'.
	OdataType string `pulumi:"odataType"`
}

// Select video tracks from the input by specifying an attribute and an attribute filter.
type SelectVideoTrackByAttributeResponse struct {
	// The TrackAttribute to filter the tracks by.
	Attribute string `pulumi:"attribute"`
	// The type of AttributeFilter to apply to the TrackAttribute in order to select the tracks.
	Filter string `pulumi:"filter"`
	// The value to filter the tracks by.  Only used when AttributeFilter.ValueEquals is specified for the Filter property. For TrackAttribute.Bitrate, this should be an integer value in bits per second (e.g: '1500000').  The TrackAttribute.Language is not supported for video tracks.
	FilterValue *string `pulumi:"filterValue"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackByAttribute'.
	OdataType string `pulumi:"odataType"`
}

// Select video tracks from the input by specifying a track identifier.
type SelectVideoTrackById struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackById'.
	OdataType string `pulumi:"odataType"`
	// Track identifier to select
	TrackId float64 `pulumi:"trackId"`
}

// Select video tracks from the input by specifying a track identifier.
type SelectVideoTrackByIdResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.SelectVideoTrackById'.
	OdataType string `pulumi:"odataType"`
	// Track identifier to select
	TrackId float64 `pulumi:"trackId"`
}

// Describes all the settings to be used when encoding the input video with the Standard Encoder.
type StandardEncoderPreset struct {
	// The list of codecs to be used when encoding the input video.
	Codecs []interface{} `pulumi:"codecs"`
	// One or more filtering operations that are applied to the input media before encoding.
	Filters *Filters `pulumi:"filters"`
	// The list of outputs to be produced by the encoder.
	Formats []interface{} `pulumi:"formats"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.StandardEncoderPreset'.
	OdataType string `pulumi:"odataType"`
}

// Describes all the settings to be used when encoding the input video with the Standard Encoder.
type StandardEncoderPresetResponse struct {
	// The list of codecs to be used when encoding the input video.
	Codecs []interface{} `pulumi:"codecs"`
	// One or more filtering operations that are applied to the input media before encoding.
	Filters *FiltersResponse `pulumi:"filters"`
	// The list of outputs to be produced by the encoder.
	Formats []interface{} `pulumi:"formats"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.StandardEncoderPreset'.
	OdataType string `pulumi:"odataType"`
}

// The storage account details.
type StorageAccount struct {
	// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
	Id *string `pulumi:"id"`
	// The type of the storage account.
	Type string `pulumi:"type"`
}

// StorageAccountInput is an input type that accepts StorageAccountArgs and StorageAccountOutput values.
// You can construct a concrete instance of `StorageAccountInput` via:
//
//	StorageAccountArgs{...}
type StorageAccountInput interface {
	pulumi.Input

	ToStorageAccountOutput() StorageAccountOutput
	ToStorageAccountOutputWithContext(context.Context) StorageAccountOutput
}

// The storage account details.
type StorageAccountArgs struct {
	// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
	Id pulumi.StringPtrInput `pulumi:"id"`
	// The type of the storage account.
	Type pulumi.StringInput `pulumi:"type"`
}

func (StorageAccountArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageAccount)(nil)).Elem()
}

func (i StorageAccountArgs) ToStorageAccountOutput() StorageAccountOutput {
	return i.ToStorageAccountOutputWithContext(context.Background())
}

func (i StorageAccountArgs) ToStorageAccountOutputWithContext(ctx context.Context) StorageAccountOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageAccountOutput)
}

// StorageAccountArrayInput is an input type that accepts StorageAccountArray and StorageAccountArrayOutput values.
// You can construct a concrete instance of `StorageAccountArrayInput` via:
//
//	StorageAccountArray{ StorageAccountArgs{...} }
type StorageAccountArrayInput interface {
	pulumi.Input

	ToStorageAccountArrayOutput() StorageAccountArrayOutput
	ToStorageAccountArrayOutputWithContext(context.Context) StorageAccountArrayOutput
}

type StorageAccountArray []StorageAccountInput

func (StorageAccountArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StorageAccount)(nil)).Elem()
}

func (i StorageAccountArray) ToStorageAccountArrayOutput() StorageAccountArrayOutput {
	return i.ToStorageAccountArrayOutputWithContext(context.Background())
}

func (i StorageAccountArray) ToStorageAccountArrayOutputWithContext(ctx context.Context) StorageAccountArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageAccountArrayOutput)
}

// The storage account details.
type StorageAccountOutput struct{ *pulumi.OutputState }

func (StorageAccountOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageAccount)(nil)).Elem()
}

func (o StorageAccountOutput) ToStorageAccountOutput() StorageAccountOutput {
	return o
}

func (o StorageAccountOutput) ToStorageAccountOutputWithContext(ctx context.Context) StorageAccountOutput {
	return o
}

// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
func (o StorageAccountOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageAccount) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// The type of the storage account.
func (o StorageAccountOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StorageAccount) string { return v.Type }).(pulumi.StringOutput)
}

type StorageAccountArrayOutput struct{ *pulumi.OutputState }

func (StorageAccountArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StorageAccount)(nil)).Elem()
}

func (o StorageAccountArrayOutput) ToStorageAccountArrayOutput() StorageAccountArrayOutput {
	return o
}

func (o StorageAccountArrayOutput) ToStorageAccountArrayOutputWithContext(ctx context.Context) StorageAccountArrayOutput {
	return o
}

func (o StorageAccountArrayOutput) Index(i pulumi.IntInput) StorageAccountOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StorageAccount {
		return vs[0].([]StorageAccount)[vs[1].(int)]
	}).(StorageAccountOutput)
}

// The storage account details.
type StorageAccountResponse struct {
	// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
	Id *string `pulumi:"id"`
	// The type of the storage account.
	Type string `pulumi:"type"`
}

// The storage account details.
type StorageAccountResponseOutput struct{ *pulumi.OutputState }

func (StorageAccountResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageAccountResponse)(nil)).Elem()
}

func (o StorageAccountResponseOutput) ToStorageAccountResponseOutput() StorageAccountResponseOutput {
	return o
}

func (o StorageAccountResponseOutput) ToStorageAccountResponseOutputWithContext(ctx context.Context) StorageAccountResponseOutput {
	return o
}

// The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
func (o StorageAccountResponseOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StorageAccountResponse) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// The type of the storage account.
func (o StorageAccountResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StorageAccountResponse) string { return v.Type }).(pulumi.StringOutput)
}

type StorageAccountResponseArrayOutput struct{ *pulumi.OutputState }

func (StorageAccountResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StorageAccountResponse)(nil)).Elem()
}

func (o StorageAccountResponseArrayOutput) ToStorageAccountResponseArrayOutput() StorageAccountResponseArrayOutput {
	return o
}

func (o StorageAccountResponseArrayOutput) ToStorageAccountResponseArrayOutputWithContext(ctx context.Context) StorageAccountResponseArrayOutput {
	return o
}

func (o StorageAccountResponseArrayOutput) Index(i pulumi.IntInput) StorageAccountResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StorageAccountResponse {
		return vs[0].([]StorageAccountResponse)[vs[1].(int)]
	}).(StorageAccountResponseOutput)
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControl struct {
	// The access control of Akamai
	Akamai *AkamaiAccessControl `pulumi:"akamai"`
	// The IP access control of the streaming endpoint.
	Ip *IPAccessControl `pulumi:"ip"`
}

// StreamingEndpointAccessControlInput is an input type that accepts StreamingEndpointAccessControlArgs and StreamingEndpointAccessControlOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlInput` via:
//
//	StreamingEndpointAccessControlArgs{...}
type StreamingEndpointAccessControlInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlOutput() StreamingEndpointAccessControlOutput
	ToStreamingEndpointAccessControlOutputWithContext(context.Context) StreamingEndpointAccessControlOutput
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControlArgs struct {
	// The access control of Akamai
	Akamai AkamaiAccessControlPtrInput `pulumi:"akamai"`
	// The IP access control of the streaming endpoint.
	Ip IPAccessControlPtrInput `pulumi:"ip"`
}

func (StreamingEndpointAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControl)(nil)).Elem()
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlOutput() StreamingEndpointAccessControlOutput {
	return i.ToStreamingEndpointAccessControlOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlOutputWithContext(ctx context.Context) StreamingEndpointAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlOutput)
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return i.ToStreamingEndpointAccessControlPtrOutputWithContext(context.Background())
}

func (i StreamingEndpointAccessControlArgs) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlOutput).ToStreamingEndpointAccessControlPtrOutputWithContext(ctx)
}

// StreamingEndpointAccessControlPtrInput is an input type that accepts StreamingEndpointAccessControlArgs, StreamingEndpointAccessControlPtr and StreamingEndpointAccessControlPtrOutput values.
// You can construct a concrete instance of `StreamingEndpointAccessControlPtrInput` via:
//
//	        StreamingEndpointAccessControlArgs{...}
//
//	or:
//
//	        nil
type StreamingEndpointAccessControlPtrInput interface {
	pulumi.Input

	ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput
	ToStreamingEndpointAccessControlPtrOutputWithContext(context.Context) StreamingEndpointAccessControlPtrOutput
}

type streamingEndpointAccessControlPtrType StreamingEndpointAccessControlArgs

func StreamingEndpointAccessControlPtr(v *StreamingEndpointAccessControlArgs) StreamingEndpointAccessControlPtrInput {
	return (*streamingEndpointAccessControlPtrType)(v)
}

func (*streamingEndpointAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointAccessControl)(nil)).Elem()
}

func (i *streamingEndpointAccessControlPtrType) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return i.ToStreamingEndpointAccessControlPtrOutputWithContext(context.Background())
}

func (i *streamingEndpointAccessControlPtrType) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingEndpointAccessControlPtrOutput)
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControlOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControl)(nil)).Elem()
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlOutput() StreamingEndpointAccessControlOutput {
	return o
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlOutputWithContext(ctx context.Context) StreamingEndpointAccessControlOutput {
	return o
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return o.ToStreamingEndpointAccessControlPtrOutputWithContext(context.Background())
}

func (o StreamingEndpointAccessControlOutput) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingEndpointAccessControl) *StreamingEndpointAccessControl {
		return &v
	}).(StreamingEndpointAccessControlPtrOutput)
}

// The access control of Akamai
func (o StreamingEndpointAccessControlOutput) Akamai() AkamaiAccessControlPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControl) *AkamaiAccessControl { return v.Akamai }).(AkamaiAccessControlPtrOutput)
}

// The IP access control of the streaming endpoint.
func (o StreamingEndpointAccessControlOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControl) *IPAccessControl { return v.Ip }).(IPAccessControlPtrOutput)
}

type StreamingEndpointAccessControlPtrOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointAccessControl)(nil)).Elem()
}

func (o StreamingEndpointAccessControlPtrOutput) ToStreamingEndpointAccessControlPtrOutput() StreamingEndpointAccessControlPtrOutput {
	return o
}

func (o StreamingEndpointAccessControlPtrOutput) ToStreamingEndpointAccessControlPtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlPtrOutput {
	return o
}

func (o StreamingEndpointAccessControlPtrOutput) Elem() StreamingEndpointAccessControlOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControl) StreamingEndpointAccessControl {
		if v != nil {
			return *v
		}
		var ret StreamingEndpointAccessControl
		return ret
	}).(StreamingEndpointAccessControlOutput)
}

// The access control of Akamai
func (o StreamingEndpointAccessControlPtrOutput) Akamai() AkamaiAccessControlPtrOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControl) *AkamaiAccessControl {
		if v == nil {
			return nil
		}
		return v.Akamai
	}).(AkamaiAccessControlPtrOutput)
}

// The IP access control of the streaming endpoint.
func (o StreamingEndpointAccessControlPtrOutput) Ip() IPAccessControlPtrOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControl) *IPAccessControl {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlPtrOutput)
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControlResponse struct {
	// The access control of Akamai
	Akamai *AkamaiAccessControlResponse `pulumi:"akamai"`
	// The IP access control of the streaming endpoint.
	Ip *IPAccessControlResponse `pulumi:"ip"`
}

// Streaming endpoint access control definition.
type StreamingEndpointAccessControlResponseOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingEndpointAccessControlResponse)(nil)).Elem()
}

func (o StreamingEndpointAccessControlResponseOutput) ToStreamingEndpointAccessControlResponseOutput() StreamingEndpointAccessControlResponseOutput {
	return o
}

func (o StreamingEndpointAccessControlResponseOutput) ToStreamingEndpointAccessControlResponseOutputWithContext(ctx context.Context) StreamingEndpointAccessControlResponseOutput {
	return o
}

// The access control of Akamai
func (o StreamingEndpointAccessControlResponseOutput) Akamai() AkamaiAccessControlResponsePtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlResponse) *AkamaiAccessControlResponse { return v.Akamai }).(AkamaiAccessControlResponsePtrOutput)
}

// The IP access control of the streaming endpoint.
func (o StreamingEndpointAccessControlResponseOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v StreamingEndpointAccessControlResponse) *IPAccessControlResponse { return v.Ip }).(IPAccessControlResponsePtrOutput)
}

type StreamingEndpointAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingEndpointAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingEndpointAccessControlResponse)(nil)).Elem()
}

func (o StreamingEndpointAccessControlResponsePtrOutput) ToStreamingEndpointAccessControlResponsePtrOutput() StreamingEndpointAccessControlResponsePtrOutput {
	return o
}

func (o StreamingEndpointAccessControlResponsePtrOutput) ToStreamingEndpointAccessControlResponsePtrOutputWithContext(ctx context.Context) StreamingEndpointAccessControlResponsePtrOutput {
	return o
}

func (o StreamingEndpointAccessControlResponsePtrOutput) Elem() StreamingEndpointAccessControlResponseOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControlResponse) StreamingEndpointAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret StreamingEndpointAccessControlResponse
		return ret
	}).(StreamingEndpointAccessControlResponseOutput)
}

// The access control of Akamai
func (o StreamingEndpointAccessControlResponsePtrOutput) Akamai() AkamaiAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControlResponse) *AkamaiAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Akamai
	}).(AkamaiAccessControlResponsePtrOutput)
}

// The IP access control of the streaming endpoint.
func (o StreamingEndpointAccessControlResponsePtrOutput) Ip() IPAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *StreamingEndpointAccessControlResponse) *IPAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Ip
	}).(IPAccessControlResponsePtrOutput)
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKey struct {
	// ID of Content Key
	Id string `pulumi:"id"`
	// Label of Content Key as specified in the Streaming Policy
	LabelReferenceInStreamingPolicy *string `pulumi:"labelReferenceInStreamingPolicy"`
	// Value of Content Key
	Value *string `pulumi:"value"`
}

// StreamingLocatorContentKeyInput is an input type that accepts StreamingLocatorContentKeyArgs and StreamingLocatorContentKeyOutput values.
// You can construct a concrete instance of `StreamingLocatorContentKeyInput` via:
//
//	StreamingLocatorContentKeyArgs{...}
type StreamingLocatorContentKeyInput interface {
	pulumi.Input

	ToStreamingLocatorContentKeyOutput() StreamingLocatorContentKeyOutput
	ToStreamingLocatorContentKeyOutputWithContext(context.Context) StreamingLocatorContentKeyOutput
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKeyArgs struct {
	// ID of Content Key
	Id pulumi.StringInput `pulumi:"id"`
	// Label of Content Key as specified in the Streaming Policy
	LabelReferenceInStreamingPolicy pulumi.StringPtrInput `pulumi:"labelReferenceInStreamingPolicy"`
	// Value of Content Key
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (StreamingLocatorContentKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingLocatorContentKey)(nil)).Elem()
}

func (i StreamingLocatorContentKeyArgs) ToStreamingLocatorContentKeyOutput() StreamingLocatorContentKeyOutput {
	return i.ToStreamingLocatorContentKeyOutputWithContext(context.Background())
}

func (i StreamingLocatorContentKeyArgs) ToStreamingLocatorContentKeyOutputWithContext(ctx context.Context) StreamingLocatorContentKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingLocatorContentKeyOutput)
}

// StreamingLocatorContentKeyArrayInput is an input type that accepts StreamingLocatorContentKeyArray and StreamingLocatorContentKeyArrayOutput values.
// You can construct a concrete instance of `StreamingLocatorContentKeyArrayInput` via:
//
//	StreamingLocatorContentKeyArray{ StreamingLocatorContentKeyArgs{...} }
type StreamingLocatorContentKeyArrayInput interface {
	pulumi.Input

	ToStreamingLocatorContentKeyArrayOutput() StreamingLocatorContentKeyArrayOutput
	ToStreamingLocatorContentKeyArrayOutputWithContext(context.Context) StreamingLocatorContentKeyArrayOutput
}

type StreamingLocatorContentKeyArray []StreamingLocatorContentKeyInput

func (StreamingLocatorContentKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingLocatorContentKey)(nil)).Elem()
}

func (i StreamingLocatorContentKeyArray) ToStreamingLocatorContentKeyArrayOutput() StreamingLocatorContentKeyArrayOutput {
	return i.ToStreamingLocatorContentKeyArrayOutputWithContext(context.Background())
}

func (i StreamingLocatorContentKeyArray) ToStreamingLocatorContentKeyArrayOutputWithContext(ctx context.Context) StreamingLocatorContentKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingLocatorContentKeyArrayOutput)
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKeyOutput struct{ *pulumi.OutputState }

func (StreamingLocatorContentKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingLocatorContentKey)(nil)).Elem()
}

func (o StreamingLocatorContentKeyOutput) ToStreamingLocatorContentKeyOutput() StreamingLocatorContentKeyOutput {
	return o
}

func (o StreamingLocatorContentKeyOutput) ToStreamingLocatorContentKeyOutputWithContext(ctx context.Context) StreamingLocatorContentKeyOutput {
	return o
}

// ID of Content Key
func (o StreamingLocatorContentKeyOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingLocatorContentKey) string { return v.Id }).(pulumi.StringOutput)
}

// Label of Content Key as specified in the Streaming Policy
func (o StreamingLocatorContentKeyOutput) LabelReferenceInStreamingPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingLocatorContentKey) *string { return v.LabelReferenceInStreamingPolicy }).(pulumi.StringPtrOutput)
}

// Value of Content Key
func (o StreamingLocatorContentKeyOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingLocatorContentKey) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type StreamingLocatorContentKeyArrayOutput struct{ *pulumi.OutputState }

func (StreamingLocatorContentKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingLocatorContentKey)(nil)).Elem()
}

func (o StreamingLocatorContentKeyArrayOutput) ToStreamingLocatorContentKeyArrayOutput() StreamingLocatorContentKeyArrayOutput {
	return o
}

func (o StreamingLocatorContentKeyArrayOutput) ToStreamingLocatorContentKeyArrayOutputWithContext(ctx context.Context) StreamingLocatorContentKeyArrayOutput {
	return o
}

func (o StreamingLocatorContentKeyArrayOutput) Index(i pulumi.IntInput) StreamingLocatorContentKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingLocatorContentKey {
		return vs[0].([]StreamingLocatorContentKey)[vs[1].(int)]
	}).(StreamingLocatorContentKeyOutput)
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKeyResponse struct {
	// ID of Content Key
	Id string `pulumi:"id"`
	// Label of Content Key as specified in the Streaming Policy
	LabelReferenceInStreamingPolicy *string `pulumi:"labelReferenceInStreamingPolicy"`
	// ContentKeyPolicy used by Content Key
	PolicyName string `pulumi:"policyName"`
	// Tracks which use this Content Key
	Tracks []TrackSelectionResponse `pulumi:"tracks"`
	// Encryption type of Content Key
	Type string `pulumi:"type"`
	// Value of Content Key
	Value *string `pulumi:"value"`
}

// Class for content key in Streaming Locator
type StreamingLocatorContentKeyResponseOutput struct{ *pulumi.OutputState }

func (StreamingLocatorContentKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingLocatorContentKeyResponse)(nil)).Elem()
}

func (o StreamingLocatorContentKeyResponseOutput) ToStreamingLocatorContentKeyResponseOutput() StreamingLocatorContentKeyResponseOutput {
	return o
}

func (o StreamingLocatorContentKeyResponseOutput) ToStreamingLocatorContentKeyResponseOutputWithContext(ctx context.Context) StreamingLocatorContentKeyResponseOutput {
	return o
}

// ID of Content Key
func (o StreamingLocatorContentKeyResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) string { return v.Id }).(pulumi.StringOutput)
}

// Label of Content Key as specified in the Streaming Policy
func (o StreamingLocatorContentKeyResponseOutput) LabelReferenceInStreamingPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) *string { return v.LabelReferenceInStreamingPolicy }).(pulumi.StringPtrOutput)
}

// ContentKeyPolicy used by Content Key
func (o StreamingLocatorContentKeyResponseOutput) PolicyName() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) string { return v.PolicyName }).(pulumi.StringOutput)
}

// Tracks which use this Content Key
func (o StreamingLocatorContentKeyResponseOutput) Tracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) []TrackSelectionResponse { return v.Tracks }).(TrackSelectionResponseArrayOutput)
}

// Encryption type of Content Key
func (o StreamingLocatorContentKeyResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Value of Content Key
func (o StreamingLocatorContentKeyResponseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingLocatorContentKeyResponse) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type StreamingLocatorContentKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (StreamingLocatorContentKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingLocatorContentKeyResponse)(nil)).Elem()
}

func (o StreamingLocatorContentKeyResponseArrayOutput) ToStreamingLocatorContentKeyResponseArrayOutput() StreamingLocatorContentKeyResponseArrayOutput {
	return o
}

func (o StreamingLocatorContentKeyResponseArrayOutput) ToStreamingLocatorContentKeyResponseArrayOutputWithContext(ctx context.Context) StreamingLocatorContentKeyResponseArrayOutput {
	return o
}

func (o StreamingLocatorContentKeyResponseArrayOutput) Index(i pulumi.IntInput) StreamingLocatorContentKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingLocatorContentKeyResponse {
		return vs[0].([]StreamingLocatorContentKeyResponse)[vs[1].(int)]
	}).(StreamingLocatorContentKeyResponseOutput)
}

// Class of paths for streaming
type StreamingPathResponse struct {
	// Encryption scheme
	EncryptionScheme string `pulumi:"encryptionScheme"`
	// Streaming paths for each protocol and encryptionScheme pair
	Paths []string `pulumi:"paths"`
	// Streaming protocol
	StreamingProtocol string `pulumi:"streamingProtocol"`
}

// Class of paths for streaming
type StreamingPathResponseOutput struct{ *pulumi.OutputState }

func (StreamingPathResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPathResponse)(nil)).Elem()
}

func (o StreamingPathResponseOutput) ToStreamingPathResponseOutput() StreamingPathResponseOutput {
	return o
}

func (o StreamingPathResponseOutput) ToStreamingPathResponseOutputWithContext(ctx context.Context) StreamingPathResponseOutput {
	return o
}

// Encryption scheme
func (o StreamingPathResponseOutput) EncryptionScheme() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingPathResponse) string { return v.EncryptionScheme }).(pulumi.StringOutput)
}

// Streaming paths for each protocol and encryptionScheme pair
func (o StreamingPathResponseOutput) Paths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StreamingPathResponse) []string { return v.Paths }).(pulumi.StringArrayOutput)
}

// Streaming protocol
func (o StreamingPathResponseOutput) StreamingProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v StreamingPathResponse) string { return v.StreamingProtocol }).(pulumi.StringOutput)
}

type StreamingPathResponseArrayOutput struct{ *pulumi.OutputState }

func (StreamingPathResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingPathResponse)(nil)).Elem()
}

func (o StreamingPathResponseArrayOutput) ToStreamingPathResponseArrayOutput() StreamingPathResponseArrayOutput {
	return o
}

func (o StreamingPathResponseArrayOutput) ToStreamingPathResponseArrayOutputWithContext(ctx context.Context) StreamingPathResponseArrayOutput {
	return o
}

func (o StreamingPathResponseArrayOutput) Index(i pulumi.IntInput) StreamingPathResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingPathResponse {
		return vs[0].([]StreamingPathResponse)[vs[1].(int)]
	}).(StreamingPathResponseOutput)
}

// Class to specify properties of content key
type StreamingPolicyContentKey struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `pulumi:"label"`
	// Policy used by Content Key
	PolicyName *string `pulumi:"policyName"`
	// Tracks which use this content key
	Tracks []TrackSelection `pulumi:"tracks"`
}

// StreamingPolicyContentKeyInput is an input type that accepts StreamingPolicyContentKeyArgs and StreamingPolicyContentKeyOutput values.
// You can construct a concrete instance of `StreamingPolicyContentKeyInput` via:
//
//	StreamingPolicyContentKeyArgs{...}
type StreamingPolicyContentKeyInput interface {
	pulumi.Input

	ToStreamingPolicyContentKeyOutput() StreamingPolicyContentKeyOutput
	ToStreamingPolicyContentKeyOutputWithContext(context.Context) StreamingPolicyContentKeyOutput
}

// Class to specify properties of content key
type StreamingPolicyContentKeyArgs struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label pulumi.StringPtrInput `pulumi:"label"`
	// Policy used by Content Key
	PolicyName pulumi.StringPtrInput `pulumi:"policyName"`
	// Tracks which use this content key
	Tracks TrackSelectionArrayInput `pulumi:"tracks"`
}

func (StreamingPolicyContentKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKey)(nil)).Elem()
}

func (i StreamingPolicyContentKeyArgs) ToStreamingPolicyContentKeyOutput() StreamingPolicyContentKeyOutput {
	return i.ToStreamingPolicyContentKeyOutputWithContext(context.Background())
}

func (i StreamingPolicyContentKeyArgs) ToStreamingPolicyContentKeyOutputWithContext(ctx context.Context) StreamingPolicyContentKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeyOutput)
}

// StreamingPolicyContentKeyArrayInput is an input type that accepts StreamingPolicyContentKeyArray and StreamingPolicyContentKeyArrayOutput values.
// You can construct a concrete instance of `StreamingPolicyContentKeyArrayInput` via:
//
//	StreamingPolicyContentKeyArray{ StreamingPolicyContentKeyArgs{...} }
type StreamingPolicyContentKeyArrayInput interface {
	pulumi.Input

	ToStreamingPolicyContentKeyArrayOutput() StreamingPolicyContentKeyArrayOutput
	ToStreamingPolicyContentKeyArrayOutputWithContext(context.Context) StreamingPolicyContentKeyArrayOutput
}

type StreamingPolicyContentKeyArray []StreamingPolicyContentKeyInput

func (StreamingPolicyContentKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingPolicyContentKey)(nil)).Elem()
}

func (i StreamingPolicyContentKeyArray) ToStreamingPolicyContentKeyArrayOutput() StreamingPolicyContentKeyArrayOutput {
	return i.ToStreamingPolicyContentKeyArrayOutputWithContext(context.Background())
}

func (i StreamingPolicyContentKeyArray) ToStreamingPolicyContentKeyArrayOutputWithContext(ctx context.Context) StreamingPolicyContentKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeyArrayOutput)
}

// Class to specify properties of content key
type StreamingPolicyContentKeyOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKey)(nil)).Elem()
}

func (o StreamingPolicyContentKeyOutput) ToStreamingPolicyContentKeyOutput() StreamingPolicyContentKeyOutput {
	return o
}

func (o StreamingPolicyContentKeyOutput) ToStreamingPolicyContentKeyOutputWithContext(ctx context.Context) StreamingPolicyContentKeyOutput {
	return o
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o StreamingPolicyContentKeyOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKey) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Policy used by Content Key
func (o StreamingPolicyContentKeyOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKey) *string { return v.PolicyName }).(pulumi.StringPtrOutput)
}

// Tracks which use this content key
func (o StreamingPolicyContentKeyOutput) Tracks() TrackSelectionArrayOutput {
	return o.ApplyT(func(v StreamingPolicyContentKey) []TrackSelection { return v.Tracks }).(TrackSelectionArrayOutput)
}

type StreamingPolicyContentKeyArrayOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingPolicyContentKey)(nil)).Elem()
}

func (o StreamingPolicyContentKeyArrayOutput) ToStreamingPolicyContentKeyArrayOutput() StreamingPolicyContentKeyArrayOutput {
	return o
}

func (o StreamingPolicyContentKeyArrayOutput) ToStreamingPolicyContentKeyArrayOutputWithContext(ctx context.Context) StreamingPolicyContentKeyArrayOutput {
	return o
}

func (o StreamingPolicyContentKeyArrayOutput) Index(i pulumi.IntInput) StreamingPolicyContentKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingPolicyContentKey {
		return vs[0].([]StreamingPolicyContentKey)[vs[1].(int)]
	}).(StreamingPolicyContentKeyOutput)
}

// Class to specify properties of content key
type StreamingPolicyContentKeyResponse struct {
	// Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `pulumi:"label"`
	// Policy used by Content Key
	PolicyName *string `pulumi:"policyName"`
	// Tracks which use this content key
	Tracks []TrackSelectionResponse `pulumi:"tracks"`
}

// Class to specify properties of content key
type StreamingPolicyContentKeyResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKeyResponse)(nil)).Elem()
}

func (o StreamingPolicyContentKeyResponseOutput) ToStreamingPolicyContentKeyResponseOutput() StreamingPolicyContentKeyResponseOutput {
	return o
}

func (o StreamingPolicyContentKeyResponseOutput) ToStreamingPolicyContentKeyResponseOutputWithContext(ctx context.Context) StreamingPolicyContentKeyResponseOutput {
	return o
}

// Label can be used to specify Content Key when creating a Streaming Locator
func (o StreamingPolicyContentKeyResponseOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeyResponse) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Policy used by Content Key
func (o StreamingPolicyContentKeyResponseOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeyResponse) *string { return v.PolicyName }).(pulumi.StringPtrOutput)
}

// Tracks which use this content key
func (o StreamingPolicyContentKeyResponseOutput) Tracks() TrackSelectionResponseArrayOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeyResponse) []TrackSelectionResponse { return v.Tracks }).(TrackSelectionResponseArrayOutput)
}

type StreamingPolicyContentKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamingPolicyContentKeyResponse)(nil)).Elem()
}

func (o StreamingPolicyContentKeyResponseArrayOutput) ToStreamingPolicyContentKeyResponseArrayOutput() StreamingPolicyContentKeyResponseArrayOutput {
	return o
}

func (o StreamingPolicyContentKeyResponseArrayOutput) ToStreamingPolicyContentKeyResponseArrayOutputWithContext(ctx context.Context) StreamingPolicyContentKeyResponseArrayOutput {
	return o
}

func (o StreamingPolicyContentKeyResponseArrayOutput) Index(i pulumi.IntInput) StreamingPolicyContentKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamingPolicyContentKeyResponse {
		return vs[0].([]StreamingPolicyContentKeyResponse)[vs[1].(int)]
	}).(StreamingPolicyContentKeyResponseOutput)
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeys struct {
	// Default content key for an encryption scheme
	DefaultKey *DefaultKey `pulumi:"defaultKey"`
	// Representing tracks needs separate content key
	KeyToTrackMappings []StreamingPolicyContentKey `pulumi:"keyToTrackMappings"`
}

// StreamingPolicyContentKeysInput is an input type that accepts StreamingPolicyContentKeysArgs and StreamingPolicyContentKeysOutput values.
// You can construct a concrete instance of `StreamingPolicyContentKeysInput` via:
//
//	StreamingPolicyContentKeysArgs{...}
type StreamingPolicyContentKeysInput interface {
	pulumi.Input

	ToStreamingPolicyContentKeysOutput() StreamingPolicyContentKeysOutput
	ToStreamingPolicyContentKeysOutputWithContext(context.Context) StreamingPolicyContentKeysOutput
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeysArgs struct {
	// Default content key for an encryption scheme
	DefaultKey DefaultKeyPtrInput `pulumi:"defaultKey"`
	// Representing tracks needs separate content key
	KeyToTrackMappings StreamingPolicyContentKeyArrayInput `pulumi:"keyToTrackMappings"`
}

func (StreamingPolicyContentKeysArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKeys)(nil)).Elem()
}

func (i StreamingPolicyContentKeysArgs) ToStreamingPolicyContentKeysOutput() StreamingPolicyContentKeysOutput {
	return i.ToStreamingPolicyContentKeysOutputWithContext(context.Background())
}

func (i StreamingPolicyContentKeysArgs) ToStreamingPolicyContentKeysOutputWithContext(ctx context.Context) StreamingPolicyContentKeysOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeysOutput)
}

func (i StreamingPolicyContentKeysArgs) ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput {
	return i.ToStreamingPolicyContentKeysPtrOutputWithContext(context.Background())
}

func (i StreamingPolicyContentKeysArgs) ToStreamingPolicyContentKeysPtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeysOutput).ToStreamingPolicyContentKeysPtrOutputWithContext(ctx)
}

// StreamingPolicyContentKeysPtrInput is an input type that accepts StreamingPolicyContentKeysArgs, StreamingPolicyContentKeysPtr and StreamingPolicyContentKeysPtrOutput values.
// You can construct a concrete instance of `StreamingPolicyContentKeysPtrInput` via:
//
//	        StreamingPolicyContentKeysArgs{...}
//
//	or:
//
//	        nil
type StreamingPolicyContentKeysPtrInput interface {
	pulumi.Input

	ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput
	ToStreamingPolicyContentKeysPtrOutputWithContext(context.Context) StreamingPolicyContentKeysPtrOutput
}

type streamingPolicyContentKeysPtrType StreamingPolicyContentKeysArgs

func StreamingPolicyContentKeysPtr(v *StreamingPolicyContentKeysArgs) StreamingPolicyContentKeysPtrInput {
	return (*streamingPolicyContentKeysPtrType)(v)
}

func (*streamingPolicyContentKeysPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyContentKeys)(nil)).Elem()
}

func (i *streamingPolicyContentKeysPtrType) ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput {
	return i.ToStreamingPolicyContentKeysPtrOutputWithContext(context.Background())
}

func (i *streamingPolicyContentKeysPtrType) ToStreamingPolicyContentKeysPtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyContentKeysPtrOutput)
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeysOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeysOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKeys)(nil)).Elem()
}

func (o StreamingPolicyContentKeysOutput) ToStreamingPolicyContentKeysOutput() StreamingPolicyContentKeysOutput {
	return o
}

func (o StreamingPolicyContentKeysOutput) ToStreamingPolicyContentKeysOutputWithContext(ctx context.Context) StreamingPolicyContentKeysOutput {
	return o
}

func (o StreamingPolicyContentKeysOutput) ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput {
	return o.ToStreamingPolicyContentKeysPtrOutputWithContext(context.Background())
}

func (o StreamingPolicyContentKeysOutput) ToStreamingPolicyContentKeysPtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingPolicyContentKeys) *StreamingPolicyContentKeys {
		return &v
	}).(StreamingPolicyContentKeysPtrOutput)
}

// Default content key for an encryption scheme
func (o StreamingPolicyContentKeysOutput) DefaultKey() DefaultKeyPtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeys) *DefaultKey { return v.DefaultKey }).(DefaultKeyPtrOutput)
}

// Representing tracks needs separate content key
func (o StreamingPolicyContentKeysOutput) KeyToTrackMappings() StreamingPolicyContentKeyArrayOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeys) []StreamingPolicyContentKey { return v.KeyToTrackMappings }).(StreamingPolicyContentKeyArrayOutput)
}

type StreamingPolicyContentKeysPtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeysPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyContentKeys)(nil)).Elem()
}

func (o StreamingPolicyContentKeysPtrOutput) ToStreamingPolicyContentKeysPtrOutput() StreamingPolicyContentKeysPtrOutput {
	return o
}

func (o StreamingPolicyContentKeysPtrOutput) ToStreamingPolicyContentKeysPtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysPtrOutput {
	return o
}

func (o StreamingPolicyContentKeysPtrOutput) Elem() StreamingPolicyContentKeysOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeys) StreamingPolicyContentKeys {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyContentKeys
		return ret
	}).(StreamingPolicyContentKeysOutput)
}

// Default content key for an encryption scheme
func (o StreamingPolicyContentKeysPtrOutput) DefaultKey() DefaultKeyPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeys) *DefaultKey {
		if v == nil {
			return nil
		}
		return v.DefaultKey
	}).(DefaultKeyPtrOutput)
}

// Representing tracks needs separate content key
func (o StreamingPolicyContentKeysPtrOutput) KeyToTrackMappings() StreamingPolicyContentKeyArrayOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeys) []StreamingPolicyContentKey {
		if v == nil {
			return nil
		}
		return v.KeyToTrackMappings
	}).(StreamingPolicyContentKeyArrayOutput)
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeysResponse struct {
	// Default content key for an encryption scheme
	DefaultKey *DefaultKeyResponse `pulumi:"defaultKey"`
	// Representing tracks needs separate content key
	KeyToTrackMappings []StreamingPolicyContentKeyResponse `pulumi:"keyToTrackMappings"`
}

// Class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeysResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeysResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyContentKeysResponse)(nil)).Elem()
}

func (o StreamingPolicyContentKeysResponseOutput) ToStreamingPolicyContentKeysResponseOutput() StreamingPolicyContentKeysResponseOutput {
	return o
}

func (o StreamingPolicyContentKeysResponseOutput) ToStreamingPolicyContentKeysResponseOutputWithContext(ctx context.Context) StreamingPolicyContentKeysResponseOutput {
	return o
}

// Default content key for an encryption scheme
func (o StreamingPolicyContentKeysResponseOutput) DefaultKey() DefaultKeyResponsePtrOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeysResponse) *DefaultKeyResponse { return v.DefaultKey }).(DefaultKeyResponsePtrOutput)
}

// Representing tracks needs separate content key
func (o StreamingPolicyContentKeysResponseOutput) KeyToTrackMappings() StreamingPolicyContentKeyResponseArrayOutput {
	return o.ApplyT(func(v StreamingPolicyContentKeysResponse) []StreamingPolicyContentKeyResponse {
		return v.KeyToTrackMappings
	}).(StreamingPolicyContentKeyResponseArrayOutput)
}

type StreamingPolicyContentKeysResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyContentKeysResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyContentKeysResponse)(nil)).Elem()
}

func (o StreamingPolicyContentKeysResponsePtrOutput) ToStreamingPolicyContentKeysResponsePtrOutput() StreamingPolicyContentKeysResponsePtrOutput {
	return o
}

func (o StreamingPolicyContentKeysResponsePtrOutput) ToStreamingPolicyContentKeysResponsePtrOutputWithContext(ctx context.Context) StreamingPolicyContentKeysResponsePtrOutput {
	return o
}

func (o StreamingPolicyContentKeysResponsePtrOutput) Elem() StreamingPolicyContentKeysResponseOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeysResponse) StreamingPolicyContentKeysResponse {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyContentKeysResponse
		return ret
	}).(StreamingPolicyContentKeysResponseOutput)
}

// Default content key for an encryption scheme
func (o StreamingPolicyContentKeysResponsePtrOutput) DefaultKey() DefaultKeyResponsePtrOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeysResponse) *DefaultKeyResponse {
		if v == nil {
			return nil
		}
		return v.DefaultKey
	}).(DefaultKeyResponsePtrOutput)
}

// Representing tracks needs separate content key
func (o StreamingPolicyContentKeysResponsePtrOutput) KeyToTrackMappings() StreamingPolicyContentKeyResponseArrayOutput {
	return o.ApplyT(func(v *StreamingPolicyContentKeysResponse) []StreamingPolicyContentKeyResponse {
		if v == nil {
			return nil
		}
		return v.KeyToTrackMappings
	}).(StreamingPolicyContentKeyResponseArrayOutput)
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfiguration struct {
	// All license to be persistent or not
	AllowPersistentLicense bool `pulumi:"allowPersistentLicense"`
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

// StreamingPolicyFairPlayConfigurationInput is an input type that accepts StreamingPolicyFairPlayConfigurationArgs and StreamingPolicyFairPlayConfigurationOutput values.
// You can construct a concrete instance of `StreamingPolicyFairPlayConfigurationInput` via:
//
//	StreamingPolicyFairPlayConfigurationArgs{...}
type StreamingPolicyFairPlayConfigurationInput interface {
	pulumi.Input

	ToStreamingPolicyFairPlayConfigurationOutput() StreamingPolicyFairPlayConfigurationOutput
	ToStreamingPolicyFairPlayConfigurationOutputWithContext(context.Context) StreamingPolicyFairPlayConfigurationOutput
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfigurationArgs struct {
	// All license to be persistent or not
	AllowPersistentLicense pulumi.BoolInput `pulumi:"allowPersistentLicense"`
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate pulumi.StringPtrInput `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

func (StreamingPolicyFairPlayConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyFairPlayConfiguration)(nil)).Elem()
}

func (i StreamingPolicyFairPlayConfigurationArgs) ToStreamingPolicyFairPlayConfigurationOutput() StreamingPolicyFairPlayConfigurationOutput {
	return i.ToStreamingPolicyFairPlayConfigurationOutputWithContext(context.Background())
}

func (i StreamingPolicyFairPlayConfigurationArgs) ToStreamingPolicyFairPlayConfigurationOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyFairPlayConfigurationOutput)
}

func (i StreamingPolicyFairPlayConfigurationArgs) ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput {
	return i.ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(context.Background())
}

func (i StreamingPolicyFairPlayConfigurationArgs) ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyFairPlayConfigurationOutput).ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx)
}

// StreamingPolicyFairPlayConfigurationPtrInput is an input type that accepts StreamingPolicyFairPlayConfigurationArgs, StreamingPolicyFairPlayConfigurationPtr and StreamingPolicyFairPlayConfigurationPtrOutput values.
// You can construct a concrete instance of `StreamingPolicyFairPlayConfigurationPtrInput` via:
//
//	        StreamingPolicyFairPlayConfigurationArgs{...}
//
//	or:
//
//	        nil
type StreamingPolicyFairPlayConfigurationPtrInput interface {
	pulumi.Input

	ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput
	ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(context.Context) StreamingPolicyFairPlayConfigurationPtrOutput
}

type streamingPolicyFairPlayConfigurationPtrType StreamingPolicyFairPlayConfigurationArgs

func StreamingPolicyFairPlayConfigurationPtr(v *StreamingPolicyFairPlayConfigurationArgs) StreamingPolicyFairPlayConfigurationPtrInput {
	return (*streamingPolicyFairPlayConfigurationPtrType)(v)
}

func (*streamingPolicyFairPlayConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyFairPlayConfiguration)(nil)).Elem()
}

func (i *streamingPolicyFairPlayConfigurationPtrType) ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput {
	return i.ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(context.Background())
}

func (i *streamingPolicyFairPlayConfigurationPtrType) ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyFairPlayConfigurationPtrOutput)
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfigurationOutput struct{ *pulumi.OutputState }

func (StreamingPolicyFairPlayConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyFairPlayConfiguration)(nil)).Elem()
}

func (o StreamingPolicyFairPlayConfigurationOutput) ToStreamingPolicyFairPlayConfigurationOutput() StreamingPolicyFairPlayConfigurationOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationOutput) ToStreamingPolicyFairPlayConfigurationOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationOutput) ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput {
	return o.ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(context.Background())
}

func (o StreamingPolicyFairPlayConfigurationOutput) ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingPolicyFairPlayConfiguration) *StreamingPolicyFairPlayConfiguration {
		return &v
	}).(StreamingPolicyFairPlayConfigurationPtrOutput)
}

// All license to be persistent or not
func (o StreamingPolicyFairPlayConfigurationOutput) AllowPersistentLicense() pulumi.BoolOutput {
	return o.ApplyT(func(v StreamingPolicyFairPlayConfiguration) bool { return v.AllowPersistentLicense }).(pulumi.BoolOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyFairPlayConfigurationOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyFairPlayConfiguration) *string { return v.CustomLicenseAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

type StreamingPolicyFairPlayConfigurationPtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyFairPlayConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyFairPlayConfiguration)(nil)).Elem()
}

func (o StreamingPolicyFairPlayConfigurationPtrOutput) ToStreamingPolicyFairPlayConfigurationPtrOutput() StreamingPolicyFairPlayConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationPtrOutput) ToStreamingPolicyFairPlayConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationPtrOutput) Elem() StreamingPolicyFairPlayConfigurationOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfiguration) StreamingPolicyFairPlayConfiguration {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyFairPlayConfiguration
		return ret
	}).(StreamingPolicyFairPlayConfigurationOutput)
}

// All license to be persistent or not
func (o StreamingPolicyFairPlayConfigurationPtrOutput) AllowPersistentLicense() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfiguration) *bool {
		if v == nil {
			return nil
		}
		return &v.AllowPersistentLicense
	}).(pulumi.BoolPtrOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyFairPlayConfigurationPtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfigurationResponse struct {
	// All license to be persistent or not
	AllowPersistentLicense bool `pulumi:"allowPersistentLicense"`
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

// Class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfigurationResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyFairPlayConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyFairPlayConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyFairPlayConfigurationResponseOutput) ToStreamingPolicyFairPlayConfigurationResponseOutput() StreamingPolicyFairPlayConfigurationResponseOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationResponseOutput) ToStreamingPolicyFairPlayConfigurationResponseOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationResponseOutput {
	return o
}

// All license to be persistent or not
func (o StreamingPolicyFairPlayConfigurationResponseOutput) AllowPersistentLicense() pulumi.BoolOutput {
	return o.ApplyT(func(v StreamingPolicyFairPlayConfigurationResponse) bool { return v.AllowPersistentLicense }).(pulumi.BoolOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyFairPlayConfigurationResponseOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyFairPlayConfigurationResponse) *string {
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

type StreamingPolicyFairPlayConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyFairPlayConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyFairPlayConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) ToStreamingPolicyFairPlayConfigurationResponsePtrOutput() StreamingPolicyFairPlayConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) ToStreamingPolicyFairPlayConfigurationResponsePtrOutputWithContext(ctx context.Context) StreamingPolicyFairPlayConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) Elem() StreamingPolicyFairPlayConfigurationResponseOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfigurationResponse) StreamingPolicyFairPlayConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyFairPlayConfigurationResponse
		return ret
	}).(StreamingPolicyFairPlayConfigurationResponseOutput)
}

// All license to be persistent or not
func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) AllowPersistentLicense() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfigurationResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.AllowPersistentLicense
	}).(pulumi.BoolPtrOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyFairPlayConfigurationResponsePtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyFairPlayConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfiguration struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
	// Custom attributes for PlayReady
	PlayReadyCustomAttributes *string `pulumi:"playReadyCustomAttributes"`
}

// StreamingPolicyPlayReadyConfigurationInput is an input type that accepts StreamingPolicyPlayReadyConfigurationArgs and StreamingPolicyPlayReadyConfigurationOutput values.
// You can construct a concrete instance of `StreamingPolicyPlayReadyConfigurationInput` via:
//
//	StreamingPolicyPlayReadyConfigurationArgs{...}
type StreamingPolicyPlayReadyConfigurationInput interface {
	pulumi.Input

	ToStreamingPolicyPlayReadyConfigurationOutput() StreamingPolicyPlayReadyConfigurationOutput
	ToStreamingPolicyPlayReadyConfigurationOutputWithContext(context.Context) StreamingPolicyPlayReadyConfigurationOutput
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfigurationArgs struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate pulumi.StringPtrInput `pulumi:"customLicenseAcquisitionUrlTemplate"`
	// Custom attributes for PlayReady
	PlayReadyCustomAttributes pulumi.StringPtrInput `pulumi:"playReadyCustomAttributes"`
}

func (StreamingPolicyPlayReadyConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (i StreamingPolicyPlayReadyConfigurationArgs) ToStreamingPolicyPlayReadyConfigurationOutput() StreamingPolicyPlayReadyConfigurationOutput {
	return i.ToStreamingPolicyPlayReadyConfigurationOutputWithContext(context.Background())
}

func (i StreamingPolicyPlayReadyConfigurationArgs) ToStreamingPolicyPlayReadyConfigurationOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyPlayReadyConfigurationOutput)
}

func (i StreamingPolicyPlayReadyConfigurationArgs) ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return i.ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(context.Background())
}

func (i StreamingPolicyPlayReadyConfigurationArgs) ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyPlayReadyConfigurationOutput).ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx)
}

// StreamingPolicyPlayReadyConfigurationPtrInput is an input type that accepts StreamingPolicyPlayReadyConfigurationArgs, StreamingPolicyPlayReadyConfigurationPtr and StreamingPolicyPlayReadyConfigurationPtrOutput values.
// You can construct a concrete instance of `StreamingPolicyPlayReadyConfigurationPtrInput` via:
//
//	        StreamingPolicyPlayReadyConfigurationArgs{...}
//
//	or:
//
//	        nil
type StreamingPolicyPlayReadyConfigurationPtrInput interface {
	pulumi.Input

	ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput
	ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput
}

type streamingPolicyPlayReadyConfigurationPtrType StreamingPolicyPlayReadyConfigurationArgs

func StreamingPolicyPlayReadyConfigurationPtr(v *StreamingPolicyPlayReadyConfigurationArgs) StreamingPolicyPlayReadyConfigurationPtrInput {
	return (*streamingPolicyPlayReadyConfigurationPtrType)(v)
}

func (*streamingPolicyPlayReadyConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (i *streamingPolicyPlayReadyConfigurationPtrType) ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return i.ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(context.Background())
}

func (i *streamingPolicyPlayReadyConfigurationPtrType) ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfigurationOutput struct{ *pulumi.OutputState }

func (StreamingPolicyPlayReadyConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (o StreamingPolicyPlayReadyConfigurationOutput) ToStreamingPolicyPlayReadyConfigurationOutput() StreamingPolicyPlayReadyConfigurationOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationOutput) ToStreamingPolicyPlayReadyConfigurationOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationOutput) ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(context.Background())
}

func (o StreamingPolicyPlayReadyConfigurationOutput) ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingPolicyPlayReadyConfiguration) *StreamingPolicyPlayReadyConfiguration {
		return &v
	}).(StreamingPolicyPlayReadyConfigurationPtrOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyPlayReadyConfigurationOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyPlayReadyConfiguration) *string { return v.CustomLicenseAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

// Custom attributes for PlayReady
func (o StreamingPolicyPlayReadyConfigurationOutput) PlayReadyCustomAttributes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyPlayReadyConfiguration) *string { return v.PlayReadyCustomAttributes }).(pulumi.StringPtrOutput)
}

type StreamingPolicyPlayReadyConfigurationPtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyPlayReadyConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyPlayReadyConfiguration)(nil)).Elem()
}

func (o StreamingPolicyPlayReadyConfigurationPtrOutput) ToStreamingPolicyPlayReadyConfigurationPtrOutput() StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationPtrOutput) ToStreamingPolicyPlayReadyConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationPtrOutput) Elem() StreamingPolicyPlayReadyConfigurationOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfiguration) StreamingPolicyPlayReadyConfiguration {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyPlayReadyConfiguration
		return ret
	}).(StreamingPolicyPlayReadyConfigurationOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyPlayReadyConfigurationPtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Custom attributes for PlayReady
func (o StreamingPolicyPlayReadyConfigurationPtrOutput) PlayReadyCustomAttributes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.PlayReadyCustomAttributes
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfigurationResponse struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
	// Custom attributes for PlayReady
	PlayReadyCustomAttributes *string `pulumi:"playReadyCustomAttributes"`
}

// Class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfigurationResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyPlayReadyConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyPlayReadyConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyPlayReadyConfigurationResponseOutput) ToStreamingPolicyPlayReadyConfigurationResponseOutput() StreamingPolicyPlayReadyConfigurationResponseOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationResponseOutput) ToStreamingPolicyPlayReadyConfigurationResponseOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationResponseOutput {
	return o
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyPlayReadyConfigurationResponseOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyPlayReadyConfigurationResponse) *string {
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Custom attributes for PlayReady
func (o StreamingPolicyPlayReadyConfigurationResponseOutput) PlayReadyCustomAttributes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyPlayReadyConfigurationResponse) *string { return v.PlayReadyCustomAttributes }).(pulumi.StringPtrOutput)
}

type StreamingPolicyPlayReadyConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyPlayReadyConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyPlayReadyConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) ToStreamingPolicyPlayReadyConfigurationResponsePtrOutput() StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) ToStreamingPolicyPlayReadyConfigurationResponsePtrOutputWithContext(ctx context.Context) StreamingPolicyPlayReadyConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) Elem() StreamingPolicyPlayReadyConfigurationResponseOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfigurationResponse) StreamingPolicyPlayReadyConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyPlayReadyConfigurationResponse
		return ret
	}).(StreamingPolicyPlayReadyConfigurationResponseOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Custom attributes for PlayReady
func (o StreamingPolicyPlayReadyConfigurationResponsePtrOutput) PlayReadyCustomAttributes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyPlayReadyConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.PlayReadyCustomAttributes
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfiguration struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

// StreamingPolicyWidevineConfigurationInput is an input type that accepts StreamingPolicyWidevineConfigurationArgs and StreamingPolicyWidevineConfigurationOutput values.
// You can construct a concrete instance of `StreamingPolicyWidevineConfigurationInput` via:
//
//	StreamingPolicyWidevineConfigurationArgs{...}
type StreamingPolicyWidevineConfigurationInput interface {
	pulumi.Input

	ToStreamingPolicyWidevineConfigurationOutput() StreamingPolicyWidevineConfigurationOutput
	ToStreamingPolicyWidevineConfigurationOutputWithContext(context.Context) StreamingPolicyWidevineConfigurationOutput
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfigurationArgs struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate pulumi.StringPtrInput `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

func (StreamingPolicyWidevineConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyWidevineConfiguration)(nil)).Elem()
}

func (i StreamingPolicyWidevineConfigurationArgs) ToStreamingPolicyWidevineConfigurationOutput() StreamingPolicyWidevineConfigurationOutput {
	return i.ToStreamingPolicyWidevineConfigurationOutputWithContext(context.Background())
}

func (i StreamingPolicyWidevineConfigurationArgs) ToStreamingPolicyWidevineConfigurationOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyWidevineConfigurationOutput)
}

func (i StreamingPolicyWidevineConfigurationArgs) ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput {
	return i.ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(context.Background())
}

func (i StreamingPolicyWidevineConfigurationArgs) ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyWidevineConfigurationOutput).ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx)
}

// StreamingPolicyWidevineConfigurationPtrInput is an input type that accepts StreamingPolicyWidevineConfigurationArgs, StreamingPolicyWidevineConfigurationPtr and StreamingPolicyWidevineConfigurationPtrOutput values.
// You can construct a concrete instance of `StreamingPolicyWidevineConfigurationPtrInput` via:
//
//	        StreamingPolicyWidevineConfigurationArgs{...}
//
//	or:
//
//	        nil
type StreamingPolicyWidevineConfigurationPtrInput interface {
	pulumi.Input

	ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput
	ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(context.Context) StreamingPolicyWidevineConfigurationPtrOutput
}

type streamingPolicyWidevineConfigurationPtrType StreamingPolicyWidevineConfigurationArgs

func StreamingPolicyWidevineConfigurationPtr(v *StreamingPolicyWidevineConfigurationArgs) StreamingPolicyWidevineConfigurationPtrInput {
	return (*streamingPolicyWidevineConfigurationPtrType)(v)
}

func (*streamingPolicyWidevineConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyWidevineConfiguration)(nil)).Elem()
}

func (i *streamingPolicyWidevineConfigurationPtrType) ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput {
	return i.ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(context.Background())
}

func (i *streamingPolicyWidevineConfigurationPtrType) ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamingPolicyWidevineConfigurationPtrOutput)
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfigurationOutput struct{ *pulumi.OutputState }

func (StreamingPolicyWidevineConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyWidevineConfiguration)(nil)).Elem()
}

func (o StreamingPolicyWidevineConfigurationOutput) ToStreamingPolicyWidevineConfigurationOutput() StreamingPolicyWidevineConfigurationOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationOutput) ToStreamingPolicyWidevineConfigurationOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationOutput) ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(context.Background())
}

func (o StreamingPolicyWidevineConfigurationOutput) ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StreamingPolicyWidevineConfiguration) *StreamingPolicyWidevineConfiguration {
		return &v
	}).(StreamingPolicyWidevineConfigurationPtrOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyWidevineConfigurationOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyWidevineConfiguration) *string { return v.CustomLicenseAcquisitionUrlTemplate }).(pulumi.StringPtrOutput)
}

type StreamingPolicyWidevineConfigurationPtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyWidevineConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyWidevineConfiguration)(nil)).Elem()
}

func (o StreamingPolicyWidevineConfigurationPtrOutput) ToStreamingPolicyWidevineConfigurationPtrOutput() StreamingPolicyWidevineConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationPtrOutput) ToStreamingPolicyWidevineConfigurationPtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationPtrOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationPtrOutput) Elem() StreamingPolicyWidevineConfigurationOutput {
	return o.ApplyT(func(v *StreamingPolicyWidevineConfiguration) StreamingPolicyWidevineConfiguration {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyWidevineConfiguration
		return ret
	}).(StreamingPolicyWidevineConfigurationOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyWidevineConfigurationPtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyWidevineConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfigurationResponse struct {
	// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionUrlTemplate *string `pulumi:"customLicenseAcquisitionUrlTemplate"`
}

// Class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfigurationResponseOutput struct{ *pulumi.OutputState }

func (StreamingPolicyWidevineConfigurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamingPolicyWidevineConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyWidevineConfigurationResponseOutput) ToStreamingPolicyWidevineConfigurationResponseOutput() StreamingPolicyWidevineConfigurationResponseOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationResponseOutput) ToStreamingPolicyWidevineConfigurationResponseOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationResponseOutput {
	return o
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyWidevineConfigurationResponseOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StreamingPolicyWidevineConfigurationResponse) *string {
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

type StreamingPolicyWidevineConfigurationResponsePtrOutput struct{ *pulumi.OutputState }

func (StreamingPolicyWidevineConfigurationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StreamingPolicyWidevineConfigurationResponse)(nil)).Elem()
}

func (o StreamingPolicyWidevineConfigurationResponsePtrOutput) ToStreamingPolicyWidevineConfigurationResponsePtrOutput() StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationResponsePtrOutput) ToStreamingPolicyWidevineConfigurationResponsePtrOutputWithContext(ctx context.Context) StreamingPolicyWidevineConfigurationResponsePtrOutput {
	return o
}

func (o StreamingPolicyWidevineConfigurationResponsePtrOutput) Elem() StreamingPolicyWidevineConfigurationResponseOutput {
	return o.ApplyT(func(v *StreamingPolicyWidevineConfigurationResponse) StreamingPolicyWidevineConfigurationResponse {
		if v != nil {
			return *v
		}
		var ret StreamingPolicyWidevineConfigurationResponse
		return ret
	}).(StreamingPolicyWidevineConfigurationResponseOutput)
}

// Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
func (o StreamingPolicyWidevineConfigurationResponsePtrOutput) CustomLicenseAcquisitionUrlTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StreamingPolicyWidevineConfigurationResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomLicenseAcquisitionUrlTemplate
	}).(pulumi.StringPtrOutput)
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponse struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *string `pulumi:"createdAt"`
	// The identity that created the resource.
	CreatedBy *string `pulumi:"createdBy"`
	// The type of identity that created the resource.
	CreatedByType *string `pulumi:"createdByType"`
	// The timestamp of resource last modification (UTC)
	LastModifiedAt *string `pulumi:"lastModifiedAt"`
	// The identity that last modified the resource.
	LastModifiedBy *string `pulumi:"lastModifiedBy"`
	// The type of identity that last modified the resource.
	LastModifiedByType *string `pulumi:"lastModifiedByType"`
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponseOutput struct{ *pulumi.OutputState }

func (SystemDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SystemDataResponse)(nil)).Elem()
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutput() SystemDataResponseOutput {
	return o
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutputWithContext(ctx context.Context) SystemDataResponseOutput {
	return o
}

// The timestamp of resource creation (UTC).
func (o SystemDataResponseOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedAt }).(pulumi.StringPtrOutput)
}

// The identity that created the resource.
func (o SystemDataResponseOutput) CreatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that created the resource.
func (o SystemDataResponseOutput) CreatedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedByType }).(pulumi.StringPtrOutput)
}

// The timestamp of resource last modification (UTC)
func (o SystemDataResponseOutput) LastModifiedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedAt }).(pulumi.StringPtrOutput)
}

// The identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedByType }).(pulumi.StringPtrOutput)
}

// Class to specify one track property condition
type TrackPropertyCondition struct {
	// Track property condition operation
	Operation string `pulumi:"operation"`
	// Track property type
	Property string `pulumi:"property"`
	// Track property value
	Value *string `pulumi:"value"`
}

// TrackPropertyConditionInput is an input type that accepts TrackPropertyConditionArgs and TrackPropertyConditionOutput values.
// You can construct a concrete instance of `TrackPropertyConditionInput` via:
//
//	TrackPropertyConditionArgs{...}
type TrackPropertyConditionInput interface {
	pulumi.Input

	ToTrackPropertyConditionOutput() TrackPropertyConditionOutput
	ToTrackPropertyConditionOutputWithContext(context.Context) TrackPropertyConditionOutput
}

// Class to specify one track property condition
type TrackPropertyConditionArgs struct {
	// Track property condition operation
	Operation pulumi.StringInput `pulumi:"operation"`
	// Track property type
	Property pulumi.StringInput `pulumi:"property"`
	// Track property value
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (TrackPropertyConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackPropertyCondition)(nil)).Elem()
}

func (i TrackPropertyConditionArgs) ToTrackPropertyConditionOutput() TrackPropertyConditionOutput {
	return i.ToTrackPropertyConditionOutputWithContext(context.Background())
}

func (i TrackPropertyConditionArgs) ToTrackPropertyConditionOutputWithContext(ctx context.Context) TrackPropertyConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrackPropertyConditionOutput)
}

// TrackPropertyConditionArrayInput is an input type that accepts TrackPropertyConditionArray and TrackPropertyConditionArrayOutput values.
// You can construct a concrete instance of `TrackPropertyConditionArrayInput` via:
//
//	TrackPropertyConditionArray{ TrackPropertyConditionArgs{...} }
type TrackPropertyConditionArrayInput interface {
	pulumi.Input

	ToTrackPropertyConditionArrayOutput() TrackPropertyConditionArrayOutput
	ToTrackPropertyConditionArrayOutputWithContext(context.Context) TrackPropertyConditionArrayOutput
}

type TrackPropertyConditionArray []TrackPropertyConditionInput

func (TrackPropertyConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackPropertyCondition)(nil)).Elem()
}

func (i TrackPropertyConditionArray) ToTrackPropertyConditionArrayOutput() TrackPropertyConditionArrayOutput {
	return i.ToTrackPropertyConditionArrayOutputWithContext(context.Background())
}

func (i TrackPropertyConditionArray) ToTrackPropertyConditionArrayOutputWithContext(ctx context.Context) TrackPropertyConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrackPropertyConditionArrayOutput)
}

// Class to specify one track property condition
type TrackPropertyConditionOutput struct{ *pulumi.OutputState }

func (TrackPropertyConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackPropertyCondition)(nil)).Elem()
}

func (o TrackPropertyConditionOutput) ToTrackPropertyConditionOutput() TrackPropertyConditionOutput {
	return o
}

func (o TrackPropertyConditionOutput) ToTrackPropertyConditionOutputWithContext(ctx context.Context) TrackPropertyConditionOutput {
	return o
}

// Track property condition operation
func (o TrackPropertyConditionOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v TrackPropertyCondition) string { return v.Operation }).(pulumi.StringOutput)
}

// Track property type
func (o TrackPropertyConditionOutput) Property() pulumi.StringOutput {
	return o.ApplyT(func(v TrackPropertyCondition) string { return v.Property }).(pulumi.StringOutput)
}

// Track property value
func (o TrackPropertyConditionOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TrackPropertyCondition) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type TrackPropertyConditionArrayOutput struct{ *pulumi.OutputState }

func (TrackPropertyConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackPropertyCondition)(nil)).Elem()
}

func (o TrackPropertyConditionArrayOutput) ToTrackPropertyConditionArrayOutput() TrackPropertyConditionArrayOutput {
	return o
}

func (o TrackPropertyConditionArrayOutput) ToTrackPropertyConditionArrayOutputWithContext(ctx context.Context) TrackPropertyConditionArrayOutput {
	return o
}

func (o TrackPropertyConditionArrayOutput) Index(i pulumi.IntInput) TrackPropertyConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TrackPropertyCondition {
		return vs[0].([]TrackPropertyCondition)[vs[1].(int)]
	}).(TrackPropertyConditionOutput)
}

// Class to specify one track property condition
type TrackPropertyConditionResponse struct {
	// Track property condition operation
	Operation string `pulumi:"operation"`
	// Track property type
	Property string `pulumi:"property"`
	// Track property value
	Value *string `pulumi:"value"`
}

// Class to specify one track property condition
type TrackPropertyConditionResponseOutput struct{ *pulumi.OutputState }

func (TrackPropertyConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackPropertyConditionResponse)(nil)).Elem()
}

func (o TrackPropertyConditionResponseOutput) ToTrackPropertyConditionResponseOutput() TrackPropertyConditionResponseOutput {
	return o
}

func (o TrackPropertyConditionResponseOutput) ToTrackPropertyConditionResponseOutputWithContext(ctx context.Context) TrackPropertyConditionResponseOutput {
	return o
}

// Track property condition operation
func (o TrackPropertyConditionResponseOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v TrackPropertyConditionResponse) string { return v.Operation }).(pulumi.StringOutput)
}

// Track property type
func (o TrackPropertyConditionResponseOutput) Property() pulumi.StringOutput {
	return o.ApplyT(func(v TrackPropertyConditionResponse) string { return v.Property }).(pulumi.StringOutput)
}

// Track property value
func (o TrackPropertyConditionResponseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TrackPropertyConditionResponse) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type TrackPropertyConditionResponseArrayOutput struct{ *pulumi.OutputState }

func (TrackPropertyConditionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackPropertyConditionResponse)(nil)).Elem()
}

func (o TrackPropertyConditionResponseArrayOutput) ToTrackPropertyConditionResponseArrayOutput() TrackPropertyConditionResponseArrayOutput {
	return o
}

func (o TrackPropertyConditionResponseArrayOutput) ToTrackPropertyConditionResponseArrayOutputWithContext(ctx context.Context) TrackPropertyConditionResponseArrayOutput {
	return o
}

func (o TrackPropertyConditionResponseArrayOutput) Index(i pulumi.IntInput) TrackPropertyConditionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TrackPropertyConditionResponse {
		return vs[0].([]TrackPropertyConditionResponse)[vs[1].(int)]
	}).(TrackPropertyConditionResponseOutput)
}

// Class to select a track
type TrackSelection struct {
	// TrackSelections is a track property condition list which can specify track(s)
	TrackSelections []TrackPropertyCondition `pulumi:"trackSelections"`
}

// TrackSelectionInput is an input type that accepts TrackSelectionArgs and TrackSelectionOutput values.
// You can construct a concrete instance of `TrackSelectionInput` via:
//
//	TrackSelectionArgs{...}
type TrackSelectionInput interface {
	pulumi.Input

	ToTrackSelectionOutput() TrackSelectionOutput
	ToTrackSelectionOutputWithContext(context.Context) TrackSelectionOutput
}

// Class to select a track
type TrackSelectionArgs struct {
	// TrackSelections is a track property condition list which can specify track(s)
	TrackSelections TrackPropertyConditionArrayInput `pulumi:"trackSelections"`
}

func (TrackSelectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackSelection)(nil)).Elem()
}

func (i TrackSelectionArgs) ToTrackSelectionOutput() TrackSelectionOutput {
	return i.ToTrackSelectionOutputWithContext(context.Background())
}

func (i TrackSelectionArgs) ToTrackSelectionOutputWithContext(ctx context.Context) TrackSelectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrackSelectionOutput)
}

// TrackSelectionArrayInput is an input type that accepts TrackSelectionArray and TrackSelectionArrayOutput values.
// You can construct a concrete instance of `TrackSelectionArrayInput` via:
//
//	TrackSelectionArray{ TrackSelectionArgs{...} }
type TrackSelectionArrayInput interface {
	pulumi.Input

	ToTrackSelectionArrayOutput() TrackSelectionArrayOutput
	ToTrackSelectionArrayOutputWithContext(context.Context) TrackSelectionArrayOutput
}

type TrackSelectionArray []TrackSelectionInput

func (TrackSelectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackSelection)(nil)).Elem()
}

func (i TrackSelectionArray) ToTrackSelectionArrayOutput() TrackSelectionArrayOutput {
	return i.ToTrackSelectionArrayOutputWithContext(context.Background())
}

func (i TrackSelectionArray) ToTrackSelectionArrayOutputWithContext(ctx context.Context) TrackSelectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrackSelectionArrayOutput)
}

// Class to select a track
type TrackSelectionOutput struct{ *pulumi.OutputState }

func (TrackSelectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackSelection)(nil)).Elem()
}

func (o TrackSelectionOutput) ToTrackSelectionOutput() TrackSelectionOutput {
	return o
}

func (o TrackSelectionOutput) ToTrackSelectionOutputWithContext(ctx context.Context) TrackSelectionOutput {
	return o
}

// TrackSelections is a track property condition list which can specify track(s)
func (o TrackSelectionOutput) TrackSelections() TrackPropertyConditionArrayOutput {
	return o.ApplyT(func(v TrackSelection) []TrackPropertyCondition { return v.TrackSelections }).(TrackPropertyConditionArrayOutput)
}

type TrackSelectionArrayOutput struct{ *pulumi.OutputState }

func (TrackSelectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackSelection)(nil)).Elem()
}

func (o TrackSelectionArrayOutput) ToTrackSelectionArrayOutput() TrackSelectionArrayOutput {
	return o
}

func (o TrackSelectionArrayOutput) ToTrackSelectionArrayOutputWithContext(ctx context.Context) TrackSelectionArrayOutput {
	return o
}

func (o TrackSelectionArrayOutput) Index(i pulumi.IntInput) TrackSelectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TrackSelection {
		return vs[0].([]TrackSelection)[vs[1].(int)]
	}).(TrackSelectionOutput)
}

// Class to select a track
type TrackSelectionResponse struct {
	// TrackSelections is a track property condition list which can specify track(s)
	TrackSelections []TrackPropertyConditionResponse `pulumi:"trackSelections"`
}

// Class to select a track
type TrackSelectionResponseOutput struct{ *pulumi.OutputState }

func (TrackSelectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrackSelectionResponse)(nil)).Elem()
}

func (o TrackSelectionResponseOutput) ToTrackSelectionResponseOutput() TrackSelectionResponseOutput {
	return o
}

func (o TrackSelectionResponseOutput) ToTrackSelectionResponseOutputWithContext(ctx context.Context) TrackSelectionResponseOutput {
	return o
}

// TrackSelections is a track property condition list which can specify track(s)
func (o TrackSelectionResponseOutput) TrackSelections() TrackPropertyConditionResponseArrayOutput {
	return o.ApplyT(func(v TrackSelectionResponse) []TrackPropertyConditionResponse { return v.TrackSelections }).(TrackPropertyConditionResponseArrayOutput)
}

type TrackSelectionResponseArrayOutput struct{ *pulumi.OutputState }

func (TrackSelectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrackSelectionResponse)(nil)).Elem()
}

func (o TrackSelectionResponseArrayOutput) ToTrackSelectionResponseArrayOutput() TrackSelectionResponseArrayOutput {
	return o
}

func (o TrackSelectionResponseArrayOutput) ToTrackSelectionResponseArrayOutputWithContext(ctx context.Context) TrackSelectionResponseArrayOutput {
	return o
}

func (o TrackSelectionResponseArrayOutput) Index(i pulumi.IntInput) TrackSelectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TrackSelectionResponse {
		return vs[0].([]TrackSelectionResponse)[vs[1].(int)]
	}).(TrackSelectionResponseOutput)
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputType struct {
	// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
	OnError *string `pulumi:"onError"`
	// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
	Preset interface{} `pulumi:"preset"`
	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
	RelativePriority *string `pulumi:"relativePriority"`
}

// TransformOutputTypeInput is an input type that accepts TransformOutputTypeArgs and TransformOutputTypeOutput values.
// You can construct a concrete instance of `TransformOutputTypeInput` via:
//
//	TransformOutputTypeArgs{...}
type TransformOutputTypeInput interface {
	pulumi.Input

	ToTransformOutputTypeOutput() TransformOutputTypeOutput
	ToTransformOutputTypeOutputWithContext(context.Context) TransformOutputTypeOutput
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputTypeArgs struct {
	// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
	OnError pulumi.StringPtrInput `pulumi:"onError"`
	// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
	Preset pulumi.Input `pulumi:"preset"`
	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
	RelativePriority pulumi.StringPtrInput `pulumi:"relativePriority"`
}

func (TransformOutputTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputType)(nil)).Elem()
}

func (i TransformOutputTypeArgs) ToTransformOutputTypeOutput() TransformOutputTypeOutput {
	return i.ToTransformOutputTypeOutputWithContext(context.Background())
}

func (i TransformOutputTypeArgs) ToTransformOutputTypeOutputWithContext(ctx context.Context) TransformOutputTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputTypeOutput)
}

// TransformOutputTypeArrayInput is an input type that accepts TransformOutputTypeArray and TransformOutputTypeArrayOutput values.
// You can construct a concrete instance of `TransformOutputTypeArrayInput` via:
//
//	TransformOutputTypeArray{ TransformOutputTypeArgs{...} }
type TransformOutputTypeArrayInput interface {
	pulumi.Input

	ToTransformOutputTypeArrayOutput() TransformOutputTypeArrayOutput
	ToTransformOutputTypeArrayOutputWithContext(context.Context) TransformOutputTypeArrayOutput
}

type TransformOutputTypeArray []TransformOutputTypeInput

func (TransformOutputTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TransformOutputType)(nil)).Elem()
}

func (i TransformOutputTypeArray) ToTransformOutputTypeArrayOutput() TransformOutputTypeArrayOutput {
	return i.ToTransformOutputTypeArrayOutputWithContext(context.Background())
}

func (i TransformOutputTypeArray) ToTransformOutputTypeArrayOutputWithContext(ctx context.Context) TransformOutputTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TransformOutputTypeArrayOutput)
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputTypeOutput struct{ *pulumi.OutputState }

func (TransformOutputTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputType)(nil)).Elem()
}

func (o TransformOutputTypeOutput) ToTransformOutputTypeOutput() TransformOutputTypeOutput {
	return o
}

func (o TransformOutputTypeOutput) ToTransformOutputTypeOutputWithContext(ctx context.Context) TransformOutputTypeOutput {
	return o
}

// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
func (o TransformOutputTypeOutput) OnError() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputType) *string { return v.OnError }).(pulumi.StringPtrOutput)
}

// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
func (o TransformOutputTypeOutput) Preset() pulumi.AnyOutput {
	return o.ApplyT(func(v TransformOutputType) interface{} { return v.Preset }).(pulumi.AnyOutput)
}

// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
func (o TransformOutputTypeOutput) RelativePriority() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputType) *string { return v.RelativePriority }).(pulumi.StringPtrOutput)
}

type TransformOutputTypeArrayOutput struct{ *pulumi.OutputState }

func (TransformOutputTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TransformOutputType)(nil)).Elem()
}

func (o TransformOutputTypeArrayOutput) ToTransformOutputTypeArrayOutput() TransformOutputTypeArrayOutput {
	return o
}

func (o TransformOutputTypeArrayOutput) ToTransformOutputTypeArrayOutputWithContext(ctx context.Context) TransformOutputTypeArrayOutput {
	return o
}

func (o TransformOutputTypeArrayOutput) Index(i pulumi.IntInput) TransformOutputTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TransformOutputType {
		return vs[0].([]TransformOutputType)[vs[1].(int)]
	}).(TransformOutputTypeOutput)
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputResponse struct {
	// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
	OnError *string `pulumi:"onError"`
	// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
	Preset interface{} `pulumi:"preset"`
	// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
	RelativePriority *string `pulumi:"relativePriority"`
}

// Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
type TransformOutputResponseOutput struct{ *pulumi.OutputState }

func (TransformOutputResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TransformOutputResponse)(nil)).Elem()
}

func (o TransformOutputResponseOutput) ToTransformOutputResponseOutput() TransformOutputResponseOutput {
	return o
}

func (o TransformOutputResponseOutput) ToTransformOutputResponseOutputWithContext(ctx context.Context) TransformOutputResponseOutput {
	return o
}

// A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
func (o TransformOutputResponseOutput) OnError() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputResponse) *string { return v.OnError }).(pulumi.StringPtrOutput)
}

// Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
func (o TransformOutputResponseOutput) Preset() pulumi.AnyOutput {
	return o.ApplyT(func(v TransformOutputResponse) interface{} { return v.Preset }).(pulumi.AnyOutput)
}

// Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
func (o TransformOutputResponseOutput) RelativePriority() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TransformOutputResponse) *string { return v.RelativePriority }).(pulumi.StringPtrOutput)
}

type TransformOutputResponseArrayOutput struct{ *pulumi.OutputState }

func (TransformOutputResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TransformOutputResponse)(nil)).Elem()
}

func (o TransformOutputResponseArrayOutput) ToTransformOutputResponseArrayOutput() TransformOutputResponseArrayOutput {
	return o
}

func (o TransformOutputResponseArrayOutput) ToTransformOutputResponseArrayOutputWithContext(ctx context.Context) TransformOutputResponseArrayOutput {
	return o
}

func (o TransformOutputResponseArrayOutput) Index(i pulumi.IntInput) TransformOutputResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TransformOutputResponse {
		return vs[0].([]TransformOutputResponse)[vs[1].(int)]
	}).(TransformOutputResponseOutput)
}

// Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC 13818-1) output video file(s).
type TransportStreamFormat struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.TransportStreamFormat'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFile `pulumi:"outputFiles"`
}

// Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC 13818-1) output video file(s).
type TransportStreamFormatResponse struct {
	// The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. {Resolution} - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern string `pulumi:"filenamePattern"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.TransportStreamFormat'.
	OdataType string `pulumi:"odataType"`
	// The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles []OutputFileResponse `pulumi:"outputFiles"`
}

// Specifies the clip time as a Utc time position in the media file.  The Utc time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type UtcClipTime struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.UtcClipTime'.
	OdataType string `pulumi:"odataType"`
	// The time position on the timeline of the input media based on Utc time.
	Time string `pulumi:"time"`
}

// Specifies the clip time as a Utc time position in the media file.  The Utc time can point to a different position depending on whether the media file starts from a timestamp of zero or not.
type UtcClipTimeResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.UtcClipTime'.
	OdataType string `pulumi:"odataType"`
	// The time position on the timeline of the input media based on Utc time.
	Time string `pulumi:"time"`
}

// Describes the basic properties for encoding the input video.
type Video struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Video'.
	OdataType string `pulumi:"odataType"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// A video analyzer preset that extracts insights (rich metadata) from both audio and video, and outputs a JSON format file.
type VideoAnalyzerPreset struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
	InsightsToExtract *string `pulumi:"insightsToExtract"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoAnalyzerPreset'.
	OdataType string `pulumi:"odataType"`
}

// A video analyzer preset that extracts insights (rich metadata) from both audio and video, and outputs a JSON format file.
type VideoAnalyzerPresetResponse struct {
	// The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode::Basic, since automatic language detection is not included in basic mode. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `pulumi:"audioLanguage"`
	// Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]string `pulumi:"experimentalOptions"`
	// Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out.
	InsightsToExtract *string `pulumi:"insightsToExtract"`
	// Determines the set of audio analysis operations to be performed. If unspecified, the Standard AudioAnalysisMode would be chosen.
	Mode *string `pulumi:"mode"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoAnalyzerPreset'.
	OdataType string `pulumi:"odataType"`
}

// Describes the properties of a video overlay.
type VideoOverlay struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `pulumi:"audioGainLevel"`
	// An optional rectangular window used to crop the overlay image or video.
	CropRectangle *Rectangle `pulumi:"cropRectangle"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End *string `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel string `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoOverlay'.
	OdataType string `pulumi:"odataType"`
	// The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
	Opacity *float64 `pulumi:"opacity"`
	// The location in the input video where the overlay is applied.
	Position *Rectangle `pulumi:"position"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `pulumi:"start"`
}

// Describes the properties of a video overlay.
type VideoOverlayResponse struct {
	// The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `pulumi:"audioGainLevel"`
	// An optional rectangular window used to crop the overlay image or video.
	CropRectangle *RectangleResponse `pulumi:"cropRectangle"`
	// The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, PT30S to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
	End *string `pulumi:"end"`
	// The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `pulumi:"fadeInDuration"`
	// The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `pulumi:"fadeOutDuration"`
	// The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel string `pulumi:"inputLabel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoOverlay'.
	OdataType string `pulumi:"odataType"`
	// The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
	Opacity *float64 `pulumi:"opacity"`
	// The location in the input video where the overlay is applied.
	Position *RectangleResponse `pulumi:"position"`
	// The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `pulumi:"start"`
}

// Describes the basic properties for encoding the input video.
type VideoResponse struct {
	// The distance between two key frames. The value should be non-zero in the range [0.5, 20] seconds, specified in ISO 8601 format. The default is 2 seconds(PT2S). Note that this setting is ignored if VideoSyncMode.Passthrough is set, where the KeyFrameInterval value will follow the input source setting.
	KeyFrameInterval *string `pulumi:"keyFrameInterval"`
	// An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `pulumi:"label"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.Video'.
	OdataType string `pulumi:"odataType"`
	// The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize
	StretchMode *string `pulumi:"stretchMode"`
	// The Video Sync Mode
	SyncMode *string `pulumi:"syncMode"`
}

// A TrackSelection to select video tracks.
type VideoTrackDescriptor struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoTrackDescriptor'.
	OdataType string `pulumi:"odataType"`
}

// A TrackSelection to select video tracks.
type VideoTrackDescriptorResponse struct {
	// The discriminator for derived types.
	// Expected value is '#Microsoft.Media.VideoTrackDescriptor'.
	OdataType string `pulumi:"odataType"`
}

func init() {
	pulumi.RegisterOutputType(AccountEncryptionOutput{})
	pulumi.RegisterOutputType(AccountEncryptionPtrOutput{})
	pulumi.RegisterOutputType(AccountEncryptionResponseOutput{})
	pulumi.RegisterOutputType(AccountEncryptionResponsePtrOutput{})
	pulumi.RegisterOutputType(AkamaiAccessControlOutput{})
	pulumi.RegisterOutputType(AkamaiAccessControlPtrOutput{})
	pulumi.RegisterOutputType(AkamaiAccessControlResponseOutput{})
	pulumi.RegisterOutputType(AkamaiAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(AkamaiSignatureHeaderAuthenticationKeyOutput{})
	pulumi.RegisterOutputType(AkamaiSignatureHeaderAuthenticationKeyArrayOutput{})
	pulumi.RegisterOutputType(AkamaiSignatureHeaderAuthenticationKeyResponseOutput{})
	pulumi.RegisterOutputType(AkamaiSignatureHeaderAuthenticationKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(AssetFileEncryptionMetadataResponseOutput{})
	pulumi.RegisterOutputType(AssetFileEncryptionMetadataResponseArrayOutput{})
	pulumi.RegisterOutputType(AssetStreamingLocatorResponseOutput{})
	pulumi.RegisterOutputType(AssetStreamingLocatorResponseArrayOutput{})
	pulumi.RegisterOutputType(CbcsDrmConfigurationOutput{})
	pulumi.RegisterOutputType(CbcsDrmConfigurationPtrOutput{})
	pulumi.RegisterOutputType(CbcsDrmConfigurationResponseOutput{})
	pulumi.RegisterOutputType(CbcsDrmConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(CencDrmConfigurationOutput{})
	pulumi.RegisterOutputType(CencDrmConfigurationPtrOutput{})
	pulumi.RegisterOutputType(CencDrmConfigurationResponseOutput{})
	pulumi.RegisterOutputType(CencDrmConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCbcsOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCbcsPtrOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCbcsResponseOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCbcsResponsePtrOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCencOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCencPtrOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCencResponseOutput{})
	pulumi.RegisterOutputType(CommonEncryptionCencResponsePtrOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOptionOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOptionArrayOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOptionResponseOutput{})
	pulumi.RegisterOutputType(ContentKeyPolicyOptionResponseArrayOutput{})
	pulumi.RegisterOutputType(CrossSiteAccessPoliciesOutput{})
	pulumi.RegisterOutputType(CrossSiteAccessPoliciesPtrOutput{})
	pulumi.RegisterOutputType(CrossSiteAccessPoliciesResponseOutput{})
	pulumi.RegisterOutputType(CrossSiteAccessPoliciesResponsePtrOutput{})
	pulumi.RegisterOutputType(DefaultKeyOutput{})
	pulumi.RegisterOutputType(DefaultKeyPtrOutput{})
	pulumi.RegisterOutputType(DefaultKeyResponseOutput{})
	pulumi.RegisterOutputType(DefaultKeyResponsePtrOutput{})
	pulumi.RegisterOutputType(EdgeUsageDataCollectionPolicyResponseOutput{})
	pulumi.RegisterOutputType(EdgeUsageDataCollectionPolicyResponsePtrOutput{})
	pulumi.RegisterOutputType(EdgeUsageDataEventHubResponseOutput{})
	pulumi.RegisterOutputType(EdgeUsageDataEventHubResponsePtrOutput{})
	pulumi.RegisterOutputType(EnabledProtocolsOutput{})
	pulumi.RegisterOutputType(EnabledProtocolsPtrOutput{})
	pulumi.RegisterOutputType(EnabledProtocolsResponseOutput{})
	pulumi.RegisterOutputType(EnabledProtocolsResponsePtrOutput{})
	pulumi.RegisterOutputType(EnvelopeEncryptionOutput{})
	pulumi.RegisterOutputType(EnvelopeEncryptionPtrOutput{})
	pulumi.RegisterOutputType(EnvelopeEncryptionResponseOutput{})
	pulumi.RegisterOutputType(EnvelopeEncryptionResponsePtrOutput{})
	pulumi.RegisterOutputType(FilterTrackPropertyConditionOutput{})
	pulumi.RegisterOutputType(FilterTrackPropertyConditionArrayOutput{})
	pulumi.RegisterOutputType(FilterTrackPropertyConditionResponseOutput{})
	pulumi.RegisterOutputType(FilterTrackPropertyConditionResponseArrayOutput{})
	pulumi.RegisterOutputType(FilterTrackSelectionOutput{})
	pulumi.RegisterOutputType(FilterTrackSelectionArrayOutput{})
	pulumi.RegisterOutputType(FilterTrackSelectionResponseOutput{})
	pulumi.RegisterOutputType(FilterTrackSelectionResponseArrayOutput{})
	pulumi.RegisterOutputType(FirstQualityOutput{})
	pulumi.RegisterOutputType(FirstQualityPtrOutput{})
	pulumi.RegisterOutputType(FirstQualityResponseOutput{})
	pulumi.RegisterOutputType(FirstQualityResponsePtrOutput{})
	pulumi.RegisterOutputType(HlsOutput{})
	pulumi.RegisterOutputType(HlsPtrOutput{})
	pulumi.RegisterOutputType(HlsResponseOutput{})
	pulumi.RegisterOutputType(HlsResponsePtrOutput{})
	pulumi.RegisterOutputType(IPAccessControlOutput{})
	pulumi.RegisterOutputType(IPAccessControlPtrOutput{})
	pulumi.RegisterOutputType(IPAccessControlResponseOutput{})
	pulumi.RegisterOutputType(IPAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(IPRangeOutput{})
	pulumi.RegisterOutputType(IPRangeArrayOutput{})
	pulumi.RegisterOutputType(IPRangeResponseOutput{})
	pulumi.RegisterOutputType(IPRangeResponseArrayOutput{})
	pulumi.RegisterOutputType(JobErrorDetailResponseOutput{})
	pulumi.RegisterOutputType(JobErrorDetailResponseArrayOutput{})
	pulumi.RegisterOutputType(JobErrorResponseOutput{})
	pulumi.RegisterOutputType(JobOutputAssetOutput{})
	pulumi.RegisterOutputType(JobOutputAssetArrayOutput{})
	pulumi.RegisterOutputType(JobOutputAssetResponseOutput{})
	pulumi.RegisterOutputType(JobOutputAssetResponseArrayOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesPtrOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesResponseOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventEncodingOutput{})
	pulumi.RegisterOutputType(LiveEventEncodingPtrOutput{})
	pulumi.RegisterOutputType(LiveEventEncodingResponseOutput{})
	pulumi.RegisterOutputType(LiveEventEncodingResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventEndpointOutput{})
	pulumi.RegisterOutputType(LiveEventEndpointArrayOutput{})
	pulumi.RegisterOutputType(LiveEventEndpointResponseOutput{})
	pulumi.RegisterOutputType(LiveEventEndpointResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventInputTypeOutput{})
	pulumi.RegisterOutputType(LiveEventInputAccessControlOutput{})
	pulumi.RegisterOutputType(LiveEventInputAccessControlPtrOutput{})
	pulumi.RegisterOutputType(LiveEventInputAccessControlResponseOutput{})
	pulumi.RegisterOutputType(LiveEventInputAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventInputResponseOutput{})
	pulumi.RegisterOutputType(LiveEventInputTrackSelectionOutput{})
	pulumi.RegisterOutputType(LiveEventInputTrackSelectionArrayOutput{})
	pulumi.RegisterOutputType(LiveEventInputTrackSelectionResponseOutput{})
	pulumi.RegisterOutputType(LiveEventInputTrackSelectionResponseArrayOutput{})
	pulumi.RegisterOutputType(LiveEventOutputTranscriptionTrackOutput{})
	pulumi.RegisterOutputType(LiveEventOutputTranscriptionTrackPtrOutput{})
	pulumi.RegisterOutputType(LiveEventOutputTranscriptionTrackResponseOutput{})
	pulumi.RegisterOutputType(LiveEventOutputTranscriptionTrackResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewPtrOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewAccessControlOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewAccessControlPtrOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewAccessControlResponseOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewResponseOutput{})
	pulumi.RegisterOutputType(LiveEventPreviewResponsePtrOutput{})
	pulumi.RegisterOutputType(LiveEventTranscriptionOutput{})
	pulumi.RegisterOutputType(LiveEventTranscriptionArrayOutput{})
	pulumi.RegisterOutputType(LiveEventTranscriptionResponseOutput{})
	pulumi.RegisterOutputType(LiveEventTranscriptionResponseArrayOutput{})
	pulumi.RegisterOutputType(MediaServiceIdentityOutput{})
	pulumi.RegisterOutputType(MediaServiceIdentityPtrOutput{})
	pulumi.RegisterOutputType(MediaServiceIdentityResponseOutput{})
	pulumi.RegisterOutputType(MediaServiceIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(NoEncryptionOutput{})
	pulumi.RegisterOutputType(NoEncryptionPtrOutput{})
	pulumi.RegisterOutputType(NoEncryptionResponseOutput{})
	pulumi.RegisterOutputType(NoEncryptionResponsePtrOutput{})
	pulumi.RegisterOutputType(PresentationTimeRangeOutput{})
	pulumi.RegisterOutputType(PresentationTimeRangePtrOutput{})
	pulumi.RegisterOutputType(PresentationTimeRangeResponseOutput{})
	pulumi.RegisterOutputType(PresentationTimeRangeResponsePtrOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResponsePtrOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateResponseOutput{})
	pulumi.RegisterOutputType(StorageAccountOutput{})
	pulumi.RegisterOutputType(StorageAccountArrayOutput{})
	pulumi.RegisterOutputType(StorageAccountResponseOutput{})
	pulumi.RegisterOutputType(StorageAccountResponseArrayOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlPtrOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlResponseOutput{})
	pulumi.RegisterOutputType(StreamingEndpointAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(StreamingLocatorContentKeyOutput{})
	pulumi.RegisterOutputType(StreamingLocatorContentKeyArrayOutput{})
	pulumi.RegisterOutputType(StreamingLocatorContentKeyResponseOutput{})
	pulumi.RegisterOutputType(StreamingLocatorContentKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(StreamingPathResponseOutput{})
	pulumi.RegisterOutputType(StreamingPathResponseArrayOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeyOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeyArrayOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeyResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeysOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeysPtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeysResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyContentKeysResponsePtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyFairPlayConfigurationOutput{})
	pulumi.RegisterOutputType(StreamingPolicyFairPlayConfigurationPtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyFairPlayConfigurationResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyFairPlayConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyPlayReadyConfigurationOutput{})
	pulumi.RegisterOutputType(StreamingPolicyPlayReadyConfigurationPtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyPlayReadyConfigurationResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyPlayReadyConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyWidevineConfigurationOutput{})
	pulumi.RegisterOutputType(StreamingPolicyWidevineConfigurationPtrOutput{})
	pulumi.RegisterOutputType(StreamingPolicyWidevineConfigurationResponseOutput{})
	pulumi.RegisterOutputType(StreamingPolicyWidevineConfigurationResponsePtrOutput{})
	pulumi.RegisterOutputType(SystemDataResponseOutput{})
	pulumi.RegisterOutputType(TrackPropertyConditionOutput{})
	pulumi.RegisterOutputType(TrackPropertyConditionArrayOutput{})
	pulumi.RegisterOutputType(TrackPropertyConditionResponseOutput{})
	pulumi.RegisterOutputType(TrackPropertyConditionResponseArrayOutput{})
	pulumi.RegisterOutputType(TrackSelectionOutput{})
	pulumi.RegisterOutputType(TrackSelectionArrayOutput{})
	pulumi.RegisterOutputType(TrackSelectionResponseOutput{})
	pulumi.RegisterOutputType(TrackSelectionResponseArrayOutput{})
	pulumi.RegisterOutputType(TransformOutputTypeOutput{})
	pulumi.RegisterOutputType(TransformOutputTypeArrayOutput{})
	pulumi.RegisterOutputType(TransformOutputResponseOutput{})
	pulumi.RegisterOutputType(TransformOutputResponseArrayOutput{})
}
