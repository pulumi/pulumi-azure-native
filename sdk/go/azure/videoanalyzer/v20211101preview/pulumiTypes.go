// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v20211101preview

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Defines how the Video Analyzer account is (optionally) encrypted.
type AccountEncryption struct {
	// The Key Vault identity.
	Identity *ResourceIdentity `pulumi:"identity"`
	// The properties of the key used to encrypt the account.
	KeyVaultProperties *KeyVaultProperties `pulumi:"keyVaultProperties"`
	// The type of key used to encrypt the Account Key.
	Type string `pulumi:"type"`
}

// AccountEncryptionInput is an input type that accepts AccountEncryptionArgs and AccountEncryptionOutput values.
// You can construct a concrete instance of `AccountEncryptionInput` via:
//
//	AccountEncryptionArgs{...}
type AccountEncryptionInput interface {
	pulumi.Input

	ToAccountEncryptionOutput() AccountEncryptionOutput
	ToAccountEncryptionOutputWithContext(context.Context) AccountEncryptionOutput
}

// Defines how the Video Analyzer account is (optionally) encrypted.
type AccountEncryptionArgs struct {
	// The Key Vault identity.
	Identity ResourceIdentityPtrInput `pulumi:"identity"`
	// The properties of the key used to encrypt the account.
	KeyVaultProperties KeyVaultPropertiesPtrInput `pulumi:"keyVaultProperties"`
	// The type of key used to encrypt the Account Key.
	Type pulumi.StringInput `pulumi:"type"`
}

func (AccountEncryptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AccountEncryption)(nil)).Elem()
}

func (i AccountEncryptionArgs) ToAccountEncryptionOutput() AccountEncryptionOutput {
	return i.ToAccountEncryptionOutputWithContext(context.Background())
}

func (i AccountEncryptionArgs) ToAccountEncryptionOutputWithContext(ctx context.Context) AccountEncryptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionOutput)
}

func (i AccountEncryptionArgs) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return i.ToAccountEncryptionPtrOutputWithContext(context.Background())
}

func (i AccountEncryptionArgs) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionOutput).ToAccountEncryptionPtrOutputWithContext(ctx)
}

// AccountEncryptionPtrInput is an input type that accepts AccountEncryptionArgs, AccountEncryptionPtr and AccountEncryptionPtrOutput values.
// You can construct a concrete instance of `AccountEncryptionPtrInput` via:
//
//	        AccountEncryptionArgs{...}
//
//	or:
//
//	        nil
type AccountEncryptionPtrInput interface {
	pulumi.Input

	ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput
	ToAccountEncryptionPtrOutputWithContext(context.Context) AccountEncryptionPtrOutput
}

type accountEncryptionPtrType AccountEncryptionArgs

func AccountEncryptionPtr(v *AccountEncryptionArgs) AccountEncryptionPtrInput {
	return (*accountEncryptionPtrType)(v)
}

func (*accountEncryptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryption)(nil)).Elem()
}

func (i *accountEncryptionPtrType) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return i.ToAccountEncryptionPtrOutputWithContext(context.Background())
}

func (i *accountEncryptionPtrType) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccountEncryptionPtrOutput)
}

// Defines how the Video Analyzer account is (optionally) encrypted.
type AccountEncryptionOutput struct{ *pulumi.OutputState }

func (AccountEncryptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccountEncryption)(nil)).Elem()
}

func (o AccountEncryptionOutput) ToAccountEncryptionOutput() AccountEncryptionOutput {
	return o
}

func (o AccountEncryptionOutput) ToAccountEncryptionOutputWithContext(ctx context.Context) AccountEncryptionOutput {
	return o
}

func (o AccountEncryptionOutput) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return o.ToAccountEncryptionPtrOutputWithContext(context.Background())
}

func (o AccountEncryptionOutput) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AccountEncryption) *AccountEncryption {
		return &v
	}).(AccountEncryptionPtrOutput)
}

// The Key Vault identity.
func (o AccountEncryptionOutput) Identity() ResourceIdentityPtrOutput {
	return o.ApplyT(func(v AccountEncryption) *ResourceIdentity { return v.Identity }).(ResourceIdentityPtrOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionOutput) KeyVaultProperties() KeyVaultPropertiesPtrOutput {
	return o.ApplyT(func(v AccountEncryption) *KeyVaultProperties { return v.KeyVaultProperties }).(KeyVaultPropertiesPtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AccountEncryption) string { return v.Type }).(pulumi.StringOutput)
}

type AccountEncryptionPtrOutput struct{ *pulumi.OutputState }

func (AccountEncryptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryption)(nil)).Elem()
}

func (o AccountEncryptionPtrOutput) ToAccountEncryptionPtrOutput() AccountEncryptionPtrOutput {
	return o
}

func (o AccountEncryptionPtrOutput) ToAccountEncryptionPtrOutputWithContext(ctx context.Context) AccountEncryptionPtrOutput {
	return o
}

func (o AccountEncryptionPtrOutput) Elem() AccountEncryptionOutput {
	return o.ApplyT(func(v *AccountEncryption) AccountEncryption {
		if v != nil {
			return *v
		}
		var ret AccountEncryption
		return ret
	}).(AccountEncryptionOutput)
}

// The Key Vault identity.
func (o AccountEncryptionPtrOutput) Identity() ResourceIdentityPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) *ResourceIdentity {
		if v == nil {
			return nil
		}
		return v.Identity
	}).(ResourceIdentityPtrOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionPtrOutput) KeyVaultProperties() KeyVaultPropertiesPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) *KeyVaultProperties {
		if v == nil {
			return nil
		}
		return v.KeyVaultProperties
	}).(KeyVaultPropertiesPtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryption) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// Defines how the Video Analyzer account is (optionally) encrypted.
type AccountEncryptionResponse struct {
	// The Key Vault identity.
	Identity *ResourceIdentityResponse `pulumi:"identity"`
	// The properties of the key used to encrypt the account.
	KeyVaultProperties *KeyVaultPropertiesResponse `pulumi:"keyVaultProperties"`
	// The current status of the Key Vault mapping.
	Status string `pulumi:"status"`
	// The type of key used to encrypt the Account Key.
	Type string `pulumi:"type"`
}

// Defines how the Video Analyzer account is (optionally) encrypted.
type AccountEncryptionResponseOutput struct{ *pulumi.OutputState }

func (AccountEncryptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccountEncryptionResponse)(nil)).Elem()
}

func (o AccountEncryptionResponseOutput) ToAccountEncryptionResponseOutput() AccountEncryptionResponseOutput {
	return o
}

func (o AccountEncryptionResponseOutput) ToAccountEncryptionResponseOutputWithContext(ctx context.Context) AccountEncryptionResponseOutput {
	return o
}

// The Key Vault identity.
func (o AccountEncryptionResponseOutput) Identity() ResourceIdentityResponsePtrOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) *ResourceIdentityResponse { return v.Identity }).(ResourceIdentityResponsePtrOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionResponseOutput) KeyVaultProperties() KeyVaultPropertiesResponsePtrOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) *KeyVaultPropertiesResponse { return v.KeyVaultProperties }).(KeyVaultPropertiesResponsePtrOutput)
}

// The current status of the Key Vault mapping.
func (o AccountEncryptionResponseOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) string { return v.Status }).(pulumi.StringOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AccountEncryptionResponse) string { return v.Type }).(pulumi.StringOutput)
}

type AccountEncryptionResponsePtrOutput struct{ *pulumi.OutputState }

func (AccountEncryptionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccountEncryptionResponse)(nil)).Elem()
}

func (o AccountEncryptionResponsePtrOutput) ToAccountEncryptionResponsePtrOutput() AccountEncryptionResponsePtrOutput {
	return o
}

func (o AccountEncryptionResponsePtrOutput) ToAccountEncryptionResponsePtrOutputWithContext(ctx context.Context) AccountEncryptionResponsePtrOutput {
	return o
}

func (o AccountEncryptionResponsePtrOutput) Elem() AccountEncryptionResponseOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) AccountEncryptionResponse {
		if v != nil {
			return *v
		}
		var ret AccountEncryptionResponse
		return ret
	}).(AccountEncryptionResponseOutput)
}

// The Key Vault identity.
func (o AccountEncryptionResponsePtrOutput) Identity() ResourceIdentityResponsePtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *ResourceIdentityResponse {
		if v == nil {
			return nil
		}
		return v.Identity
	}).(ResourceIdentityResponsePtrOutput)
}

// The properties of the key used to encrypt the account.
func (o AccountEncryptionResponsePtrOutput) KeyVaultProperties() KeyVaultPropertiesResponsePtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *KeyVaultPropertiesResponse {
		if v == nil {
			return nil
		}
		return v.KeyVaultProperties
	}).(KeyVaultPropertiesResponsePtrOutput)
}

// The current status of the Key Vault mapping.
func (o AccountEncryptionResponsePtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Status
	}).(pulumi.StringPtrOutput)
}

// The type of key used to encrypt the Account Key.
func (o AccountEncryptionResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AccountEncryptionResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// A custom preset for encoding audio with the AAC codec.
type AudioEncoderAac struct {
	// Bitrate, in kilobits per second or Kbps, at which audio should be encoded (2-channel stereo audio at a sampling rate of 48 kHz). Allowed values are 96, 112, 128, 160, 192, 224, and 256. If omitted, the bitrate of the input audio is used.
	BitrateKbps *string `pulumi:"bitrateKbps"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.AudioEncoderAac'.
	Type string `pulumi:"type"`
}

// A custom preset for encoding audio with the AAC codec.
type AudioEncoderAacResponse struct {
	// Bitrate, in kilobits per second or Kbps, at which audio should be encoded (2-channel stereo audio at a sampling rate of 48 kHz). Allowed values are 96, 112, 128, 160, 192, 224, and 256. If omitted, the bitrate of the input audio is used.
	BitrateKbps *string `pulumi:"bitrateKbps"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.AudioEncoderAac'.
	Type string `pulumi:"type"`
}

// Required validation properties for tokens generated with Elliptical Curve algorithm.
type EccTokenKey struct {
	// Elliptical curve algorithm to be used: ES256, ES384 or ES512.
	Alg string `pulumi:"alg"`
	// JWT token key id. Validation keys are looked up based on the key id present on the JWT token header.
	Kid string `pulumi:"kid"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.EccTokenKey'.
	Type string `pulumi:"type"`
	// X coordinate.
	X string `pulumi:"x"`
	// Y coordinate.
	Y string `pulumi:"y"`
}

// Required validation properties for tokens generated with Elliptical Curve algorithm.
type EccTokenKeyResponse struct {
	// Elliptical curve algorithm to be used: ES256, ES384 or ES512.
	Alg string `pulumi:"alg"`
	// JWT token key id. Validation keys are looked up based on the key id present on the JWT token header.
	Kid string `pulumi:"kid"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.EccTokenKey'.
	Type string `pulumi:"type"`
	// X coordinate.
	X string `pulumi:"x"`
	// Y coordinate.
	Y string `pulumi:"y"`
}

// Describes a custom preset for encoding the input content using the encoder processor.
type EncoderCustomPreset struct {
	// Describes a custom preset for encoding audio.
	AudioEncoder *AudioEncoderAac `pulumi:"audioEncoder"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.EncoderCustomPreset'.
	Type string `pulumi:"type"`
	// Describes a custom preset for encoding video.
	VideoEncoder *VideoEncoderH264 `pulumi:"videoEncoder"`
}

// Describes a custom preset for encoding the input content using the encoder processor.
type EncoderCustomPresetResponse struct {
	// Describes a custom preset for encoding audio.
	AudioEncoder *AudioEncoderAacResponse `pulumi:"audioEncoder"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.EncoderCustomPreset'.
	Type string `pulumi:"type"`
	// Describes a custom preset for encoding video.
	VideoEncoder *VideoEncoderH264Response `pulumi:"videoEncoder"`
}

// Encoder processor allows for encoding of the input content. For example, it can used to change the resolution from 4K to 1280x720.
type EncoderProcessor struct {
	// An array of upstream node references within the topology to be used as inputs for this node.
	Inputs []NodeInput `pulumi:"inputs"`
	// Node name. Must be unique within the topology.
	Name string `pulumi:"name"`
	// The encoder preset, which defines the recipe or instructions on how the input content should be processed.
	Preset interface{} `pulumi:"preset"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.EncoderProcessor'.
	Type string `pulumi:"type"`
}

// EncoderProcessorInput is an input type that accepts EncoderProcessorArgs and EncoderProcessorOutput values.
// You can construct a concrete instance of `EncoderProcessorInput` via:
//
//	EncoderProcessorArgs{...}
type EncoderProcessorInput interface {
	pulumi.Input

	ToEncoderProcessorOutput() EncoderProcessorOutput
	ToEncoderProcessorOutputWithContext(context.Context) EncoderProcessorOutput
}

// Encoder processor allows for encoding of the input content. For example, it can used to change the resolution from 4K to 1280x720.
type EncoderProcessorArgs struct {
	// An array of upstream node references within the topology to be used as inputs for this node.
	Inputs NodeInputArrayInput `pulumi:"inputs"`
	// Node name. Must be unique within the topology.
	Name pulumi.StringInput `pulumi:"name"`
	// The encoder preset, which defines the recipe or instructions on how the input content should be processed.
	Preset pulumi.Input `pulumi:"preset"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.EncoderProcessor'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (EncoderProcessorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EncoderProcessor)(nil)).Elem()
}

func (i EncoderProcessorArgs) ToEncoderProcessorOutput() EncoderProcessorOutput {
	return i.ToEncoderProcessorOutputWithContext(context.Background())
}

func (i EncoderProcessorArgs) ToEncoderProcessorOutputWithContext(ctx context.Context) EncoderProcessorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncoderProcessorOutput)
}

// EncoderProcessorArrayInput is an input type that accepts EncoderProcessorArray and EncoderProcessorArrayOutput values.
// You can construct a concrete instance of `EncoderProcessorArrayInput` via:
//
//	EncoderProcessorArray{ EncoderProcessorArgs{...} }
type EncoderProcessorArrayInput interface {
	pulumi.Input

	ToEncoderProcessorArrayOutput() EncoderProcessorArrayOutput
	ToEncoderProcessorArrayOutputWithContext(context.Context) EncoderProcessorArrayOutput
}

type EncoderProcessorArray []EncoderProcessorInput

func (EncoderProcessorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EncoderProcessor)(nil)).Elem()
}

func (i EncoderProcessorArray) ToEncoderProcessorArrayOutput() EncoderProcessorArrayOutput {
	return i.ToEncoderProcessorArrayOutputWithContext(context.Background())
}

func (i EncoderProcessorArray) ToEncoderProcessorArrayOutputWithContext(ctx context.Context) EncoderProcessorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncoderProcessorArrayOutput)
}

// Encoder processor allows for encoding of the input content. For example, it can used to change the resolution from 4K to 1280x720.
type EncoderProcessorOutput struct{ *pulumi.OutputState }

func (EncoderProcessorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EncoderProcessor)(nil)).Elem()
}

func (o EncoderProcessorOutput) ToEncoderProcessorOutput() EncoderProcessorOutput {
	return o
}

func (o EncoderProcessorOutput) ToEncoderProcessorOutputWithContext(ctx context.Context) EncoderProcessorOutput {
	return o
}

// An array of upstream node references within the topology to be used as inputs for this node.
func (o EncoderProcessorOutput) Inputs() NodeInputArrayOutput {
	return o.ApplyT(func(v EncoderProcessor) []NodeInput { return v.Inputs }).(NodeInputArrayOutput)
}

// Node name. Must be unique within the topology.
func (o EncoderProcessorOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v EncoderProcessor) string { return v.Name }).(pulumi.StringOutput)
}

// The encoder preset, which defines the recipe or instructions on how the input content should be processed.
func (o EncoderProcessorOutput) Preset() pulumi.AnyOutput {
	return o.ApplyT(func(v EncoderProcessor) interface{} { return v.Preset }).(pulumi.AnyOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.VideoAnalyzer.EncoderProcessor'.
func (o EncoderProcessorOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v EncoderProcessor) string { return v.Type }).(pulumi.StringOutput)
}

type EncoderProcessorArrayOutput struct{ *pulumi.OutputState }

func (EncoderProcessorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EncoderProcessor)(nil)).Elem()
}

func (o EncoderProcessorArrayOutput) ToEncoderProcessorArrayOutput() EncoderProcessorArrayOutput {
	return o
}

func (o EncoderProcessorArrayOutput) ToEncoderProcessorArrayOutputWithContext(ctx context.Context) EncoderProcessorArrayOutput {
	return o
}

func (o EncoderProcessorArrayOutput) Index(i pulumi.IntInput) EncoderProcessorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EncoderProcessor {
		return vs[0].([]EncoderProcessor)[vs[1].(int)]
	}).(EncoderProcessorOutput)
}

// Encoder processor allows for encoding of the input content. For example, it can used to change the resolution from 4K to 1280x720.
type EncoderProcessorResponse struct {
	// An array of upstream node references within the topology to be used as inputs for this node.
	Inputs []NodeInputResponse `pulumi:"inputs"`
	// Node name. Must be unique within the topology.
	Name string `pulumi:"name"`
	// The encoder preset, which defines the recipe or instructions on how the input content should be processed.
	Preset interface{} `pulumi:"preset"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.EncoderProcessor'.
	Type string `pulumi:"type"`
}

// Encoder processor allows for encoding of the input content. For example, it can used to change the resolution from 4K to 1280x720.
type EncoderProcessorResponseOutput struct{ *pulumi.OutputState }

func (EncoderProcessorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EncoderProcessorResponse)(nil)).Elem()
}

func (o EncoderProcessorResponseOutput) ToEncoderProcessorResponseOutput() EncoderProcessorResponseOutput {
	return o
}

func (o EncoderProcessorResponseOutput) ToEncoderProcessorResponseOutputWithContext(ctx context.Context) EncoderProcessorResponseOutput {
	return o
}

// An array of upstream node references within the topology to be used as inputs for this node.
func (o EncoderProcessorResponseOutput) Inputs() NodeInputResponseArrayOutput {
	return o.ApplyT(func(v EncoderProcessorResponse) []NodeInputResponse { return v.Inputs }).(NodeInputResponseArrayOutput)
}

// Node name. Must be unique within the topology.
func (o EncoderProcessorResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v EncoderProcessorResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The encoder preset, which defines the recipe or instructions on how the input content should be processed.
func (o EncoderProcessorResponseOutput) Preset() pulumi.AnyOutput {
	return o.ApplyT(func(v EncoderProcessorResponse) interface{} { return v.Preset }).(pulumi.AnyOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.VideoAnalyzer.EncoderProcessor'.
func (o EncoderProcessorResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v EncoderProcessorResponse) string { return v.Type }).(pulumi.StringOutput)
}

type EncoderProcessorResponseArrayOutput struct{ *pulumi.OutputState }

func (EncoderProcessorResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EncoderProcessorResponse)(nil)).Elem()
}

func (o EncoderProcessorResponseArrayOutput) ToEncoderProcessorResponseArrayOutput() EncoderProcessorResponseArrayOutput {
	return o
}

func (o EncoderProcessorResponseArrayOutput) ToEncoderProcessorResponseArrayOutputWithContext(ctx context.Context) EncoderProcessorResponseArrayOutput {
	return o
}

func (o EncoderProcessorResponseArrayOutput) Index(i pulumi.IntInput) EncoderProcessorResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EncoderProcessorResponse {
		return vs[0].([]EncoderProcessorResponse)[vs[1].(int)]
	}).(EncoderProcessorResponseOutput)
}

// Describes a built-in preset for encoding the input content using the encoder processor.
type EncoderSystemPreset struct {
	// Name of the built-in encoding preset.
	Name string `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.EncoderSystemPreset'.
	Type string `pulumi:"type"`
}

// Describes a built-in preset for encoding the input content using the encoder processor.
type EncoderSystemPresetResponse struct {
	// Name of the built-in encoding preset.
	Name string `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.EncoderSystemPreset'.
	Type string `pulumi:"type"`
}

// The endpoint details.
type EndpointResponse struct {
	// The URL of the endpoint.
	EndpointUrl *string `pulumi:"endpointUrl"`
	// The type of the endpoint.
	Type string `pulumi:"type"`
}

// The endpoint details.
type EndpointResponseOutput struct{ *pulumi.OutputState }

func (EndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EndpointResponse)(nil)).Elem()
}

func (o EndpointResponseOutput) ToEndpointResponseOutput() EndpointResponseOutput {
	return o
}

func (o EndpointResponseOutput) ToEndpointResponseOutputWithContext(ctx context.Context) EndpointResponseOutput {
	return o
}

// The URL of the endpoint.
func (o EndpointResponseOutput) EndpointUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EndpointResponse) *string { return v.EndpointUrl }).(pulumi.StringPtrOutput)
}

// The type of the endpoint.
func (o EndpointResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v EndpointResponse) string { return v.Type }).(pulumi.StringOutput)
}

type EndpointResponseArrayOutput struct{ *pulumi.OutputState }

func (EndpointResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EndpointResponse)(nil)).Elem()
}

func (o EndpointResponseArrayOutput) ToEndpointResponseArrayOutput() EndpointResponseArrayOutput {
	return o
}

func (o EndpointResponseArrayOutput) ToEndpointResponseArrayOutputWithContext(ctx context.Context) EndpointResponseArrayOutput {
	return o
}

func (o EndpointResponseArrayOutput) Index(i pulumi.IntInput) EndpointResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EndpointResponse {
		return vs[0].([]EndpointResponse)[vs[1].(int)]
	}).(EndpointResponseOutput)
}

// Group level network access control.
type GroupLevelAccessControl struct {
	// Whether or not public network access is allowed for specified resources under the Video Analyzer account.
	PublicNetworkAccess *string `pulumi:"publicNetworkAccess"`
}

// GroupLevelAccessControlInput is an input type that accepts GroupLevelAccessControlArgs and GroupLevelAccessControlOutput values.
// You can construct a concrete instance of `GroupLevelAccessControlInput` via:
//
//	GroupLevelAccessControlArgs{...}
type GroupLevelAccessControlInput interface {
	pulumi.Input

	ToGroupLevelAccessControlOutput() GroupLevelAccessControlOutput
	ToGroupLevelAccessControlOutputWithContext(context.Context) GroupLevelAccessControlOutput
}

// Group level network access control.
type GroupLevelAccessControlArgs struct {
	// Whether or not public network access is allowed for specified resources under the Video Analyzer account.
	PublicNetworkAccess pulumi.StringPtrInput `pulumi:"publicNetworkAccess"`
}

func (GroupLevelAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupLevelAccessControl)(nil)).Elem()
}

func (i GroupLevelAccessControlArgs) ToGroupLevelAccessControlOutput() GroupLevelAccessControlOutput {
	return i.ToGroupLevelAccessControlOutputWithContext(context.Background())
}

func (i GroupLevelAccessControlArgs) ToGroupLevelAccessControlOutputWithContext(ctx context.Context) GroupLevelAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupLevelAccessControlOutput)
}

func (i GroupLevelAccessControlArgs) ToGroupLevelAccessControlPtrOutput() GroupLevelAccessControlPtrOutput {
	return i.ToGroupLevelAccessControlPtrOutputWithContext(context.Background())
}

func (i GroupLevelAccessControlArgs) ToGroupLevelAccessControlPtrOutputWithContext(ctx context.Context) GroupLevelAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupLevelAccessControlOutput).ToGroupLevelAccessControlPtrOutputWithContext(ctx)
}

// GroupLevelAccessControlPtrInput is an input type that accepts GroupLevelAccessControlArgs, GroupLevelAccessControlPtr and GroupLevelAccessControlPtrOutput values.
// You can construct a concrete instance of `GroupLevelAccessControlPtrInput` via:
//
//	        GroupLevelAccessControlArgs{...}
//
//	or:
//
//	        nil
type GroupLevelAccessControlPtrInput interface {
	pulumi.Input

	ToGroupLevelAccessControlPtrOutput() GroupLevelAccessControlPtrOutput
	ToGroupLevelAccessControlPtrOutputWithContext(context.Context) GroupLevelAccessControlPtrOutput
}

type groupLevelAccessControlPtrType GroupLevelAccessControlArgs

func GroupLevelAccessControlPtr(v *GroupLevelAccessControlArgs) GroupLevelAccessControlPtrInput {
	return (*groupLevelAccessControlPtrType)(v)
}

func (*groupLevelAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupLevelAccessControl)(nil)).Elem()
}

func (i *groupLevelAccessControlPtrType) ToGroupLevelAccessControlPtrOutput() GroupLevelAccessControlPtrOutput {
	return i.ToGroupLevelAccessControlPtrOutputWithContext(context.Background())
}

func (i *groupLevelAccessControlPtrType) ToGroupLevelAccessControlPtrOutputWithContext(ctx context.Context) GroupLevelAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupLevelAccessControlPtrOutput)
}

// Group level network access control.
type GroupLevelAccessControlOutput struct{ *pulumi.OutputState }

func (GroupLevelAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupLevelAccessControl)(nil)).Elem()
}

func (o GroupLevelAccessControlOutput) ToGroupLevelAccessControlOutput() GroupLevelAccessControlOutput {
	return o
}

func (o GroupLevelAccessControlOutput) ToGroupLevelAccessControlOutputWithContext(ctx context.Context) GroupLevelAccessControlOutput {
	return o
}

func (o GroupLevelAccessControlOutput) ToGroupLevelAccessControlPtrOutput() GroupLevelAccessControlPtrOutput {
	return o.ToGroupLevelAccessControlPtrOutputWithContext(context.Background())
}

func (o GroupLevelAccessControlOutput) ToGroupLevelAccessControlPtrOutputWithContext(ctx context.Context) GroupLevelAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GroupLevelAccessControl) *GroupLevelAccessControl {
		return &v
	}).(GroupLevelAccessControlPtrOutput)
}

// Whether or not public network access is allowed for specified resources under the Video Analyzer account.
func (o GroupLevelAccessControlOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupLevelAccessControl) *string { return v.PublicNetworkAccess }).(pulumi.StringPtrOutput)
}

type GroupLevelAccessControlPtrOutput struct{ *pulumi.OutputState }

func (GroupLevelAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupLevelAccessControl)(nil)).Elem()
}

func (o GroupLevelAccessControlPtrOutput) ToGroupLevelAccessControlPtrOutput() GroupLevelAccessControlPtrOutput {
	return o
}

func (o GroupLevelAccessControlPtrOutput) ToGroupLevelAccessControlPtrOutputWithContext(ctx context.Context) GroupLevelAccessControlPtrOutput {
	return o
}

func (o GroupLevelAccessControlPtrOutput) Elem() GroupLevelAccessControlOutput {
	return o.ApplyT(func(v *GroupLevelAccessControl) GroupLevelAccessControl {
		if v != nil {
			return *v
		}
		var ret GroupLevelAccessControl
		return ret
	}).(GroupLevelAccessControlOutput)
}

// Whether or not public network access is allowed for specified resources under the Video Analyzer account.
func (o GroupLevelAccessControlPtrOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GroupLevelAccessControl) *string {
		if v == nil {
			return nil
		}
		return v.PublicNetworkAccess
	}).(pulumi.StringPtrOutput)
}

// Group level network access control.
type GroupLevelAccessControlResponse struct {
	// Whether or not public network access is allowed for specified resources under the Video Analyzer account.
	PublicNetworkAccess *string `pulumi:"publicNetworkAccess"`
}

// Group level network access control.
type GroupLevelAccessControlResponseOutput struct{ *pulumi.OutputState }

func (GroupLevelAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupLevelAccessControlResponse)(nil)).Elem()
}

func (o GroupLevelAccessControlResponseOutput) ToGroupLevelAccessControlResponseOutput() GroupLevelAccessControlResponseOutput {
	return o
}

func (o GroupLevelAccessControlResponseOutput) ToGroupLevelAccessControlResponseOutputWithContext(ctx context.Context) GroupLevelAccessControlResponseOutput {
	return o
}

// Whether or not public network access is allowed for specified resources under the Video Analyzer account.
func (o GroupLevelAccessControlResponseOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupLevelAccessControlResponse) *string { return v.PublicNetworkAccess }).(pulumi.StringPtrOutput)
}

type GroupLevelAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (GroupLevelAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupLevelAccessControlResponse)(nil)).Elem()
}

func (o GroupLevelAccessControlResponsePtrOutput) ToGroupLevelAccessControlResponsePtrOutput() GroupLevelAccessControlResponsePtrOutput {
	return o
}

func (o GroupLevelAccessControlResponsePtrOutput) ToGroupLevelAccessControlResponsePtrOutputWithContext(ctx context.Context) GroupLevelAccessControlResponsePtrOutput {
	return o
}

func (o GroupLevelAccessControlResponsePtrOutput) Elem() GroupLevelAccessControlResponseOutput {
	return o.ApplyT(func(v *GroupLevelAccessControlResponse) GroupLevelAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret GroupLevelAccessControlResponse
		return ret
	}).(GroupLevelAccessControlResponseOutput)
}

// Whether or not public network access is allowed for specified resources under the Video Analyzer account.
func (o GroupLevelAccessControlResponsePtrOutput) PublicNetworkAccess() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GroupLevelAccessControlResponse) *string {
		if v == nil {
			return nil
		}
		return v.PublicNetworkAccess
	}).(pulumi.StringPtrOutput)
}

// The IoT Hub details.
type IotHub struct {
	// The IoT Hub resource identifier.
	Id string `pulumi:"id"`
	// The IoT Hub identity.
	Identity ResourceIdentity `pulumi:"identity"`
}

// IotHubInput is an input type that accepts IotHubArgs and IotHubOutput values.
// You can construct a concrete instance of `IotHubInput` via:
//
//	IotHubArgs{...}
type IotHubInput interface {
	pulumi.Input

	ToIotHubOutput() IotHubOutput
	ToIotHubOutputWithContext(context.Context) IotHubOutput
}

// The IoT Hub details.
type IotHubArgs struct {
	// The IoT Hub resource identifier.
	Id pulumi.StringInput `pulumi:"id"`
	// The IoT Hub identity.
	Identity ResourceIdentityInput `pulumi:"identity"`
}

func (IotHubArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IotHub)(nil)).Elem()
}

func (i IotHubArgs) ToIotHubOutput() IotHubOutput {
	return i.ToIotHubOutputWithContext(context.Background())
}

func (i IotHubArgs) ToIotHubOutputWithContext(ctx context.Context) IotHubOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IotHubOutput)
}

// IotHubArrayInput is an input type that accepts IotHubArray and IotHubArrayOutput values.
// You can construct a concrete instance of `IotHubArrayInput` via:
//
//	IotHubArray{ IotHubArgs{...} }
type IotHubArrayInput interface {
	pulumi.Input

	ToIotHubArrayOutput() IotHubArrayOutput
	ToIotHubArrayOutputWithContext(context.Context) IotHubArrayOutput
}

type IotHubArray []IotHubInput

func (IotHubArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IotHub)(nil)).Elem()
}

func (i IotHubArray) ToIotHubArrayOutput() IotHubArrayOutput {
	return i.ToIotHubArrayOutputWithContext(context.Background())
}

func (i IotHubArray) ToIotHubArrayOutputWithContext(ctx context.Context) IotHubArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IotHubArrayOutput)
}

// The IoT Hub details.
type IotHubOutput struct{ *pulumi.OutputState }

func (IotHubOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IotHub)(nil)).Elem()
}

func (o IotHubOutput) ToIotHubOutput() IotHubOutput {
	return o
}

func (o IotHubOutput) ToIotHubOutputWithContext(ctx context.Context) IotHubOutput {
	return o
}

// The IoT Hub resource identifier.
func (o IotHubOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v IotHub) string { return v.Id }).(pulumi.StringOutput)
}

// The IoT Hub identity.
func (o IotHubOutput) Identity() ResourceIdentityOutput {
	return o.ApplyT(func(v IotHub) ResourceIdentity { return v.Identity }).(ResourceIdentityOutput)
}

type IotHubArrayOutput struct{ *pulumi.OutputState }

func (IotHubArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IotHub)(nil)).Elem()
}

func (o IotHubArrayOutput) ToIotHubArrayOutput() IotHubArrayOutput {
	return o
}

func (o IotHubArrayOutput) ToIotHubArrayOutputWithContext(ctx context.Context) IotHubArrayOutput {
	return o
}

func (o IotHubArrayOutput) Index(i pulumi.IntInput) IotHubOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IotHub {
		return vs[0].([]IotHub)[vs[1].(int)]
	}).(IotHubOutput)
}

// The IoT Hub details.
type IotHubResponse struct {
	// The IoT Hub resource identifier.
	Id string `pulumi:"id"`
	// The IoT Hub identity.
	Identity ResourceIdentityResponse `pulumi:"identity"`
	// The current status of the Iot Hub mapping.
	Status string `pulumi:"status"`
}

// The IoT Hub details.
type IotHubResponseOutput struct{ *pulumi.OutputState }

func (IotHubResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IotHubResponse)(nil)).Elem()
}

func (o IotHubResponseOutput) ToIotHubResponseOutput() IotHubResponseOutput {
	return o
}

func (o IotHubResponseOutput) ToIotHubResponseOutputWithContext(ctx context.Context) IotHubResponseOutput {
	return o
}

// The IoT Hub resource identifier.
func (o IotHubResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v IotHubResponse) string { return v.Id }).(pulumi.StringOutput)
}

// The IoT Hub identity.
func (o IotHubResponseOutput) Identity() ResourceIdentityResponseOutput {
	return o.ApplyT(func(v IotHubResponse) ResourceIdentityResponse { return v.Identity }).(ResourceIdentityResponseOutput)
}

// The current status of the Iot Hub mapping.
func (o IotHubResponseOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v IotHubResponse) string { return v.Status }).(pulumi.StringOutput)
}

type IotHubResponseArrayOutput struct{ *pulumi.OutputState }

func (IotHubResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IotHubResponse)(nil)).Elem()
}

func (o IotHubResponseArrayOutput) ToIotHubResponseArrayOutput() IotHubResponseArrayOutput {
	return o
}

func (o IotHubResponseArrayOutput) ToIotHubResponseArrayOutputWithContext(ctx context.Context) IotHubResponseArrayOutput {
	return o
}

func (o IotHubResponseArrayOutput) Index(i pulumi.IntInput) IotHubResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IotHubResponse {
		return vs[0].([]IotHubResponse)[vs[1].(int)]
	}).(IotHubResponseOutput)
}

// Properties for access validation based on JSON Web Tokens (JWT).
type JwtAuthentication struct {
	// List of expected token audiences. Token audience is valid if it matches at least one of the given values.
	Audiences []string `pulumi:"audiences"`
	// List of additional token claims to be validated. Token must contains all claims and respective values for it to be valid.
	Claims []TokenClaim `pulumi:"claims"`
	// List of expected token issuers. Token issuer is valid if it matches at least one of the given values.
	Issuers []string `pulumi:"issuers"`
	// List of keys which can be used to validate access tokens. Having multiple keys allow for seamless key rotation of the token signing key. Token signature must match exactly one key.
	Keys []interface{} `pulumi:"keys"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.JwtAuthentication'.
	Type string `pulumi:"type"`
}

// JwtAuthenticationInput is an input type that accepts JwtAuthenticationArgs and JwtAuthenticationOutput values.
// You can construct a concrete instance of `JwtAuthenticationInput` via:
//
//	JwtAuthenticationArgs{...}
type JwtAuthenticationInput interface {
	pulumi.Input

	ToJwtAuthenticationOutput() JwtAuthenticationOutput
	ToJwtAuthenticationOutputWithContext(context.Context) JwtAuthenticationOutput
}

// Properties for access validation based on JSON Web Tokens (JWT).
type JwtAuthenticationArgs struct {
	// List of expected token audiences. Token audience is valid if it matches at least one of the given values.
	Audiences pulumi.StringArrayInput `pulumi:"audiences"`
	// List of additional token claims to be validated. Token must contains all claims and respective values for it to be valid.
	Claims TokenClaimArrayInput `pulumi:"claims"`
	// List of expected token issuers. Token issuer is valid if it matches at least one of the given values.
	Issuers pulumi.StringArrayInput `pulumi:"issuers"`
	// List of keys which can be used to validate access tokens. Having multiple keys allow for seamless key rotation of the token signing key. Token signature must match exactly one key.
	Keys pulumi.ArrayInput `pulumi:"keys"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.JwtAuthentication'.
	Type pulumi.StringInput `pulumi:"type"`
}

func (JwtAuthenticationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JwtAuthentication)(nil)).Elem()
}

func (i JwtAuthenticationArgs) ToJwtAuthenticationOutput() JwtAuthenticationOutput {
	return i.ToJwtAuthenticationOutputWithContext(context.Background())
}

func (i JwtAuthenticationArgs) ToJwtAuthenticationOutputWithContext(ctx context.Context) JwtAuthenticationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JwtAuthenticationOutput)
}

func (i JwtAuthenticationArgs) ToJwtAuthenticationPtrOutput() JwtAuthenticationPtrOutput {
	return i.ToJwtAuthenticationPtrOutputWithContext(context.Background())
}

func (i JwtAuthenticationArgs) ToJwtAuthenticationPtrOutputWithContext(ctx context.Context) JwtAuthenticationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JwtAuthenticationOutput).ToJwtAuthenticationPtrOutputWithContext(ctx)
}

// JwtAuthenticationPtrInput is an input type that accepts JwtAuthenticationArgs, JwtAuthenticationPtr and JwtAuthenticationPtrOutput values.
// You can construct a concrete instance of `JwtAuthenticationPtrInput` via:
//
//	        JwtAuthenticationArgs{...}
//
//	or:
//
//	        nil
type JwtAuthenticationPtrInput interface {
	pulumi.Input

	ToJwtAuthenticationPtrOutput() JwtAuthenticationPtrOutput
	ToJwtAuthenticationPtrOutputWithContext(context.Context) JwtAuthenticationPtrOutput
}

type jwtAuthenticationPtrType JwtAuthenticationArgs

func JwtAuthenticationPtr(v *JwtAuthenticationArgs) JwtAuthenticationPtrInput {
	return (*jwtAuthenticationPtrType)(v)
}

func (*jwtAuthenticationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JwtAuthentication)(nil)).Elem()
}

func (i *jwtAuthenticationPtrType) ToJwtAuthenticationPtrOutput() JwtAuthenticationPtrOutput {
	return i.ToJwtAuthenticationPtrOutputWithContext(context.Background())
}

func (i *jwtAuthenticationPtrType) ToJwtAuthenticationPtrOutputWithContext(ctx context.Context) JwtAuthenticationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JwtAuthenticationPtrOutput)
}

// Properties for access validation based on JSON Web Tokens (JWT).
type JwtAuthenticationOutput struct{ *pulumi.OutputState }

func (JwtAuthenticationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JwtAuthentication)(nil)).Elem()
}

func (o JwtAuthenticationOutput) ToJwtAuthenticationOutput() JwtAuthenticationOutput {
	return o
}

func (o JwtAuthenticationOutput) ToJwtAuthenticationOutputWithContext(ctx context.Context) JwtAuthenticationOutput {
	return o
}

func (o JwtAuthenticationOutput) ToJwtAuthenticationPtrOutput() JwtAuthenticationPtrOutput {
	return o.ToJwtAuthenticationPtrOutputWithContext(context.Background())
}

func (o JwtAuthenticationOutput) ToJwtAuthenticationPtrOutputWithContext(ctx context.Context) JwtAuthenticationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v JwtAuthentication) *JwtAuthentication {
		return &v
	}).(JwtAuthenticationPtrOutput)
}

// List of expected token audiences. Token audience is valid if it matches at least one of the given values.
func (o JwtAuthenticationOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JwtAuthentication) []string { return v.Audiences }).(pulumi.StringArrayOutput)
}

// List of additional token claims to be validated. Token must contains all claims and respective values for it to be valid.
func (o JwtAuthenticationOutput) Claims() TokenClaimArrayOutput {
	return o.ApplyT(func(v JwtAuthentication) []TokenClaim { return v.Claims }).(TokenClaimArrayOutput)
}

// List of expected token issuers. Token issuer is valid if it matches at least one of the given values.
func (o JwtAuthenticationOutput) Issuers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JwtAuthentication) []string { return v.Issuers }).(pulumi.StringArrayOutput)
}

// List of keys which can be used to validate access tokens. Having multiple keys allow for seamless key rotation of the token signing key. Token signature must match exactly one key.
func (o JwtAuthenticationOutput) Keys() pulumi.ArrayOutput {
	return o.ApplyT(func(v JwtAuthentication) []interface{} { return v.Keys }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.VideoAnalyzer.JwtAuthentication'.
func (o JwtAuthenticationOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v JwtAuthentication) string { return v.Type }).(pulumi.StringOutput)
}

type JwtAuthenticationPtrOutput struct{ *pulumi.OutputState }

func (JwtAuthenticationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JwtAuthentication)(nil)).Elem()
}

func (o JwtAuthenticationPtrOutput) ToJwtAuthenticationPtrOutput() JwtAuthenticationPtrOutput {
	return o
}

func (o JwtAuthenticationPtrOutput) ToJwtAuthenticationPtrOutputWithContext(ctx context.Context) JwtAuthenticationPtrOutput {
	return o
}

func (o JwtAuthenticationPtrOutput) Elem() JwtAuthenticationOutput {
	return o.ApplyT(func(v *JwtAuthentication) JwtAuthentication {
		if v != nil {
			return *v
		}
		var ret JwtAuthentication
		return ret
	}).(JwtAuthenticationOutput)
}

// List of expected token audiences. Token audience is valid if it matches at least one of the given values.
func (o JwtAuthenticationPtrOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JwtAuthentication) []string {
		if v == nil {
			return nil
		}
		return v.Audiences
	}).(pulumi.StringArrayOutput)
}

// List of additional token claims to be validated. Token must contains all claims and respective values for it to be valid.
func (o JwtAuthenticationPtrOutput) Claims() TokenClaimArrayOutput {
	return o.ApplyT(func(v *JwtAuthentication) []TokenClaim {
		if v == nil {
			return nil
		}
		return v.Claims
	}).(TokenClaimArrayOutput)
}

// List of expected token issuers. Token issuer is valid if it matches at least one of the given values.
func (o JwtAuthenticationPtrOutput) Issuers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JwtAuthentication) []string {
		if v == nil {
			return nil
		}
		return v.Issuers
	}).(pulumi.StringArrayOutput)
}

// List of keys which can be used to validate access tokens. Having multiple keys allow for seamless key rotation of the token signing key. Token signature must match exactly one key.
func (o JwtAuthenticationPtrOutput) Keys() pulumi.ArrayOutput {
	return o.ApplyT(func(v *JwtAuthentication) []interface{} {
		if v == nil {
			return nil
		}
		return v.Keys
	}).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.VideoAnalyzer.JwtAuthentication'.
func (o JwtAuthenticationPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JwtAuthentication) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// Properties for access validation based on JSON Web Tokens (JWT).
type JwtAuthenticationResponse struct {
	// List of expected token audiences. Token audience is valid if it matches at least one of the given values.
	Audiences []string `pulumi:"audiences"`
	// List of additional token claims to be validated. Token must contains all claims and respective values for it to be valid.
	Claims []TokenClaimResponse `pulumi:"claims"`
	// List of expected token issuers. Token issuer is valid if it matches at least one of the given values.
	Issuers []string `pulumi:"issuers"`
	// List of keys which can be used to validate access tokens. Having multiple keys allow for seamless key rotation of the token signing key. Token signature must match exactly one key.
	Keys []interface{} `pulumi:"keys"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.JwtAuthentication'.
	Type string `pulumi:"type"`
}

// Properties for access validation based on JSON Web Tokens (JWT).
type JwtAuthenticationResponseOutput struct{ *pulumi.OutputState }

func (JwtAuthenticationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JwtAuthenticationResponse)(nil)).Elem()
}

func (o JwtAuthenticationResponseOutput) ToJwtAuthenticationResponseOutput() JwtAuthenticationResponseOutput {
	return o
}

func (o JwtAuthenticationResponseOutput) ToJwtAuthenticationResponseOutputWithContext(ctx context.Context) JwtAuthenticationResponseOutput {
	return o
}

// List of expected token audiences. Token audience is valid if it matches at least one of the given values.
func (o JwtAuthenticationResponseOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JwtAuthenticationResponse) []string { return v.Audiences }).(pulumi.StringArrayOutput)
}

// List of additional token claims to be validated. Token must contains all claims and respective values for it to be valid.
func (o JwtAuthenticationResponseOutput) Claims() TokenClaimResponseArrayOutput {
	return o.ApplyT(func(v JwtAuthenticationResponse) []TokenClaimResponse { return v.Claims }).(TokenClaimResponseArrayOutput)
}

// List of expected token issuers. Token issuer is valid if it matches at least one of the given values.
func (o JwtAuthenticationResponseOutput) Issuers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JwtAuthenticationResponse) []string { return v.Issuers }).(pulumi.StringArrayOutput)
}

// List of keys which can be used to validate access tokens. Having multiple keys allow for seamless key rotation of the token signing key. Token signature must match exactly one key.
func (o JwtAuthenticationResponseOutput) Keys() pulumi.ArrayOutput {
	return o.ApplyT(func(v JwtAuthenticationResponse) []interface{} { return v.Keys }).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.VideoAnalyzer.JwtAuthentication'.
func (o JwtAuthenticationResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v JwtAuthenticationResponse) string { return v.Type }).(pulumi.StringOutput)
}

type JwtAuthenticationResponsePtrOutput struct{ *pulumi.OutputState }

func (JwtAuthenticationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JwtAuthenticationResponse)(nil)).Elem()
}

func (o JwtAuthenticationResponsePtrOutput) ToJwtAuthenticationResponsePtrOutput() JwtAuthenticationResponsePtrOutput {
	return o
}

func (o JwtAuthenticationResponsePtrOutput) ToJwtAuthenticationResponsePtrOutputWithContext(ctx context.Context) JwtAuthenticationResponsePtrOutput {
	return o
}

func (o JwtAuthenticationResponsePtrOutput) Elem() JwtAuthenticationResponseOutput {
	return o.ApplyT(func(v *JwtAuthenticationResponse) JwtAuthenticationResponse {
		if v != nil {
			return *v
		}
		var ret JwtAuthenticationResponse
		return ret
	}).(JwtAuthenticationResponseOutput)
}

// List of expected token audiences. Token audience is valid if it matches at least one of the given values.
func (o JwtAuthenticationResponsePtrOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JwtAuthenticationResponse) []string {
		if v == nil {
			return nil
		}
		return v.Audiences
	}).(pulumi.StringArrayOutput)
}

// List of additional token claims to be validated. Token must contains all claims and respective values for it to be valid.
func (o JwtAuthenticationResponsePtrOutput) Claims() TokenClaimResponseArrayOutput {
	return o.ApplyT(func(v *JwtAuthenticationResponse) []TokenClaimResponse {
		if v == nil {
			return nil
		}
		return v.Claims
	}).(TokenClaimResponseArrayOutput)
}

// List of expected token issuers. Token issuer is valid if it matches at least one of the given values.
func (o JwtAuthenticationResponsePtrOutput) Issuers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JwtAuthenticationResponse) []string {
		if v == nil {
			return nil
		}
		return v.Issuers
	}).(pulumi.StringArrayOutput)
}

// List of keys which can be used to validate access tokens. Having multiple keys allow for seamless key rotation of the token signing key. Token signature must match exactly one key.
func (o JwtAuthenticationResponsePtrOutput) Keys() pulumi.ArrayOutput {
	return o.ApplyT(func(v *JwtAuthenticationResponse) []interface{} {
		if v == nil {
			return nil
		}
		return v.Keys
	}).(pulumi.ArrayOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.VideoAnalyzer.JwtAuthentication'.
func (o JwtAuthenticationResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JwtAuthenticationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The details for accessing the encryption keys in Key Vault.
type KeyVaultProperties struct {
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
	KeyIdentifier string `pulumi:"keyIdentifier"`
}

// KeyVaultPropertiesInput is an input type that accepts KeyVaultPropertiesArgs and KeyVaultPropertiesOutput values.
// You can construct a concrete instance of `KeyVaultPropertiesInput` via:
//
//	KeyVaultPropertiesArgs{...}
type KeyVaultPropertiesInput interface {
	pulumi.Input

	ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput
	ToKeyVaultPropertiesOutputWithContext(context.Context) KeyVaultPropertiesOutput
}

// The details for accessing the encryption keys in Key Vault.
type KeyVaultPropertiesArgs struct {
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
	KeyIdentifier pulumi.StringInput `pulumi:"keyIdentifier"`
}

func (KeyVaultPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultProperties)(nil)).Elem()
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput {
	return i.ToKeyVaultPropertiesOutputWithContext(context.Background())
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesOutputWithContext(ctx context.Context) KeyVaultPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesOutput)
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return i.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i KeyVaultPropertiesArgs) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesOutput).ToKeyVaultPropertiesPtrOutputWithContext(ctx)
}

// KeyVaultPropertiesPtrInput is an input type that accepts KeyVaultPropertiesArgs, KeyVaultPropertiesPtr and KeyVaultPropertiesPtrOutput values.
// You can construct a concrete instance of `KeyVaultPropertiesPtrInput` via:
//
//	        KeyVaultPropertiesArgs{...}
//
//	or:
//
//	        nil
type KeyVaultPropertiesPtrInput interface {
	pulumi.Input

	ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput
	ToKeyVaultPropertiesPtrOutputWithContext(context.Context) KeyVaultPropertiesPtrOutput
}

type keyVaultPropertiesPtrType KeyVaultPropertiesArgs

func KeyVaultPropertiesPtr(v *KeyVaultPropertiesArgs) KeyVaultPropertiesPtrInput {
	return (*keyVaultPropertiesPtrType)(v)
}

func (*keyVaultPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultProperties)(nil)).Elem()
}

func (i *keyVaultPropertiesPtrType) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return i.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (i *keyVaultPropertiesPtrType) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyVaultPropertiesPtrOutput)
}

// The details for accessing the encryption keys in Key Vault.
type KeyVaultPropertiesOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultProperties)(nil)).Elem()
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesOutput() KeyVaultPropertiesOutput {
	return o
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesOutputWithContext(ctx context.Context) KeyVaultPropertiesOutput {
	return o
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return o.ToKeyVaultPropertiesPtrOutputWithContext(context.Background())
}

func (o KeyVaultPropertiesOutput) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeyVaultProperties) *KeyVaultProperties {
		return &v
	}).(KeyVaultPropertiesPtrOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesOutput) KeyIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v KeyVaultProperties) string { return v.KeyIdentifier }).(pulumi.StringOutput)
}

type KeyVaultPropertiesPtrOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultProperties)(nil)).Elem()
}

func (o KeyVaultPropertiesPtrOutput) ToKeyVaultPropertiesPtrOutput() KeyVaultPropertiesPtrOutput {
	return o
}

func (o KeyVaultPropertiesPtrOutput) ToKeyVaultPropertiesPtrOutputWithContext(ctx context.Context) KeyVaultPropertiesPtrOutput {
	return o
}

func (o KeyVaultPropertiesPtrOutput) Elem() KeyVaultPropertiesOutput {
	return o.ApplyT(func(v *KeyVaultProperties) KeyVaultProperties {
		if v != nil {
			return *v
		}
		var ret KeyVaultProperties
		return ret
	}).(KeyVaultPropertiesOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesPtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultProperties) *string {
		if v == nil {
			return nil
		}
		return &v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// The details for accessing the encryption keys in Key Vault.
type KeyVaultPropertiesResponse struct {
	// The current key used to encrypt Video Analyzer account, including the key version.
	CurrentKeyIdentifier string `pulumi:"currentKeyIdentifier"`
	// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
	KeyIdentifier string `pulumi:"keyIdentifier"`
}

// The details for accessing the encryption keys in Key Vault.
type KeyVaultPropertiesResponseOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyVaultPropertiesResponse)(nil)).Elem()
}

func (o KeyVaultPropertiesResponseOutput) ToKeyVaultPropertiesResponseOutput() KeyVaultPropertiesResponseOutput {
	return o
}

func (o KeyVaultPropertiesResponseOutput) ToKeyVaultPropertiesResponseOutputWithContext(ctx context.Context) KeyVaultPropertiesResponseOutput {
	return o
}

// The current key used to encrypt Video Analyzer account, including the key version.
func (o KeyVaultPropertiesResponseOutput) CurrentKeyIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v KeyVaultPropertiesResponse) string { return v.CurrentKeyIdentifier }).(pulumi.StringOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesResponseOutput) KeyIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v KeyVaultPropertiesResponse) string { return v.KeyIdentifier }).(pulumi.StringOutput)
}

type KeyVaultPropertiesResponsePtrOutput struct{ *pulumi.OutputState }

func (KeyVaultPropertiesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyVaultPropertiesResponse)(nil)).Elem()
}

func (o KeyVaultPropertiesResponsePtrOutput) ToKeyVaultPropertiesResponsePtrOutput() KeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o KeyVaultPropertiesResponsePtrOutput) ToKeyVaultPropertiesResponsePtrOutputWithContext(ctx context.Context) KeyVaultPropertiesResponsePtrOutput {
	return o
}

func (o KeyVaultPropertiesResponsePtrOutput) Elem() KeyVaultPropertiesResponseOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) KeyVaultPropertiesResponse {
		if v != nil {
			return *v
		}
		var ret KeyVaultPropertiesResponse
		return ret
	}).(KeyVaultPropertiesResponseOutput)
}

// The current key used to encrypt Video Analyzer account, including the key version.
func (o KeyVaultPropertiesResponsePtrOutput) CurrentKeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CurrentKeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
func (o KeyVaultPropertiesResponsePtrOutput) KeyIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyVaultPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return &v.KeyIdentifier
	}).(pulumi.StringPtrOutput)
}

// Network access control for video analyzer account.
type NetworkAccessControl struct {
	// Public network access for consumption group.
	Consumption *GroupLevelAccessControl `pulumi:"consumption"`
	// Public network access for ingestion group.
	Ingestion *GroupLevelAccessControl `pulumi:"ingestion"`
	// Public network access for integration group.
	Integration *GroupLevelAccessControl `pulumi:"integration"`
}

// NetworkAccessControlInput is an input type that accepts NetworkAccessControlArgs and NetworkAccessControlOutput values.
// You can construct a concrete instance of `NetworkAccessControlInput` via:
//
//	NetworkAccessControlArgs{...}
type NetworkAccessControlInput interface {
	pulumi.Input

	ToNetworkAccessControlOutput() NetworkAccessControlOutput
	ToNetworkAccessControlOutputWithContext(context.Context) NetworkAccessControlOutput
}

// Network access control for video analyzer account.
type NetworkAccessControlArgs struct {
	// Public network access for consumption group.
	Consumption GroupLevelAccessControlPtrInput `pulumi:"consumption"`
	// Public network access for ingestion group.
	Ingestion GroupLevelAccessControlPtrInput `pulumi:"ingestion"`
	// Public network access for integration group.
	Integration GroupLevelAccessControlPtrInput `pulumi:"integration"`
}

func (NetworkAccessControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkAccessControl)(nil)).Elem()
}

func (i NetworkAccessControlArgs) ToNetworkAccessControlOutput() NetworkAccessControlOutput {
	return i.ToNetworkAccessControlOutputWithContext(context.Background())
}

func (i NetworkAccessControlArgs) ToNetworkAccessControlOutputWithContext(ctx context.Context) NetworkAccessControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkAccessControlOutput)
}

func (i NetworkAccessControlArgs) ToNetworkAccessControlPtrOutput() NetworkAccessControlPtrOutput {
	return i.ToNetworkAccessControlPtrOutputWithContext(context.Background())
}

func (i NetworkAccessControlArgs) ToNetworkAccessControlPtrOutputWithContext(ctx context.Context) NetworkAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkAccessControlOutput).ToNetworkAccessControlPtrOutputWithContext(ctx)
}

// NetworkAccessControlPtrInput is an input type that accepts NetworkAccessControlArgs, NetworkAccessControlPtr and NetworkAccessControlPtrOutput values.
// You can construct a concrete instance of `NetworkAccessControlPtrInput` via:
//
//	        NetworkAccessControlArgs{...}
//
//	or:
//
//	        nil
type NetworkAccessControlPtrInput interface {
	pulumi.Input

	ToNetworkAccessControlPtrOutput() NetworkAccessControlPtrOutput
	ToNetworkAccessControlPtrOutputWithContext(context.Context) NetworkAccessControlPtrOutput
}

type networkAccessControlPtrType NetworkAccessControlArgs

func NetworkAccessControlPtr(v *NetworkAccessControlArgs) NetworkAccessControlPtrInput {
	return (*networkAccessControlPtrType)(v)
}

func (*networkAccessControlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkAccessControl)(nil)).Elem()
}

func (i *networkAccessControlPtrType) ToNetworkAccessControlPtrOutput() NetworkAccessControlPtrOutput {
	return i.ToNetworkAccessControlPtrOutputWithContext(context.Background())
}

func (i *networkAccessControlPtrType) ToNetworkAccessControlPtrOutputWithContext(ctx context.Context) NetworkAccessControlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkAccessControlPtrOutput)
}

// Network access control for video analyzer account.
type NetworkAccessControlOutput struct{ *pulumi.OutputState }

func (NetworkAccessControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkAccessControl)(nil)).Elem()
}

func (o NetworkAccessControlOutput) ToNetworkAccessControlOutput() NetworkAccessControlOutput {
	return o
}

func (o NetworkAccessControlOutput) ToNetworkAccessControlOutputWithContext(ctx context.Context) NetworkAccessControlOutput {
	return o
}

func (o NetworkAccessControlOutput) ToNetworkAccessControlPtrOutput() NetworkAccessControlPtrOutput {
	return o.ToNetworkAccessControlPtrOutputWithContext(context.Background())
}

func (o NetworkAccessControlOutput) ToNetworkAccessControlPtrOutputWithContext(ctx context.Context) NetworkAccessControlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NetworkAccessControl) *NetworkAccessControl {
		return &v
	}).(NetworkAccessControlPtrOutput)
}

// Public network access for consumption group.
func (o NetworkAccessControlOutput) Consumption() GroupLevelAccessControlPtrOutput {
	return o.ApplyT(func(v NetworkAccessControl) *GroupLevelAccessControl { return v.Consumption }).(GroupLevelAccessControlPtrOutput)
}

// Public network access for ingestion group.
func (o NetworkAccessControlOutput) Ingestion() GroupLevelAccessControlPtrOutput {
	return o.ApplyT(func(v NetworkAccessControl) *GroupLevelAccessControl { return v.Ingestion }).(GroupLevelAccessControlPtrOutput)
}

// Public network access for integration group.
func (o NetworkAccessControlOutput) Integration() GroupLevelAccessControlPtrOutput {
	return o.ApplyT(func(v NetworkAccessControl) *GroupLevelAccessControl { return v.Integration }).(GroupLevelAccessControlPtrOutput)
}

type NetworkAccessControlPtrOutput struct{ *pulumi.OutputState }

func (NetworkAccessControlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkAccessControl)(nil)).Elem()
}

func (o NetworkAccessControlPtrOutput) ToNetworkAccessControlPtrOutput() NetworkAccessControlPtrOutput {
	return o
}

func (o NetworkAccessControlPtrOutput) ToNetworkAccessControlPtrOutputWithContext(ctx context.Context) NetworkAccessControlPtrOutput {
	return o
}

func (o NetworkAccessControlPtrOutput) Elem() NetworkAccessControlOutput {
	return o.ApplyT(func(v *NetworkAccessControl) NetworkAccessControl {
		if v != nil {
			return *v
		}
		var ret NetworkAccessControl
		return ret
	}).(NetworkAccessControlOutput)
}

// Public network access for consumption group.
func (o NetworkAccessControlPtrOutput) Consumption() GroupLevelAccessControlPtrOutput {
	return o.ApplyT(func(v *NetworkAccessControl) *GroupLevelAccessControl {
		if v == nil {
			return nil
		}
		return v.Consumption
	}).(GroupLevelAccessControlPtrOutput)
}

// Public network access for ingestion group.
func (o NetworkAccessControlPtrOutput) Ingestion() GroupLevelAccessControlPtrOutput {
	return o.ApplyT(func(v *NetworkAccessControl) *GroupLevelAccessControl {
		if v == nil {
			return nil
		}
		return v.Ingestion
	}).(GroupLevelAccessControlPtrOutput)
}

// Public network access for integration group.
func (o NetworkAccessControlPtrOutput) Integration() GroupLevelAccessControlPtrOutput {
	return o.ApplyT(func(v *NetworkAccessControl) *GroupLevelAccessControl {
		if v == nil {
			return nil
		}
		return v.Integration
	}).(GroupLevelAccessControlPtrOutput)
}

// Network access control for video analyzer account.
type NetworkAccessControlResponse struct {
	// Public network access for consumption group.
	Consumption *GroupLevelAccessControlResponse `pulumi:"consumption"`
	// Public network access for ingestion group.
	Ingestion *GroupLevelAccessControlResponse `pulumi:"ingestion"`
	// Public network access for integration group.
	Integration *GroupLevelAccessControlResponse `pulumi:"integration"`
}

// Network access control for video analyzer account.
type NetworkAccessControlResponseOutput struct{ *pulumi.OutputState }

func (NetworkAccessControlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkAccessControlResponse)(nil)).Elem()
}

func (o NetworkAccessControlResponseOutput) ToNetworkAccessControlResponseOutput() NetworkAccessControlResponseOutput {
	return o
}

func (o NetworkAccessControlResponseOutput) ToNetworkAccessControlResponseOutputWithContext(ctx context.Context) NetworkAccessControlResponseOutput {
	return o
}

// Public network access for consumption group.
func (o NetworkAccessControlResponseOutput) Consumption() GroupLevelAccessControlResponsePtrOutput {
	return o.ApplyT(func(v NetworkAccessControlResponse) *GroupLevelAccessControlResponse { return v.Consumption }).(GroupLevelAccessControlResponsePtrOutput)
}

// Public network access for ingestion group.
func (o NetworkAccessControlResponseOutput) Ingestion() GroupLevelAccessControlResponsePtrOutput {
	return o.ApplyT(func(v NetworkAccessControlResponse) *GroupLevelAccessControlResponse { return v.Ingestion }).(GroupLevelAccessControlResponsePtrOutput)
}

// Public network access for integration group.
func (o NetworkAccessControlResponseOutput) Integration() GroupLevelAccessControlResponsePtrOutput {
	return o.ApplyT(func(v NetworkAccessControlResponse) *GroupLevelAccessControlResponse { return v.Integration }).(GroupLevelAccessControlResponsePtrOutput)
}

type NetworkAccessControlResponsePtrOutput struct{ *pulumi.OutputState }

func (NetworkAccessControlResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkAccessControlResponse)(nil)).Elem()
}

func (o NetworkAccessControlResponsePtrOutput) ToNetworkAccessControlResponsePtrOutput() NetworkAccessControlResponsePtrOutput {
	return o
}

func (o NetworkAccessControlResponsePtrOutput) ToNetworkAccessControlResponsePtrOutputWithContext(ctx context.Context) NetworkAccessControlResponsePtrOutput {
	return o
}

func (o NetworkAccessControlResponsePtrOutput) Elem() NetworkAccessControlResponseOutput {
	return o.ApplyT(func(v *NetworkAccessControlResponse) NetworkAccessControlResponse {
		if v != nil {
			return *v
		}
		var ret NetworkAccessControlResponse
		return ret
	}).(NetworkAccessControlResponseOutput)
}

// Public network access for consumption group.
func (o NetworkAccessControlResponsePtrOutput) Consumption() GroupLevelAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *NetworkAccessControlResponse) *GroupLevelAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Consumption
	}).(GroupLevelAccessControlResponsePtrOutput)
}

// Public network access for ingestion group.
func (o NetworkAccessControlResponsePtrOutput) Ingestion() GroupLevelAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *NetworkAccessControlResponse) *GroupLevelAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Ingestion
	}).(GroupLevelAccessControlResponsePtrOutput)
}

// Public network access for integration group.
func (o NetworkAccessControlResponsePtrOutput) Integration() GroupLevelAccessControlResponsePtrOutput {
	return o.ApplyT(func(v *NetworkAccessControlResponse) *GroupLevelAccessControlResponse {
		if v == nil {
			return nil
		}
		return v.Integration
	}).(GroupLevelAccessControlResponsePtrOutput)
}

// Describes an input signal to be used on a pipeline node.
type NodeInput struct {
	// The name of the upstream node in the pipeline which output is used as input of the current node.
	NodeName string `pulumi:"nodeName"`
}

// NodeInputInput is an input type that accepts NodeInputArgs and NodeInputOutput values.
// You can construct a concrete instance of `NodeInputInput` via:
//
//	NodeInputArgs{...}
type NodeInputInput interface {
	pulumi.Input

	ToNodeInputOutput() NodeInputOutput
	ToNodeInputOutputWithContext(context.Context) NodeInputOutput
}

// Describes an input signal to be used on a pipeline node.
type NodeInputArgs struct {
	// The name of the upstream node in the pipeline which output is used as input of the current node.
	NodeName pulumi.StringInput `pulumi:"nodeName"`
}

func (NodeInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeInput)(nil)).Elem()
}

func (i NodeInputArgs) ToNodeInputOutput() NodeInputOutput {
	return i.ToNodeInputOutputWithContext(context.Background())
}

func (i NodeInputArgs) ToNodeInputOutputWithContext(ctx context.Context) NodeInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeInputOutput)
}

// NodeInputArrayInput is an input type that accepts NodeInputArray and NodeInputArrayOutput values.
// You can construct a concrete instance of `NodeInputArrayInput` via:
//
//	NodeInputArray{ NodeInputArgs{...} }
type NodeInputArrayInput interface {
	pulumi.Input

	ToNodeInputArrayOutput() NodeInputArrayOutput
	ToNodeInputArrayOutputWithContext(context.Context) NodeInputArrayOutput
}

type NodeInputArray []NodeInputInput

func (NodeInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NodeInput)(nil)).Elem()
}

func (i NodeInputArray) ToNodeInputArrayOutput() NodeInputArrayOutput {
	return i.ToNodeInputArrayOutputWithContext(context.Background())
}

func (i NodeInputArray) ToNodeInputArrayOutputWithContext(ctx context.Context) NodeInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodeInputArrayOutput)
}

// Describes an input signal to be used on a pipeline node.
type NodeInputOutput struct{ *pulumi.OutputState }

func (NodeInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeInput)(nil)).Elem()
}

func (o NodeInputOutput) ToNodeInputOutput() NodeInputOutput {
	return o
}

func (o NodeInputOutput) ToNodeInputOutputWithContext(ctx context.Context) NodeInputOutput {
	return o
}

// The name of the upstream node in the pipeline which output is used as input of the current node.
func (o NodeInputOutput) NodeName() pulumi.StringOutput {
	return o.ApplyT(func(v NodeInput) string { return v.NodeName }).(pulumi.StringOutput)
}

type NodeInputArrayOutput struct{ *pulumi.OutputState }

func (NodeInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NodeInput)(nil)).Elem()
}

func (o NodeInputArrayOutput) ToNodeInputArrayOutput() NodeInputArrayOutput {
	return o
}

func (o NodeInputArrayOutput) ToNodeInputArrayOutputWithContext(ctx context.Context) NodeInputArrayOutput {
	return o
}

func (o NodeInputArrayOutput) Index(i pulumi.IntInput) NodeInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NodeInput {
		return vs[0].([]NodeInput)[vs[1].(int)]
	}).(NodeInputOutput)
}

// Describes an input signal to be used on a pipeline node.
type NodeInputResponse struct {
	// The name of the upstream node in the pipeline which output is used as input of the current node.
	NodeName string `pulumi:"nodeName"`
}

// Describes an input signal to be used on a pipeline node.
type NodeInputResponseOutput struct{ *pulumi.OutputState }

func (NodeInputResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NodeInputResponse)(nil)).Elem()
}

func (o NodeInputResponseOutput) ToNodeInputResponseOutput() NodeInputResponseOutput {
	return o
}

func (o NodeInputResponseOutput) ToNodeInputResponseOutputWithContext(ctx context.Context) NodeInputResponseOutput {
	return o
}

// The name of the upstream node in the pipeline which output is used as input of the current node.
func (o NodeInputResponseOutput) NodeName() pulumi.StringOutput {
	return o.ApplyT(func(v NodeInputResponse) string { return v.NodeName }).(pulumi.StringOutput)
}

type NodeInputResponseArrayOutput struct{ *pulumi.OutputState }

func (NodeInputResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NodeInputResponse)(nil)).Elem()
}

func (o NodeInputResponseArrayOutput) ToNodeInputResponseArrayOutput() NodeInputResponseArrayOutput {
	return o
}

func (o NodeInputResponseArrayOutput) ToNodeInputResponseArrayOutputWithContext(ctx context.Context) NodeInputResponseArrayOutput {
	return o
}

func (o NodeInputResponseArrayOutput) Index(i pulumi.IntInput) NodeInputResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NodeInputResponse {
		return vs[0].([]NodeInputResponse)[vs[1].(int)]
	}).(NodeInputResponseOutput)
}

// Single topology parameter declaration. Declared parameters can and must be referenced throughout the topology and can optionally have default values to be used when they are not defined in the pipelines.
type ParameterDeclaration struct {
	// The default value for the parameter to be used if the pipeline does not specify a value.
	Default *string `pulumi:"default"`
	// Description of the parameter.
	Description *string `pulumi:"description"`
	// Name of the parameter.
	Name string `pulumi:"name"`
	// Type of the parameter.
	Type string `pulumi:"type"`
}

// ParameterDeclarationInput is an input type that accepts ParameterDeclarationArgs and ParameterDeclarationOutput values.
// You can construct a concrete instance of `ParameterDeclarationInput` via:
//
//	ParameterDeclarationArgs{...}
type ParameterDeclarationInput interface {
	pulumi.Input

	ToParameterDeclarationOutput() ParameterDeclarationOutput
	ToParameterDeclarationOutputWithContext(context.Context) ParameterDeclarationOutput
}

// Single topology parameter declaration. Declared parameters can and must be referenced throughout the topology and can optionally have default values to be used when they are not defined in the pipelines.
type ParameterDeclarationArgs struct {
	// The default value for the parameter to be used if the pipeline does not specify a value.
	Default pulumi.StringPtrInput `pulumi:"default"`
	// Description of the parameter.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Name of the parameter.
	Name pulumi.StringInput `pulumi:"name"`
	// Type of the parameter.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ParameterDeclarationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ParameterDeclaration)(nil)).Elem()
}

func (i ParameterDeclarationArgs) ToParameterDeclarationOutput() ParameterDeclarationOutput {
	return i.ToParameterDeclarationOutputWithContext(context.Background())
}

func (i ParameterDeclarationArgs) ToParameterDeclarationOutputWithContext(ctx context.Context) ParameterDeclarationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParameterDeclarationOutput)
}

// ParameterDeclarationArrayInput is an input type that accepts ParameterDeclarationArray and ParameterDeclarationArrayOutput values.
// You can construct a concrete instance of `ParameterDeclarationArrayInput` via:
//
//	ParameterDeclarationArray{ ParameterDeclarationArgs{...} }
type ParameterDeclarationArrayInput interface {
	pulumi.Input

	ToParameterDeclarationArrayOutput() ParameterDeclarationArrayOutput
	ToParameterDeclarationArrayOutputWithContext(context.Context) ParameterDeclarationArrayOutput
}

type ParameterDeclarationArray []ParameterDeclarationInput

func (ParameterDeclarationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ParameterDeclaration)(nil)).Elem()
}

func (i ParameterDeclarationArray) ToParameterDeclarationArrayOutput() ParameterDeclarationArrayOutput {
	return i.ToParameterDeclarationArrayOutputWithContext(context.Background())
}

func (i ParameterDeclarationArray) ToParameterDeclarationArrayOutputWithContext(ctx context.Context) ParameterDeclarationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParameterDeclarationArrayOutput)
}

// Single topology parameter declaration. Declared parameters can and must be referenced throughout the topology and can optionally have default values to be used when they are not defined in the pipelines.
type ParameterDeclarationOutput struct{ *pulumi.OutputState }

func (ParameterDeclarationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParameterDeclaration)(nil)).Elem()
}

func (o ParameterDeclarationOutput) ToParameterDeclarationOutput() ParameterDeclarationOutput {
	return o
}

func (o ParameterDeclarationOutput) ToParameterDeclarationOutputWithContext(ctx context.Context) ParameterDeclarationOutput {
	return o
}

// The default value for the parameter to be used if the pipeline does not specify a value.
func (o ParameterDeclarationOutput) Default() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParameterDeclaration) *string { return v.Default }).(pulumi.StringPtrOutput)
}

// Description of the parameter.
func (o ParameterDeclarationOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParameterDeclaration) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Name of the parameter.
func (o ParameterDeclarationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ParameterDeclaration) string { return v.Name }).(pulumi.StringOutput)
}

// Type of the parameter.
func (o ParameterDeclarationOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ParameterDeclaration) string { return v.Type }).(pulumi.StringOutput)
}

type ParameterDeclarationArrayOutput struct{ *pulumi.OutputState }

func (ParameterDeclarationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ParameterDeclaration)(nil)).Elem()
}

func (o ParameterDeclarationArrayOutput) ToParameterDeclarationArrayOutput() ParameterDeclarationArrayOutput {
	return o
}

func (o ParameterDeclarationArrayOutput) ToParameterDeclarationArrayOutputWithContext(ctx context.Context) ParameterDeclarationArrayOutput {
	return o
}

func (o ParameterDeclarationArrayOutput) Index(i pulumi.IntInput) ParameterDeclarationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ParameterDeclaration {
		return vs[0].([]ParameterDeclaration)[vs[1].(int)]
	}).(ParameterDeclarationOutput)
}

// Single topology parameter declaration. Declared parameters can and must be referenced throughout the topology and can optionally have default values to be used when they are not defined in the pipelines.
type ParameterDeclarationResponse struct {
	// The default value for the parameter to be used if the pipeline does not specify a value.
	Default *string `pulumi:"default"`
	// Description of the parameter.
	Description *string `pulumi:"description"`
	// Name of the parameter.
	Name string `pulumi:"name"`
	// Type of the parameter.
	Type string `pulumi:"type"`
}

// Single topology parameter declaration. Declared parameters can and must be referenced throughout the topology and can optionally have default values to be used when they are not defined in the pipelines.
type ParameterDeclarationResponseOutput struct{ *pulumi.OutputState }

func (ParameterDeclarationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParameterDeclarationResponse)(nil)).Elem()
}

func (o ParameterDeclarationResponseOutput) ToParameterDeclarationResponseOutput() ParameterDeclarationResponseOutput {
	return o
}

func (o ParameterDeclarationResponseOutput) ToParameterDeclarationResponseOutputWithContext(ctx context.Context) ParameterDeclarationResponseOutput {
	return o
}

// The default value for the parameter to be used if the pipeline does not specify a value.
func (o ParameterDeclarationResponseOutput) Default() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParameterDeclarationResponse) *string { return v.Default }).(pulumi.StringPtrOutput)
}

// Description of the parameter.
func (o ParameterDeclarationResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParameterDeclarationResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Name of the parameter.
func (o ParameterDeclarationResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ParameterDeclarationResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Type of the parameter.
func (o ParameterDeclarationResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ParameterDeclarationResponse) string { return v.Type }).(pulumi.StringOutput)
}

type ParameterDeclarationResponseArrayOutput struct{ *pulumi.OutputState }

func (ParameterDeclarationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ParameterDeclarationResponse)(nil)).Elem()
}

func (o ParameterDeclarationResponseArrayOutput) ToParameterDeclarationResponseArrayOutput() ParameterDeclarationResponseArrayOutput {
	return o
}

func (o ParameterDeclarationResponseArrayOutput) ToParameterDeclarationResponseArrayOutputWithContext(ctx context.Context) ParameterDeclarationResponseArrayOutput {
	return o
}

func (o ParameterDeclarationResponseArrayOutput) Index(i pulumi.IntInput) ParameterDeclarationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ParameterDeclarationResponse {
		return vs[0].([]ParameterDeclarationResponse)[vs[1].(int)]
	}).(ParameterDeclarationResponseOutput)
}

// Defines the parameter value of an specific pipeline topology parameter. See pipeline topology parameters for more information.
type ParameterDefinition struct {
	// Name of the parameter declared in the pipeline topology.
	Name string `pulumi:"name"`
	// Parameter value to be applied on this specific pipeline.
	Value *string `pulumi:"value"`
}

// ParameterDefinitionInput is an input type that accepts ParameterDefinitionArgs and ParameterDefinitionOutput values.
// You can construct a concrete instance of `ParameterDefinitionInput` via:
//
//	ParameterDefinitionArgs{...}
type ParameterDefinitionInput interface {
	pulumi.Input

	ToParameterDefinitionOutput() ParameterDefinitionOutput
	ToParameterDefinitionOutputWithContext(context.Context) ParameterDefinitionOutput
}

// Defines the parameter value of an specific pipeline topology parameter. See pipeline topology parameters for more information.
type ParameterDefinitionArgs struct {
	// Name of the parameter declared in the pipeline topology.
	Name pulumi.StringInput `pulumi:"name"`
	// Parameter value to be applied on this specific pipeline.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ParameterDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ParameterDefinition)(nil)).Elem()
}

func (i ParameterDefinitionArgs) ToParameterDefinitionOutput() ParameterDefinitionOutput {
	return i.ToParameterDefinitionOutputWithContext(context.Background())
}

func (i ParameterDefinitionArgs) ToParameterDefinitionOutputWithContext(ctx context.Context) ParameterDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParameterDefinitionOutput)
}

// ParameterDefinitionArrayInput is an input type that accepts ParameterDefinitionArray and ParameterDefinitionArrayOutput values.
// You can construct a concrete instance of `ParameterDefinitionArrayInput` via:
//
//	ParameterDefinitionArray{ ParameterDefinitionArgs{...} }
type ParameterDefinitionArrayInput interface {
	pulumi.Input

	ToParameterDefinitionArrayOutput() ParameterDefinitionArrayOutput
	ToParameterDefinitionArrayOutputWithContext(context.Context) ParameterDefinitionArrayOutput
}

type ParameterDefinitionArray []ParameterDefinitionInput

func (ParameterDefinitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ParameterDefinition)(nil)).Elem()
}

func (i ParameterDefinitionArray) ToParameterDefinitionArrayOutput() ParameterDefinitionArrayOutput {
	return i.ToParameterDefinitionArrayOutputWithContext(context.Background())
}

func (i ParameterDefinitionArray) ToParameterDefinitionArrayOutputWithContext(ctx context.Context) ParameterDefinitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParameterDefinitionArrayOutput)
}

// Defines the parameter value of an specific pipeline topology parameter. See pipeline topology parameters for more information.
type ParameterDefinitionOutput struct{ *pulumi.OutputState }

func (ParameterDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParameterDefinition)(nil)).Elem()
}

func (o ParameterDefinitionOutput) ToParameterDefinitionOutput() ParameterDefinitionOutput {
	return o
}

func (o ParameterDefinitionOutput) ToParameterDefinitionOutputWithContext(ctx context.Context) ParameterDefinitionOutput {
	return o
}

// Name of the parameter declared in the pipeline topology.
func (o ParameterDefinitionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ParameterDefinition) string { return v.Name }).(pulumi.StringOutput)
}

// Parameter value to be applied on this specific pipeline.
func (o ParameterDefinitionOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParameterDefinition) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type ParameterDefinitionArrayOutput struct{ *pulumi.OutputState }

func (ParameterDefinitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ParameterDefinition)(nil)).Elem()
}

func (o ParameterDefinitionArrayOutput) ToParameterDefinitionArrayOutput() ParameterDefinitionArrayOutput {
	return o
}

func (o ParameterDefinitionArrayOutput) ToParameterDefinitionArrayOutputWithContext(ctx context.Context) ParameterDefinitionArrayOutput {
	return o
}

func (o ParameterDefinitionArrayOutput) Index(i pulumi.IntInput) ParameterDefinitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ParameterDefinition {
		return vs[0].([]ParameterDefinition)[vs[1].(int)]
	}).(ParameterDefinitionOutput)
}

// Defines the parameter value of an specific pipeline topology parameter. See pipeline topology parameters for more information.
type ParameterDefinitionResponse struct {
	// Name of the parameter declared in the pipeline topology.
	Name string `pulumi:"name"`
	// Parameter value to be applied on this specific pipeline.
	Value *string `pulumi:"value"`
}

// Defines the parameter value of an specific pipeline topology parameter. See pipeline topology parameters for more information.
type ParameterDefinitionResponseOutput struct{ *pulumi.OutputState }

func (ParameterDefinitionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParameterDefinitionResponse)(nil)).Elem()
}

func (o ParameterDefinitionResponseOutput) ToParameterDefinitionResponseOutput() ParameterDefinitionResponseOutput {
	return o
}

func (o ParameterDefinitionResponseOutput) ToParameterDefinitionResponseOutputWithContext(ctx context.Context) ParameterDefinitionResponseOutput {
	return o
}

// Name of the parameter declared in the pipeline topology.
func (o ParameterDefinitionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ParameterDefinitionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Parameter value to be applied on this specific pipeline.
func (o ParameterDefinitionResponseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParameterDefinitionResponse) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type ParameterDefinitionResponseArrayOutput struct{ *pulumi.OutputState }

func (ParameterDefinitionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ParameterDefinitionResponse)(nil)).Elem()
}

func (o ParameterDefinitionResponseArrayOutput) ToParameterDefinitionResponseArrayOutput() ParameterDefinitionResponseArrayOutput {
	return o
}

func (o ParameterDefinitionResponseArrayOutput) ToParameterDefinitionResponseArrayOutputWithContext(ctx context.Context) ParameterDefinitionResponseArrayOutput {
	return o
}

func (o ParameterDefinitionResponseArrayOutput) Index(i pulumi.IntInput) ParameterDefinitionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ParameterDefinitionResponse {
		return vs[0].([]ParameterDefinitionResponse)[vs[1].(int)]
	}).(ParameterDefinitionResponseOutput)
}

// A list of PEM formatted certificates.
type PemCertificateList struct {
	// PEM formatted public certificates. One certificate per entry.
	Certificates []string `pulumi:"certificates"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.PemCertificateList'.
	Type string `pulumi:"type"`
}

// A list of PEM formatted certificates.
type PemCertificateListResponse struct {
	// PEM formatted public certificates. One certificate per entry.
	Certificates []string `pulumi:"certificates"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.PemCertificateList'.
	Type string `pulumi:"type"`
}

// Details about the error for a failed pipeline job.
type PipelineJobErrorResponse struct {
	// The error code.
	Code *string `pulumi:"code"`
	// The error message.
	Message *string `pulumi:"message"`
}

// Details about the error for a failed pipeline job.
type PipelineJobErrorResponseOutput struct{ *pulumi.OutputState }

func (PipelineJobErrorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PipelineJobErrorResponse)(nil)).Elem()
}

func (o PipelineJobErrorResponseOutput) ToPipelineJobErrorResponseOutput() PipelineJobErrorResponseOutput {
	return o
}

func (o PipelineJobErrorResponseOutput) ToPipelineJobErrorResponseOutputWithContext(ctx context.Context) PipelineJobErrorResponseOutput {
	return o
}

// The error code.
func (o PipelineJobErrorResponseOutput) Code() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PipelineJobErrorResponse) *string { return v.Code }).(pulumi.StringPtrOutput)
}

// The error message.
func (o PipelineJobErrorResponseOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PipelineJobErrorResponse) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnectionResponse struct {
	// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id string `pulumi:"id"`
	// The name of the resource
	Name string `pulumi:"name"`
	// The resource of private end point.
	PrivateEndpoint *PrivateEndpointResponse `pulumi:"privateEndpoint"`
	// A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState PrivateLinkServiceConnectionStateResponse `pulumi:"privateLinkServiceConnectionState"`
	// The provisioning state of the private endpoint connection resource.
	ProvisioningState string `pulumi:"provisioningState"`
	// Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData SystemDataResponse `pulumi:"systemData"`
	// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type string `pulumi:"type"`
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnectionResponseOutput struct{ *pulumi.OutputState }

func (PrivateEndpointConnectionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o PrivateEndpointConnectionResponseOutput) ToPrivateEndpointConnectionResponseOutput() PrivateEndpointConnectionResponseOutput {
	return o
}

func (o PrivateEndpointConnectionResponseOutput) ToPrivateEndpointConnectionResponseOutputWithContext(ctx context.Context) PrivateEndpointConnectionResponseOutput {
	return o
}

// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
func (o PrivateEndpointConnectionResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Id }).(pulumi.StringOutput)
}

// The name of the resource
func (o PrivateEndpointConnectionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The resource of private end point.
func (o PrivateEndpointConnectionResponseOutput) PrivateEndpoint() PrivateEndpointResponsePtrOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) *PrivateEndpointResponse { return v.PrivateEndpoint }).(PrivateEndpointResponsePtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
func (o PrivateEndpointConnectionResponseOutput) PrivateLinkServiceConnectionState() PrivateLinkServiceConnectionStateResponseOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) PrivateLinkServiceConnectionStateResponse {
		return v.PrivateLinkServiceConnectionState
	}).(PrivateLinkServiceConnectionStateResponseOutput)
}

// The provisioning state of the private endpoint connection resource.
func (o PrivateEndpointConnectionResponseOutput) ProvisioningState() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.ProvisioningState }).(pulumi.StringOutput)
}

// Azure Resource Manager metadata containing createdBy and modifiedBy information.
func (o PrivateEndpointConnectionResponseOutput) SystemData() SystemDataResponseOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) SystemDataResponse { return v.SystemData }).(SystemDataResponseOutput)
}

// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
func (o PrivateEndpointConnectionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointConnectionResponse) string { return v.Type }).(pulumi.StringOutput)
}

type PrivateEndpointConnectionResponseArrayOutput struct{ *pulumi.OutputState }

func (PrivateEndpointConnectionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PrivateEndpointConnectionResponse)(nil)).Elem()
}

func (o PrivateEndpointConnectionResponseArrayOutput) ToPrivateEndpointConnectionResponseArrayOutput() PrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o PrivateEndpointConnectionResponseArrayOutput) ToPrivateEndpointConnectionResponseArrayOutputWithContext(ctx context.Context) PrivateEndpointConnectionResponseArrayOutput {
	return o
}

func (o PrivateEndpointConnectionResponseArrayOutput) Index(i pulumi.IntInput) PrivateEndpointConnectionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PrivateEndpointConnectionResponse {
		return vs[0].([]PrivateEndpointConnectionResponse)[vs[1].(int)]
	}).(PrivateEndpointConnectionResponseOutput)
}

// The Private Endpoint resource.
type PrivateEndpointResponse struct {
	// The ARM identifier for Private Endpoint
	Id string `pulumi:"id"`
}

// The Private Endpoint resource.
type PrivateEndpointResponseOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateEndpointResponse)(nil)).Elem()
}

func (o PrivateEndpointResponseOutput) ToPrivateEndpointResponseOutput() PrivateEndpointResponseOutput {
	return o
}

func (o PrivateEndpointResponseOutput) ToPrivateEndpointResponseOutputWithContext(ctx context.Context) PrivateEndpointResponseOutput {
	return o
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PrivateEndpointResponse) string { return v.Id }).(pulumi.StringOutput)
}

type PrivateEndpointResponsePtrOutput struct{ *pulumi.OutputState }

func (PrivateEndpointResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateEndpointResponse)(nil)).Elem()
}

func (o PrivateEndpointResponsePtrOutput) ToPrivateEndpointResponsePtrOutput() PrivateEndpointResponsePtrOutput {
	return o
}

func (o PrivateEndpointResponsePtrOutput) ToPrivateEndpointResponsePtrOutputWithContext(ctx context.Context) PrivateEndpointResponsePtrOutput {
	return o
}

func (o PrivateEndpointResponsePtrOutput) Elem() PrivateEndpointResponseOutput {
	return o.ApplyT(func(v *PrivateEndpointResponse) PrivateEndpointResponse {
		if v != nil {
			return *v
		}
		var ret PrivateEndpointResponse
		return ret
	}).(PrivateEndpointResponseOutput)
}

// The ARM identifier for Private Endpoint
func (o PrivateEndpointResponsePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateEndpointResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Id
	}).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description *string `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

// PrivateLinkServiceConnectionStateInput is an input type that accepts PrivateLinkServiceConnectionStateArgs and PrivateLinkServiceConnectionStateOutput values.
// You can construct a concrete instance of `PrivateLinkServiceConnectionStateInput` via:
//
//	PrivateLinkServiceConnectionStateArgs{...}
type PrivateLinkServiceConnectionStateInput interface {
	pulumi.Input

	ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput
	ToPrivateLinkServiceConnectionStateOutputWithContext(context.Context) PrivateLinkServiceConnectionStateOutput
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateArgs struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired pulumi.StringPtrInput `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (PrivateLinkServiceConnectionStateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return i.ToPrivateLinkServiceConnectionStateOutputWithContext(context.Background())
}

func (i PrivateLinkServiceConnectionStateArgs) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateLinkServiceConnectionStateOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionState)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutput() PrivateLinkServiceConnectionStateOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateOutput) ToPrivateLinkServiceConnectionStateOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateOutput {
	return o
}

// A message indicating if changes on the service provider require any updates on the consumer.
func (o PrivateLinkServiceConnectionStateOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// The reason for approval/rejection of the connection.
func (o PrivateLinkServiceConnectionStateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o PrivateLinkServiceConnectionStateOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionState) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponse struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `pulumi:"actionsRequired"`
	// The reason for approval/rejection of the connection.
	Description *string `pulumi:"description"`
	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `pulumi:"status"`
}

// A collection of information about the state of the connection between service consumer and provider.
type PrivateLinkServiceConnectionStateResponseOutput struct{ *pulumi.OutputState }

func (PrivateLinkServiceConnectionStateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrivateLinkServiceConnectionStateResponse)(nil)).Elem()
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutput() PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

func (o PrivateLinkServiceConnectionStateResponseOutput) ToPrivateLinkServiceConnectionStateResponseOutputWithContext(ctx context.Context) PrivateLinkServiceConnectionStateResponseOutput {
	return o
}

// A message indicating if changes on the service provider require any updates on the consumer.
func (o PrivateLinkServiceConnectionStateResponseOutput) ActionsRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.ActionsRequired }).(pulumi.StringPtrOutput)
}

// The reason for approval/rejection of the connection.
func (o PrivateLinkServiceConnectionStateResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
func (o PrivateLinkServiceConnectionStateResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrivateLinkServiceConnectionStateResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// The user assigned managed identity to use when accessing a resource.
type ResourceIdentity struct {
	// The user assigned managed identity's resource identifier to use when accessing a resource.
	UserAssignedIdentity string `pulumi:"userAssignedIdentity"`
}

// ResourceIdentityInput is an input type that accepts ResourceIdentityArgs and ResourceIdentityOutput values.
// You can construct a concrete instance of `ResourceIdentityInput` via:
//
//	ResourceIdentityArgs{...}
type ResourceIdentityInput interface {
	pulumi.Input

	ToResourceIdentityOutput() ResourceIdentityOutput
	ToResourceIdentityOutputWithContext(context.Context) ResourceIdentityOutput
}

// The user assigned managed identity to use when accessing a resource.
type ResourceIdentityArgs struct {
	// The user assigned managed identity's resource identifier to use when accessing a resource.
	UserAssignedIdentity pulumi.StringInput `pulumi:"userAssignedIdentity"`
}

func (ResourceIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceIdentity)(nil)).Elem()
}

func (i ResourceIdentityArgs) ToResourceIdentityOutput() ResourceIdentityOutput {
	return i.ToResourceIdentityOutputWithContext(context.Background())
}

func (i ResourceIdentityArgs) ToResourceIdentityOutputWithContext(ctx context.Context) ResourceIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceIdentityOutput)
}

func (i ResourceIdentityArgs) ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput {
	return i.ToResourceIdentityPtrOutputWithContext(context.Background())
}

func (i ResourceIdentityArgs) ToResourceIdentityPtrOutputWithContext(ctx context.Context) ResourceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceIdentityOutput).ToResourceIdentityPtrOutputWithContext(ctx)
}

// ResourceIdentityPtrInput is an input type that accepts ResourceIdentityArgs, ResourceIdentityPtr and ResourceIdentityPtrOutput values.
// You can construct a concrete instance of `ResourceIdentityPtrInput` via:
//
//	        ResourceIdentityArgs{...}
//
//	or:
//
//	        nil
type ResourceIdentityPtrInput interface {
	pulumi.Input

	ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput
	ToResourceIdentityPtrOutputWithContext(context.Context) ResourceIdentityPtrOutput
}

type resourceIdentityPtrType ResourceIdentityArgs

func ResourceIdentityPtr(v *ResourceIdentityArgs) ResourceIdentityPtrInput {
	return (*resourceIdentityPtrType)(v)
}

func (*resourceIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceIdentity)(nil)).Elem()
}

func (i *resourceIdentityPtrType) ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput {
	return i.ToResourceIdentityPtrOutputWithContext(context.Background())
}

func (i *resourceIdentityPtrType) ToResourceIdentityPtrOutputWithContext(ctx context.Context) ResourceIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceIdentityPtrOutput)
}

// The user assigned managed identity to use when accessing a resource.
type ResourceIdentityOutput struct{ *pulumi.OutputState }

func (ResourceIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceIdentity)(nil)).Elem()
}

func (o ResourceIdentityOutput) ToResourceIdentityOutput() ResourceIdentityOutput {
	return o
}

func (o ResourceIdentityOutput) ToResourceIdentityOutputWithContext(ctx context.Context) ResourceIdentityOutput {
	return o
}

func (o ResourceIdentityOutput) ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput {
	return o.ToResourceIdentityPtrOutputWithContext(context.Background())
}

func (o ResourceIdentityOutput) ToResourceIdentityPtrOutputWithContext(ctx context.Context) ResourceIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceIdentity) *ResourceIdentity {
		return &v
	}).(ResourceIdentityPtrOutput)
}

// The user assigned managed identity's resource identifier to use when accessing a resource.
func (o ResourceIdentityOutput) UserAssignedIdentity() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceIdentity) string { return v.UserAssignedIdentity }).(pulumi.StringOutput)
}

type ResourceIdentityPtrOutput struct{ *pulumi.OutputState }

func (ResourceIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceIdentity)(nil)).Elem()
}

func (o ResourceIdentityPtrOutput) ToResourceIdentityPtrOutput() ResourceIdentityPtrOutput {
	return o
}

func (o ResourceIdentityPtrOutput) ToResourceIdentityPtrOutputWithContext(ctx context.Context) ResourceIdentityPtrOutput {
	return o
}

func (o ResourceIdentityPtrOutput) Elem() ResourceIdentityOutput {
	return o.ApplyT(func(v *ResourceIdentity) ResourceIdentity {
		if v != nil {
			return *v
		}
		var ret ResourceIdentity
		return ret
	}).(ResourceIdentityOutput)
}

// The user assigned managed identity's resource identifier to use when accessing a resource.
func (o ResourceIdentityPtrOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceIdentity) *string {
		if v == nil {
			return nil
		}
		return &v.UserAssignedIdentity
	}).(pulumi.StringPtrOutput)
}

// The user assigned managed identity to use when accessing a resource.
type ResourceIdentityResponse struct {
	// The user assigned managed identity's resource identifier to use when accessing a resource.
	UserAssignedIdentity string `pulumi:"userAssignedIdentity"`
}

// The user assigned managed identity to use when accessing a resource.
type ResourceIdentityResponseOutput struct{ *pulumi.OutputState }

func (ResourceIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceIdentityResponse)(nil)).Elem()
}

func (o ResourceIdentityResponseOutput) ToResourceIdentityResponseOutput() ResourceIdentityResponseOutput {
	return o
}

func (o ResourceIdentityResponseOutput) ToResourceIdentityResponseOutputWithContext(ctx context.Context) ResourceIdentityResponseOutput {
	return o
}

// The user assigned managed identity's resource identifier to use when accessing a resource.
func (o ResourceIdentityResponseOutput) UserAssignedIdentity() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceIdentityResponse) string { return v.UserAssignedIdentity }).(pulumi.StringOutput)
}

type ResourceIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (ResourceIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceIdentityResponse)(nil)).Elem()
}

func (o ResourceIdentityResponsePtrOutput) ToResourceIdentityResponsePtrOutput() ResourceIdentityResponsePtrOutput {
	return o
}

func (o ResourceIdentityResponsePtrOutput) ToResourceIdentityResponsePtrOutputWithContext(ctx context.Context) ResourceIdentityResponsePtrOutput {
	return o
}

func (o ResourceIdentityResponsePtrOutput) Elem() ResourceIdentityResponseOutput {
	return o.ApplyT(func(v *ResourceIdentityResponse) ResourceIdentityResponse {
		if v != nil {
			return *v
		}
		var ret ResourceIdentityResponse
		return ret
	}).(ResourceIdentityResponseOutput)
}

// The user assigned managed identity's resource identifier to use when accessing a resource.
func (o ResourceIdentityResponsePtrOutput) UserAssignedIdentity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UserAssignedIdentity
	}).(pulumi.StringPtrOutput)
}

// Required validation properties for tokens generated with RSA algorithm.
type RsaTokenKey struct {
	// RSA algorithm to be used: RS256, RS384 or RS512.
	Alg string `pulumi:"alg"`
	// RSA public key exponent.
	E string `pulumi:"e"`
	// JWT token key id. Validation keys are looked up based on the key id present on the JWT token header.
	Kid string `pulumi:"kid"`
	// RSA public key modulus.
	N string `pulumi:"n"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.RsaTokenKey'.
	Type string `pulumi:"type"`
}

// Required validation properties for tokens generated with RSA algorithm.
type RsaTokenKeyResponse struct {
	// RSA algorithm to be used: RS256, RS384 or RS512.
	Alg string `pulumi:"alg"`
	// RSA public key exponent.
	E string `pulumi:"e"`
	// JWT token key id. Validation keys are looked up based on the key id present on the JWT token header.
	Kid string `pulumi:"kid"`
	// RSA public key modulus.
	N string `pulumi:"n"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.RsaTokenKey'.
	Type string `pulumi:"type"`
}

// RTSP source allows for media from an RTSP camera or generic RTSP server to be ingested into a pipeline.
type RtspSource struct {
	// RTSP endpoint information for Video Analyzer to connect to. This contains the required information for Video Analyzer to connect to RTSP cameras and/or generic RTSP servers.
	Endpoint interface{} `pulumi:"endpoint"`
	// Node name. Must be unique within the topology.
	Name string `pulumi:"name"`
	// Network transport utilized by the RTSP and RTP exchange: TCP or HTTP. When using TCP, the RTP packets are interleaved on the TCP RTSP connection. When using HTTP, the RTSP messages are exchanged through long lived HTTP connections, and the RTP packages are interleaved in the HTTP connections alongside the RTSP messages.
	Transport *string `pulumi:"transport"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.RtspSource'.
	Type string `pulumi:"type"`
}

// RTSP source allows for media from an RTSP camera or generic RTSP server to be ingested into a pipeline.
type RtspSourceResponse struct {
	// RTSP endpoint information for Video Analyzer to connect to. This contains the required information for Video Analyzer to connect to RTSP cameras and/or generic RTSP servers.
	Endpoint interface{} `pulumi:"endpoint"`
	// Node name. Must be unique within the topology.
	Name string `pulumi:"name"`
	// Network transport utilized by the RTSP and RTP exchange: TCP or HTTP. When using TCP, the RTP packets are interleaved on the TCP RTSP connection. When using HTTP, the RTSP messages are exchanged through long lived HTTP connections, and the RTP packages are interleaved in the HTTP connections alongside the RTSP messages.
	Transport *string `pulumi:"transport"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.RtspSource'.
	Type string `pulumi:"type"`
}

// A remote tunnel securely established using IoT Hub device information.
type SecureIotDeviceRemoteTunnel struct {
	// The IoT device id to use when establishing the remote tunnel. This string is case-sensitive.
	DeviceId string `pulumi:"deviceId"`
	// Name of the IoT Hub.
	IotHubName string `pulumi:"iotHubName"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.SecureIotDeviceRemoteTunnel'.
	Type string `pulumi:"type"`
}

// A remote tunnel securely established using IoT Hub device information.
type SecureIotDeviceRemoteTunnelResponse struct {
	// The IoT device id to use when establishing the remote tunnel. This string is case-sensitive.
	DeviceId string `pulumi:"deviceId"`
	// Name of the IoT Hub.
	IotHubName string `pulumi:"iotHubName"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.SecureIotDeviceRemoteTunnel'.
	Type string `pulumi:"type"`
}

// The SKU details.
type Sku struct {
	// The SKU name.
	Name string `pulumi:"name"`
}

// SkuInput is an input type that accepts SkuArgs and SkuOutput values.
// You can construct a concrete instance of `SkuInput` via:
//
//	SkuArgs{...}
type SkuInput interface {
	pulumi.Input

	ToSkuOutput() SkuOutput
	ToSkuOutputWithContext(context.Context) SkuOutput
}

// The SKU details.
type SkuArgs struct {
	// The SKU name.
	Name pulumi.StringInput `pulumi:"name"`
}

func (SkuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (i SkuArgs) ToSkuOutput() SkuOutput {
	return i.ToSkuOutputWithContext(context.Background())
}

func (i SkuArgs) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkuOutput)
}

// The SKU details.
type SkuOutput struct{ *pulumi.OutputState }

func (SkuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Sku)(nil)).Elem()
}

func (o SkuOutput) ToSkuOutput() SkuOutput {
	return o
}

func (o SkuOutput) ToSkuOutputWithContext(ctx context.Context) SkuOutput {
	return o
}

// The SKU name.
func (o SkuOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Sku) string { return v.Name }).(pulumi.StringOutput)
}

// The SKU details.
type SkuResponse struct {
	// The SKU name.
	Name string `pulumi:"name"`
	// The SKU tier.
	Tier string `pulumi:"tier"`
}

// The SKU details.
type SkuResponseOutput struct{ *pulumi.OutputState }

func (SkuResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SkuResponse)(nil)).Elem()
}

func (o SkuResponseOutput) ToSkuResponseOutput() SkuResponseOutput {
	return o
}

func (o SkuResponseOutput) ToSkuResponseOutputWithContext(ctx context.Context) SkuResponseOutput {
	return o
}

// The SKU name.
func (o SkuResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SkuResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The SKU tier.
func (o SkuResponseOutput) Tier() pulumi.StringOutput {
	return o.ApplyT(func(v SkuResponse) string { return v.Tier }).(pulumi.StringOutput)
}

// The details about the associated storage account.
type StorageAccount struct {
	// The ID of the storage account resource. Video Analyzer relies on tables, queues, and blobs. The primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage).
	Id string `pulumi:"id"`
	// A managed identity that Video Analyzer will use to access the storage account.
	Identity *ResourceIdentity `pulumi:"identity"`
}

// StorageAccountInput is an input type that accepts StorageAccountArgs and StorageAccountOutput values.
// You can construct a concrete instance of `StorageAccountInput` via:
//
//	StorageAccountArgs{...}
type StorageAccountInput interface {
	pulumi.Input

	ToStorageAccountOutput() StorageAccountOutput
	ToStorageAccountOutputWithContext(context.Context) StorageAccountOutput
}

// The details about the associated storage account.
type StorageAccountArgs struct {
	// The ID of the storage account resource. Video Analyzer relies on tables, queues, and blobs. The primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage).
	Id pulumi.StringInput `pulumi:"id"`
	// A managed identity that Video Analyzer will use to access the storage account.
	Identity ResourceIdentityPtrInput `pulumi:"identity"`
}

func (StorageAccountArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageAccount)(nil)).Elem()
}

func (i StorageAccountArgs) ToStorageAccountOutput() StorageAccountOutput {
	return i.ToStorageAccountOutputWithContext(context.Background())
}

func (i StorageAccountArgs) ToStorageAccountOutputWithContext(ctx context.Context) StorageAccountOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageAccountOutput)
}

// StorageAccountArrayInput is an input type that accepts StorageAccountArray and StorageAccountArrayOutput values.
// You can construct a concrete instance of `StorageAccountArrayInput` via:
//
//	StorageAccountArray{ StorageAccountArgs{...} }
type StorageAccountArrayInput interface {
	pulumi.Input

	ToStorageAccountArrayOutput() StorageAccountArrayOutput
	ToStorageAccountArrayOutputWithContext(context.Context) StorageAccountArrayOutput
}

type StorageAccountArray []StorageAccountInput

func (StorageAccountArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StorageAccount)(nil)).Elem()
}

func (i StorageAccountArray) ToStorageAccountArrayOutput() StorageAccountArrayOutput {
	return i.ToStorageAccountArrayOutputWithContext(context.Background())
}

func (i StorageAccountArray) ToStorageAccountArrayOutputWithContext(ctx context.Context) StorageAccountArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageAccountArrayOutput)
}

// The details about the associated storage account.
type StorageAccountOutput struct{ *pulumi.OutputState }

func (StorageAccountOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageAccount)(nil)).Elem()
}

func (o StorageAccountOutput) ToStorageAccountOutput() StorageAccountOutput {
	return o
}

func (o StorageAccountOutput) ToStorageAccountOutputWithContext(ctx context.Context) StorageAccountOutput {
	return o
}

// The ID of the storage account resource. Video Analyzer relies on tables, queues, and blobs. The primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage).
func (o StorageAccountOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v StorageAccount) string { return v.Id }).(pulumi.StringOutput)
}

// A managed identity that Video Analyzer will use to access the storage account.
func (o StorageAccountOutput) Identity() ResourceIdentityPtrOutput {
	return o.ApplyT(func(v StorageAccount) *ResourceIdentity { return v.Identity }).(ResourceIdentityPtrOutput)
}

type StorageAccountArrayOutput struct{ *pulumi.OutputState }

func (StorageAccountArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StorageAccount)(nil)).Elem()
}

func (o StorageAccountArrayOutput) ToStorageAccountArrayOutput() StorageAccountArrayOutput {
	return o
}

func (o StorageAccountArrayOutput) ToStorageAccountArrayOutputWithContext(ctx context.Context) StorageAccountArrayOutput {
	return o
}

func (o StorageAccountArrayOutput) Index(i pulumi.IntInput) StorageAccountOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StorageAccount {
		return vs[0].([]StorageAccount)[vs[1].(int)]
	}).(StorageAccountOutput)
}

// The details about the associated storage account.
type StorageAccountResponse struct {
	// The ID of the storage account resource. Video Analyzer relies on tables, queues, and blobs. The primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage).
	Id string `pulumi:"id"`
	// A managed identity that Video Analyzer will use to access the storage account.
	Identity *ResourceIdentityResponse `pulumi:"identity"`
	// The current status of the storage account mapping.
	Status string `pulumi:"status"`
}

// The details about the associated storage account.
type StorageAccountResponseOutput struct{ *pulumi.OutputState }

func (StorageAccountResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StorageAccountResponse)(nil)).Elem()
}

func (o StorageAccountResponseOutput) ToStorageAccountResponseOutput() StorageAccountResponseOutput {
	return o
}

func (o StorageAccountResponseOutput) ToStorageAccountResponseOutputWithContext(ctx context.Context) StorageAccountResponseOutput {
	return o
}

// The ID of the storage account resource. Video Analyzer relies on tables, queues, and blobs. The primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage).
func (o StorageAccountResponseOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v StorageAccountResponse) string { return v.Id }).(pulumi.StringOutput)
}

// A managed identity that Video Analyzer will use to access the storage account.
func (o StorageAccountResponseOutput) Identity() ResourceIdentityResponsePtrOutput {
	return o.ApplyT(func(v StorageAccountResponse) *ResourceIdentityResponse { return v.Identity }).(ResourceIdentityResponsePtrOutput)
}

// The current status of the storage account mapping.
func (o StorageAccountResponseOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v StorageAccountResponse) string { return v.Status }).(pulumi.StringOutput)
}

type StorageAccountResponseArrayOutput struct{ *pulumi.OutputState }

func (StorageAccountResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StorageAccountResponse)(nil)).Elem()
}

func (o StorageAccountResponseArrayOutput) ToStorageAccountResponseArrayOutput() StorageAccountResponseArrayOutput {
	return o
}

func (o StorageAccountResponseArrayOutput) ToStorageAccountResponseArrayOutputWithContext(ctx context.Context) StorageAccountResponseArrayOutput {
	return o
}

func (o StorageAccountResponseArrayOutput) Index(i pulumi.IntInput) StorageAccountResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StorageAccountResponse {
		return vs[0].([]StorageAccountResponse)[vs[1].(int)]
	}).(StorageAccountResponseOutput)
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponse struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *string `pulumi:"createdAt"`
	// The identity that created the resource.
	CreatedBy *string `pulumi:"createdBy"`
	// The type of identity that created the resource.
	CreatedByType *string `pulumi:"createdByType"`
	// The timestamp of resource last modification (UTC)
	LastModifiedAt *string `pulumi:"lastModifiedAt"`
	// The identity that last modified the resource.
	LastModifiedBy *string `pulumi:"lastModifiedBy"`
	// The type of identity that last modified the resource.
	LastModifiedByType *string `pulumi:"lastModifiedByType"`
}

// Metadata pertaining to creation and last modification of the resource.
type SystemDataResponseOutput struct{ *pulumi.OutputState }

func (SystemDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SystemDataResponse)(nil)).Elem()
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutput() SystemDataResponseOutput {
	return o
}

func (o SystemDataResponseOutput) ToSystemDataResponseOutputWithContext(ctx context.Context) SystemDataResponseOutput {
	return o
}

// The timestamp of resource creation (UTC).
func (o SystemDataResponseOutput) CreatedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedAt }).(pulumi.StringPtrOutput)
}

// The identity that created the resource.
func (o SystemDataResponseOutput) CreatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that created the resource.
func (o SystemDataResponseOutput) CreatedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.CreatedByType }).(pulumi.StringPtrOutput)
}

// The timestamp of resource last modification (UTC)
func (o SystemDataResponseOutput) LastModifiedAt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedAt }).(pulumi.StringPtrOutput)
}

// The identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedBy }).(pulumi.StringPtrOutput)
}

// The type of identity that last modified the resource.
func (o SystemDataResponseOutput) LastModifiedByType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SystemDataResponse) *string { return v.LastModifiedByType }).(pulumi.StringPtrOutput)
}

// TLS endpoint describes an endpoint that the pipeline can connect to over TLS transport (data is encrypted in transit).
type TlsEndpoint struct {
	// Credentials to be presented to the endpoint.
	Credentials UsernamePasswordCredentials `pulumi:"credentials"`
	// List of trusted certificate authorities when authenticating a TLS connection. A null list designates that Azure Video Analyzer's list of trusted authorities should be used.
	TrustedCertificates *PemCertificateList `pulumi:"trustedCertificates"`
	// Describes the tunnel through which Video Analyzer can connect to the endpoint URL. This is an optional property, typically used when the endpoint is behind a firewall.
	Tunnel *SecureIotDeviceRemoteTunnel `pulumi:"tunnel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.TlsEndpoint'.
	Type string `pulumi:"type"`
	// The endpoint URL for Video Analyzer to connect to.
	Url string `pulumi:"url"`
	// Validation options to use when authenticating a TLS connection. By default, strict validation is used.
	ValidationOptions *TlsValidationOptions `pulumi:"validationOptions"`
}

// TLS endpoint describes an endpoint that the pipeline can connect to over TLS transport (data is encrypted in transit).
type TlsEndpointResponse struct {
	// Credentials to be presented to the endpoint.
	Credentials UsernamePasswordCredentialsResponse `pulumi:"credentials"`
	// List of trusted certificate authorities when authenticating a TLS connection. A null list designates that Azure Video Analyzer's list of trusted authorities should be used.
	TrustedCertificates *PemCertificateListResponse `pulumi:"trustedCertificates"`
	// Describes the tunnel through which Video Analyzer can connect to the endpoint URL. This is an optional property, typically used when the endpoint is behind a firewall.
	Tunnel *SecureIotDeviceRemoteTunnelResponse `pulumi:"tunnel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.TlsEndpoint'.
	Type string `pulumi:"type"`
	// The endpoint URL for Video Analyzer to connect to.
	Url string `pulumi:"url"`
	// Validation options to use when authenticating a TLS connection. By default, strict validation is used.
	ValidationOptions *TlsValidationOptionsResponse `pulumi:"validationOptions"`
}

// Options for controlling the validation of TLS endpoints.
type TlsValidationOptions struct {
	// When set to 'true' causes the certificate subject name validation to be skipped. Default is 'false'.
	IgnoreHostname *string `pulumi:"ignoreHostname"`
	// When set to 'true' causes the certificate chain trust validation to be skipped. Default is 'false'.
	IgnoreSignature *string `pulumi:"ignoreSignature"`
}

// Options for controlling the validation of TLS endpoints.
type TlsValidationOptionsResponse struct {
	// When set to 'true' causes the certificate subject name validation to be skipped. Default is 'false'.
	IgnoreHostname *string `pulumi:"ignoreHostname"`
	// When set to 'true' causes the certificate chain trust validation to be skipped. Default is 'false'.
	IgnoreSignature *string `pulumi:"ignoreSignature"`
}

// Properties for expected token claims.
type TokenClaim struct {
	// Name of the claim which must be present on the token.
	Name string `pulumi:"name"`
	// Expected value of the claim to be present on the token.
	Value string `pulumi:"value"`
}

// TokenClaimInput is an input type that accepts TokenClaimArgs and TokenClaimOutput values.
// You can construct a concrete instance of `TokenClaimInput` via:
//
//	TokenClaimArgs{...}
type TokenClaimInput interface {
	pulumi.Input

	ToTokenClaimOutput() TokenClaimOutput
	ToTokenClaimOutputWithContext(context.Context) TokenClaimOutput
}

// Properties for expected token claims.
type TokenClaimArgs struct {
	// Name of the claim which must be present on the token.
	Name pulumi.StringInput `pulumi:"name"`
	// Expected value of the claim to be present on the token.
	Value pulumi.StringInput `pulumi:"value"`
}

func (TokenClaimArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TokenClaim)(nil)).Elem()
}

func (i TokenClaimArgs) ToTokenClaimOutput() TokenClaimOutput {
	return i.ToTokenClaimOutputWithContext(context.Background())
}

func (i TokenClaimArgs) ToTokenClaimOutputWithContext(ctx context.Context) TokenClaimOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TokenClaimOutput)
}

// TokenClaimArrayInput is an input type that accepts TokenClaimArray and TokenClaimArrayOutput values.
// You can construct a concrete instance of `TokenClaimArrayInput` via:
//
//	TokenClaimArray{ TokenClaimArgs{...} }
type TokenClaimArrayInput interface {
	pulumi.Input

	ToTokenClaimArrayOutput() TokenClaimArrayOutput
	ToTokenClaimArrayOutputWithContext(context.Context) TokenClaimArrayOutput
}

type TokenClaimArray []TokenClaimInput

func (TokenClaimArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TokenClaim)(nil)).Elem()
}

func (i TokenClaimArray) ToTokenClaimArrayOutput() TokenClaimArrayOutput {
	return i.ToTokenClaimArrayOutputWithContext(context.Background())
}

func (i TokenClaimArray) ToTokenClaimArrayOutputWithContext(ctx context.Context) TokenClaimArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TokenClaimArrayOutput)
}

// Properties for expected token claims.
type TokenClaimOutput struct{ *pulumi.OutputState }

func (TokenClaimOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TokenClaim)(nil)).Elem()
}

func (o TokenClaimOutput) ToTokenClaimOutput() TokenClaimOutput {
	return o
}

func (o TokenClaimOutput) ToTokenClaimOutputWithContext(ctx context.Context) TokenClaimOutput {
	return o
}

// Name of the claim which must be present on the token.
func (o TokenClaimOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TokenClaim) string { return v.Name }).(pulumi.StringOutput)
}

// Expected value of the claim to be present on the token.
func (o TokenClaimOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v TokenClaim) string { return v.Value }).(pulumi.StringOutput)
}

type TokenClaimArrayOutput struct{ *pulumi.OutputState }

func (TokenClaimArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TokenClaim)(nil)).Elem()
}

func (o TokenClaimArrayOutput) ToTokenClaimArrayOutput() TokenClaimArrayOutput {
	return o
}

func (o TokenClaimArrayOutput) ToTokenClaimArrayOutputWithContext(ctx context.Context) TokenClaimArrayOutput {
	return o
}

func (o TokenClaimArrayOutput) Index(i pulumi.IntInput) TokenClaimOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TokenClaim {
		return vs[0].([]TokenClaim)[vs[1].(int)]
	}).(TokenClaimOutput)
}

// Properties for expected token claims.
type TokenClaimResponse struct {
	// Name of the claim which must be present on the token.
	Name string `pulumi:"name"`
	// Expected value of the claim to be present on the token.
	Value string `pulumi:"value"`
}

// Properties for expected token claims.
type TokenClaimResponseOutput struct{ *pulumi.OutputState }

func (TokenClaimResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TokenClaimResponse)(nil)).Elem()
}

func (o TokenClaimResponseOutput) ToTokenClaimResponseOutput() TokenClaimResponseOutput {
	return o
}

func (o TokenClaimResponseOutput) ToTokenClaimResponseOutputWithContext(ctx context.Context) TokenClaimResponseOutput {
	return o
}

// Name of the claim which must be present on the token.
func (o TokenClaimResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TokenClaimResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Expected value of the claim to be present on the token.
func (o TokenClaimResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v TokenClaimResponse) string { return v.Value }).(pulumi.StringOutput)
}

type TokenClaimResponseArrayOutput struct{ *pulumi.OutputState }

func (TokenClaimResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TokenClaimResponse)(nil)).Elem()
}

func (o TokenClaimResponseArrayOutput) ToTokenClaimResponseArrayOutput() TokenClaimResponseArrayOutput {
	return o
}

func (o TokenClaimResponseArrayOutput) ToTokenClaimResponseArrayOutputWithContext(ctx context.Context) TokenClaimResponseArrayOutput {
	return o
}

func (o TokenClaimResponseArrayOutput) Index(i pulumi.IntInput) TokenClaimResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TokenClaimResponse {
		return vs[0].([]TokenClaimResponse)[vs[1].(int)]
	}).(TokenClaimResponseOutput)
}

// Unsecured endpoint describes an endpoint that the pipeline can connect to over clear transport (no encryption in transit).
type UnsecuredEndpoint struct {
	// Credentials to be presented to the endpoint.
	Credentials UsernamePasswordCredentials `pulumi:"credentials"`
	// Describes the tunnel through which Video Analyzer can connect to the endpoint URL. This is an optional property, typically used when the endpoint is behind a firewall.
	Tunnel *SecureIotDeviceRemoteTunnel `pulumi:"tunnel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.UnsecuredEndpoint'.
	Type string `pulumi:"type"`
	// The endpoint URL for Video Analyzer to connect to.
	Url string `pulumi:"url"`
}

// Unsecured endpoint describes an endpoint that the pipeline can connect to over clear transport (no encryption in transit).
type UnsecuredEndpointResponse struct {
	// Credentials to be presented to the endpoint.
	Credentials UsernamePasswordCredentialsResponse `pulumi:"credentials"`
	// Describes the tunnel through which Video Analyzer can connect to the endpoint URL. This is an optional property, typically used when the endpoint is behind a firewall.
	Tunnel *SecureIotDeviceRemoteTunnelResponse `pulumi:"tunnel"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.UnsecuredEndpoint'.
	Type string `pulumi:"type"`
	// The endpoint URL for Video Analyzer to connect to.
	Url string `pulumi:"url"`
}

// The details of the user assigned managed identity used by the Video Analyzer resource.
type UserAssignedManagedIdentityResponse struct {
	// The client ID.
	ClientId string `pulumi:"clientId"`
	// The principal ID.
	PrincipalId string `pulumi:"principalId"`
}

// The details of the user assigned managed identity used by the Video Analyzer resource.
type UserAssignedManagedIdentityResponseOutput struct{ *pulumi.OutputState }

func (UserAssignedManagedIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserAssignedManagedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedManagedIdentityResponseOutput) ToUserAssignedManagedIdentityResponseOutput() UserAssignedManagedIdentityResponseOutput {
	return o
}

func (o UserAssignedManagedIdentityResponseOutput) ToUserAssignedManagedIdentityResponseOutputWithContext(ctx context.Context) UserAssignedManagedIdentityResponseOutput {
	return o
}

// The client ID.
func (o UserAssignedManagedIdentityResponseOutput) ClientId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedManagedIdentityResponse) string { return v.ClientId }).(pulumi.StringOutput)
}

// The principal ID.
func (o UserAssignedManagedIdentityResponseOutput) PrincipalId() pulumi.StringOutput {
	return o.ApplyT(func(v UserAssignedManagedIdentityResponse) string { return v.PrincipalId }).(pulumi.StringOutput)
}

type UserAssignedManagedIdentityResponseMapOutput struct{ *pulumi.OutputState }

func (UserAssignedManagedIdentityResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]UserAssignedManagedIdentityResponse)(nil)).Elem()
}

func (o UserAssignedManagedIdentityResponseMapOutput) ToUserAssignedManagedIdentityResponseMapOutput() UserAssignedManagedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedManagedIdentityResponseMapOutput) ToUserAssignedManagedIdentityResponseMapOutputWithContext(ctx context.Context) UserAssignedManagedIdentityResponseMapOutput {
	return o
}

func (o UserAssignedManagedIdentityResponseMapOutput) MapIndex(k pulumi.StringInput) UserAssignedManagedIdentityResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) UserAssignedManagedIdentityResponse {
		return vs[0].(map[string]UserAssignedManagedIdentityResponse)[vs[1].(string)]
	}).(UserAssignedManagedIdentityResponseOutput)
}

// Username and password credentials.
type UsernamePasswordCredentials struct {
	// Password to be presented as part of the credentials. It is recommended that this value is parameterized as a secret string in order to prevent this value to be returned as part of the resource on API requests.
	Password string `pulumi:"password"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.UsernamePasswordCredentials'.
	Type string `pulumi:"type"`
	// Username to be presented as part of the credentials.
	Username string `pulumi:"username"`
}

// Username and password credentials.
type UsernamePasswordCredentialsResponse struct {
	// Password to be presented as part of the credentials. It is recommended that this value is parameterized as a secret string in order to prevent this value to be returned as part of the resource on API requests.
	Password string `pulumi:"password"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.UsernamePasswordCredentials'.
	Type string `pulumi:"type"`
	// Username to be presented as part of the credentials.
	Username string `pulumi:"username"`
}

// The managed identity for the Video Analyzer resource.
type VideoAnalyzerIdentity struct {
	// The identity type.
	Type string `pulumi:"type"`
	// The User Assigned Managed Identities.
	UserAssignedIdentities map[string]interface{} `pulumi:"userAssignedIdentities"`
}

// VideoAnalyzerIdentityInput is an input type that accepts VideoAnalyzerIdentityArgs and VideoAnalyzerIdentityOutput values.
// You can construct a concrete instance of `VideoAnalyzerIdentityInput` via:
//
//	VideoAnalyzerIdentityArgs{...}
type VideoAnalyzerIdentityInput interface {
	pulumi.Input

	ToVideoAnalyzerIdentityOutput() VideoAnalyzerIdentityOutput
	ToVideoAnalyzerIdentityOutputWithContext(context.Context) VideoAnalyzerIdentityOutput
}

// The managed identity for the Video Analyzer resource.
type VideoAnalyzerIdentityArgs struct {
	// The identity type.
	Type pulumi.StringInput `pulumi:"type"`
	// The User Assigned Managed Identities.
	UserAssignedIdentities pulumi.MapInput `pulumi:"userAssignedIdentities"`
}

func (VideoAnalyzerIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoAnalyzerIdentity)(nil)).Elem()
}

func (i VideoAnalyzerIdentityArgs) ToVideoAnalyzerIdentityOutput() VideoAnalyzerIdentityOutput {
	return i.ToVideoAnalyzerIdentityOutputWithContext(context.Background())
}

func (i VideoAnalyzerIdentityArgs) ToVideoAnalyzerIdentityOutputWithContext(ctx context.Context) VideoAnalyzerIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoAnalyzerIdentityOutput)
}

func (i VideoAnalyzerIdentityArgs) ToVideoAnalyzerIdentityPtrOutput() VideoAnalyzerIdentityPtrOutput {
	return i.ToVideoAnalyzerIdentityPtrOutputWithContext(context.Background())
}

func (i VideoAnalyzerIdentityArgs) ToVideoAnalyzerIdentityPtrOutputWithContext(ctx context.Context) VideoAnalyzerIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoAnalyzerIdentityOutput).ToVideoAnalyzerIdentityPtrOutputWithContext(ctx)
}

// VideoAnalyzerIdentityPtrInput is an input type that accepts VideoAnalyzerIdentityArgs, VideoAnalyzerIdentityPtr and VideoAnalyzerIdentityPtrOutput values.
// You can construct a concrete instance of `VideoAnalyzerIdentityPtrInput` via:
//
//	        VideoAnalyzerIdentityArgs{...}
//
//	or:
//
//	        nil
type VideoAnalyzerIdentityPtrInput interface {
	pulumi.Input

	ToVideoAnalyzerIdentityPtrOutput() VideoAnalyzerIdentityPtrOutput
	ToVideoAnalyzerIdentityPtrOutputWithContext(context.Context) VideoAnalyzerIdentityPtrOutput
}

type videoAnalyzerIdentityPtrType VideoAnalyzerIdentityArgs

func VideoAnalyzerIdentityPtr(v *VideoAnalyzerIdentityArgs) VideoAnalyzerIdentityPtrInput {
	return (*videoAnalyzerIdentityPtrType)(v)
}

func (*videoAnalyzerIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoAnalyzerIdentity)(nil)).Elem()
}

func (i *videoAnalyzerIdentityPtrType) ToVideoAnalyzerIdentityPtrOutput() VideoAnalyzerIdentityPtrOutput {
	return i.ToVideoAnalyzerIdentityPtrOutputWithContext(context.Background())
}

func (i *videoAnalyzerIdentityPtrType) ToVideoAnalyzerIdentityPtrOutputWithContext(ctx context.Context) VideoAnalyzerIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoAnalyzerIdentityPtrOutput)
}

// The managed identity for the Video Analyzer resource.
type VideoAnalyzerIdentityOutput struct{ *pulumi.OutputState }

func (VideoAnalyzerIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoAnalyzerIdentity)(nil)).Elem()
}

func (o VideoAnalyzerIdentityOutput) ToVideoAnalyzerIdentityOutput() VideoAnalyzerIdentityOutput {
	return o
}

func (o VideoAnalyzerIdentityOutput) ToVideoAnalyzerIdentityOutputWithContext(ctx context.Context) VideoAnalyzerIdentityOutput {
	return o
}

func (o VideoAnalyzerIdentityOutput) ToVideoAnalyzerIdentityPtrOutput() VideoAnalyzerIdentityPtrOutput {
	return o.ToVideoAnalyzerIdentityPtrOutputWithContext(context.Background())
}

func (o VideoAnalyzerIdentityOutput) ToVideoAnalyzerIdentityPtrOutputWithContext(ctx context.Context) VideoAnalyzerIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VideoAnalyzerIdentity) *VideoAnalyzerIdentity {
		return &v
	}).(VideoAnalyzerIdentityPtrOutput)
}

// The identity type.
func (o VideoAnalyzerIdentityOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VideoAnalyzerIdentity) string { return v.Type }).(pulumi.StringOutput)
}

// The User Assigned Managed Identities.
func (o VideoAnalyzerIdentityOutput) UserAssignedIdentities() pulumi.MapOutput {
	return o.ApplyT(func(v VideoAnalyzerIdentity) map[string]interface{} { return v.UserAssignedIdentities }).(pulumi.MapOutput)
}

type VideoAnalyzerIdentityPtrOutput struct{ *pulumi.OutputState }

func (VideoAnalyzerIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoAnalyzerIdentity)(nil)).Elem()
}

func (o VideoAnalyzerIdentityPtrOutput) ToVideoAnalyzerIdentityPtrOutput() VideoAnalyzerIdentityPtrOutput {
	return o
}

func (o VideoAnalyzerIdentityPtrOutput) ToVideoAnalyzerIdentityPtrOutputWithContext(ctx context.Context) VideoAnalyzerIdentityPtrOutput {
	return o
}

func (o VideoAnalyzerIdentityPtrOutput) Elem() VideoAnalyzerIdentityOutput {
	return o.ApplyT(func(v *VideoAnalyzerIdentity) VideoAnalyzerIdentity {
		if v != nil {
			return *v
		}
		var ret VideoAnalyzerIdentity
		return ret
	}).(VideoAnalyzerIdentityOutput)
}

// The identity type.
func (o VideoAnalyzerIdentityPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerIdentity) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The User Assigned Managed Identities.
func (o VideoAnalyzerIdentityPtrOutput) UserAssignedIdentities() pulumi.MapOutput {
	return o.ApplyT(func(v *VideoAnalyzerIdentity) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(pulumi.MapOutput)
}

// The managed identity for the Video Analyzer resource.
type VideoAnalyzerIdentityResponse struct {
	// The identity type.
	Type string `pulumi:"type"`
	// The User Assigned Managed Identities.
	UserAssignedIdentities map[string]UserAssignedManagedIdentityResponse `pulumi:"userAssignedIdentities"`
}

// The managed identity for the Video Analyzer resource.
type VideoAnalyzerIdentityResponseOutput struct{ *pulumi.OutputState }

func (VideoAnalyzerIdentityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoAnalyzerIdentityResponse)(nil)).Elem()
}

func (o VideoAnalyzerIdentityResponseOutput) ToVideoAnalyzerIdentityResponseOutput() VideoAnalyzerIdentityResponseOutput {
	return o
}

func (o VideoAnalyzerIdentityResponseOutput) ToVideoAnalyzerIdentityResponseOutputWithContext(ctx context.Context) VideoAnalyzerIdentityResponseOutput {
	return o
}

// The identity type.
func (o VideoAnalyzerIdentityResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VideoAnalyzerIdentityResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The User Assigned Managed Identities.
func (o VideoAnalyzerIdentityResponseOutput) UserAssignedIdentities() UserAssignedManagedIdentityResponseMapOutput {
	return o.ApplyT(func(v VideoAnalyzerIdentityResponse) map[string]UserAssignedManagedIdentityResponse {
		return v.UserAssignedIdentities
	}).(UserAssignedManagedIdentityResponseMapOutput)
}

type VideoAnalyzerIdentityResponsePtrOutput struct{ *pulumi.OutputState }

func (VideoAnalyzerIdentityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoAnalyzerIdentityResponse)(nil)).Elem()
}

func (o VideoAnalyzerIdentityResponsePtrOutput) ToVideoAnalyzerIdentityResponsePtrOutput() VideoAnalyzerIdentityResponsePtrOutput {
	return o
}

func (o VideoAnalyzerIdentityResponsePtrOutput) ToVideoAnalyzerIdentityResponsePtrOutputWithContext(ctx context.Context) VideoAnalyzerIdentityResponsePtrOutput {
	return o
}

func (o VideoAnalyzerIdentityResponsePtrOutput) Elem() VideoAnalyzerIdentityResponseOutput {
	return o.ApplyT(func(v *VideoAnalyzerIdentityResponse) VideoAnalyzerIdentityResponse {
		if v != nil {
			return *v
		}
		var ret VideoAnalyzerIdentityResponse
		return ret
	}).(VideoAnalyzerIdentityResponseOutput)
}

// The identity type.
func (o VideoAnalyzerIdentityResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoAnalyzerIdentityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The User Assigned Managed Identities.
func (o VideoAnalyzerIdentityResponsePtrOutput) UserAssignedIdentities() UserAssignedManagedIdentityResponseMapOutput {
	return o.ApplyT(func(v *VideoAnalyzerIdentityResponse) map[string]UserAssignedManagedIdentityResponse {
		if v == nil {
			return nil
		}
		return v.UserAssignedIdentities
	}).(UserAssignedManagedIdentityResponseMapOutput)
}

// Video archival properties.
type VideoArchival struct {
	// Video retention period indicates the maximum age of the video archive segments which are intended to be kept in storage. It must be provided in the ISO8601 duration format in the granularity of days, up to a maximum of 10 years. For example, if this is set to P30D (30 days), content older than 30 days will be periodically deleted. This value can be updated at any time and the new desired retention period will be effective within 24 hours.
	RetentionPeriod *string `pulumi:"retentionPeriod"`
}

// VideoArchivalInput is an input type that accepts VideoArchivalArgs and VideoArchivalOutput values.
// You can construct a concrete instance of `VideoArchivalInput` via:
//
//	VideoArchivalArgs{...}
type VideoArchivalInput interface {
	pulumi.Input

	ToVideoArchivalOutput() VideoArchivalOutput
	ToVideoArchivalOutputWithContext(context.Context) VideoArchivalOutput
}

// Video archival properties.
type VideoArchivalArgs struct {
	// Video retention period indicates the maximum age of the video archive segments which are intended to be kept in storage. It must be provided in the ISO8601 duration format in the granularity of days, up to a maximum of 10 years. For example, if this is set to P30D (30 days), content older than 30 days will be periodically deleted. This value can be updated at any time and the new desired retention period will be effective within 24 hours.
	RetentionPeriod pulumi.StringPtrInput `pulumi:"retentionPeriod"`
}

func (VideoArchivalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoArchival)(nil)).Elem()
}

func (i VideoArchivalArgs) ToVideoArchivalOutput() VideoArchivalOutput {
	return i.ToVideoArchivalOutputWithContext(context.Background())
}

func (i VideoArchivalArgs) ToVideoArchivalOutputWithContext(ctx context.Context) VideoArchivalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoArchivalOutput)
}

func (i VideoArchivalArgs) ToVideoArchivalPtrOutput() VideoArchivalPtrOutput {
	return i.ToVideoArchivalPtrOutputWithContext(context.Background())
}

func (i VideoArchivalArgs) ToVideoArchivalPtrOutputWithContext(ctx context.Context) VideoArchivalPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoArchivalOutput).ToVideoArchivalPtrOutputWithContext(ctx)
}

// VideoArchivalPtrInput is an input type that accepts VideoArchivalArgs, VideoArchivalPtr and VideoArchivalPtrOutput values.
// You can construct a concrete instance of `VideoArchivalPtrInput` via:
//
//	        VideoArchivalArgs{...}
//
//	or:
//
//	        nil
type VideoArchivalPtrInput interface {
	pulumi.Input

	ToVideoArchivalPtrOutput() VideoArchivalPtrOutput
	ToVideoArchivalPtrOutputWithContext(context.Context) VideoArchivalPtrOutput
}

type videoArchivalPtrType VideoArchivalArgs

func VideoArchivalPtr(v *VideoArchivalArgs) VideoArchivalPtrInput {
	return (*videoArchivalPtrType)(v)
}

func (*videoArchivalPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoArchival)(nil)).Elem()
}

func (i *videoArchivalPtrType) ToVideoArchivalPtrOutput() VideoArchivalPtrOutput {
	return i.ToVideoArchivalPtrOutputWithContext(context.Background())
}

func (i *videoArchivalPtrType) ToVideoArchivalPtrOutputWithContext(ctx context.Context) VideoArchivalPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoArchivalPtrOutput)
}

// Video archival properties.
type VideoArchivalOutput struct{ *pulumi.OutputState }

func (VideoArchivalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoArchival)(nil)).Elem()
}

func (o VideoArchivalOutput) ToVideoArchivalOutput() VideoArchivalOutput {
	return o
}

func (o VideoArchivalOutput) ToVideoArchivalOutputWithContext(ctx context.Context) VideoArchivalOutput {
	return o
}

func (o VideoArchivalOutput) ToVideoArchivalPtrOutput() VideoArchivalPtrOutput {
	return o.ToVideoArchivalPtrOutputWithContext(context.Background())
}

func (o VideoArchivalOutput) ToVideoArchivalPtrOutputWithContext(ctx context.Context) VideoArchivalPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VideoArchival) *VideoArchival {
		return &v
	}).(VideoArchivalPtrOutput)
}

// Video retention period indicates the maximum age of the video archive segments which are intended to be kept in storage. It must be provided in the ISO8601 duration format in the granularity of days, up to a maximum of 10 years. For example, if this is set to P30D (30 days), content older than 30 days will be periodically deleted. This value can be updated at any time and the new desired retention period will be effective within 24 hours.
func (o VideoArchivalOutput) RetentionPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoArchival) *string { return v.RetentionPeriod }).(pulumi.StringPtrOutput)
}

type VideoArchivalPtrOutput struct{ *pulumi.OutputState }

func (VideoArchivalPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoArchival)(nil)).Elem()
}

func (o VideoArchivalPtrOutput) ToVideoArchivalPtrOutput() VideoArchivalPtrOutput {
	return o
}

func (o VideoArchivalPtrOutput) ToVideoArchivalPtrOutputWithContext(ctx context.Context) VideoArchivalPtrOutput {
	return o
}

func (o VideoArchivalPtrOutput) Elem() VideoArchivalOutput {
	return o.ApplyT(func(v *VideoArchival) VideoArchival {
		if v != nil {
			return *v
		}
		var ret VideoArchival
		return ret
	}).(VideoArchivalOutput)
}

// Video retention period indicates the maximum age of the video archive segments which are intended to be kept in storage. It must be provided in the ISO8601 duration format in the granularity of days, up to a maximum of 10 years. For example, if this is set to P30D (30 days), content older than 30 days will be periodically deleted. This value can be updated at any time and the new desired retention period will be effective within 24 hours.
func (o VideoArchivalPtrOutput) RetentionPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoArchival) *string {
		if v == nil {
			return nil
		}
		return v.RetentionPeriod
	}).(pulumi.StringPtrOutput)
}

// Video archival properties.
type VideoArchivalResponse struct {
	// Video retention period indicates the maximum age of the video archive segments which are intended to be kept in storage. It must be provided in the ISO8601 duration format in the granularity of days, up to a maximum of 10 years. For example, if this is set to P30D (30 days), content older than 30 days will be periodically deleted. This value can be updated at any time and the new desired retention period will be effective within 24 hours.
	RetentionPeriod *string `pulumi:"retentionPeriod"`
}

// Video archival properties.
type VideoArchivalResponseOutput struct{ *pulumi.OutputState }

func (VideoArchivalResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoArchivalResponse)(nil)).Elem()
}

func (o VideoArchivalResponseOutput) ToVideoArchivalResponseOutput() VideoArchivalResponseOutput {
	return o
}

func (o VideoArchivalResponseOutput) ToVideoArchivalResponseOutputWithContext(ctx context.Context) VideoArchivalResponseOutput {
	return o
}

// Video retention period indicates the maximum age of the video archive segments which are intended to be kept in storage. It must be provided in the ISO8601 duration format in the granularity of days, up to a maximum of 10 years. For example, if this is set to P30D (30 days), content older than 30 days will be periodically deleted. This value can be updated at any time and the new desired retention period will be effective within 24 hours.
func (o VideoArchivalResponseOutput) RetentionPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoArchivalResponse) *string { return v.RetentionPeriod }).(pulumi.StringPtrOutput)
}

type VideoArchivalResponsePtrOutput struct{ *pulumi.OutputState }

func (VideoArchivalResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoArchivalResponse)(nil)).Elem()
}

func (o VideoArchivalResponsePtrOutput) ToVideoArchivalResponsePtrOutput() VideoArchivalResponsePtrOutput {
	return o
}

func (o VideoArchivalResponsePtrOutput) ToVideoArchivalResponsePtrOutputWithContext(ctx context.Context) VideoArchivalResponsePtrOutput {
	return o
}

func (o VideoArchivalResponsePtrOutput) Elem() VideoArchivalResponseOutput {
	return o.ApplyT(func(v *VideoArchivalResponse) VideoArchivalResponse {
		if v != nil {
			return *v
		}
		var ret VideoArchivalResponse
		return ret
	}).(VideoArchivalResponseOutput)
}

// Video retention period indicates the maximum age of the video archive segments which are intended to be kept in storage. It must be provided in the ISO8601 duration format in the granularity of days, up to a maximum of 10 years. For example, if this is set to P30D (30 days), content older than 30 days will be periodically deleted. This value can be updated at any time and the new desired retention period will be effective within 24 hours.
func (o VideoArchivalResponsePtrOutput) RetentionPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoArchivalResponse) *string {
		if v == nil {
			return nil
		}
		return v.RetentionPeriod
	}).(pulumi.StringPtrOutput)
}

// Set of URLs to the video content.
type VideoContentUrlsResponse struct {
	// Video archive streaming base URL. The archived content can be automatically played by the Azure Video Analyzer player widget. Alternatively, this URL can be used in conjunction with the video content authorization token on any compatible DASH or HLS players by appending the following to the base URL:
	//
	//     - HLSv4:     /manifest(format=m3u8-aapl).m3u8
	//     - HLS CMAF:  /manifest(format=m3u8-cmaf)
	//     - DASH CMAF: /manifest(format=mpd-time-cmaf)
	//
	//     Moreover, an ongoing video recording can be played in "live mode" with latencies which are approximately double of the chosen video segment length. It is available when the video type is 'archive' and video archiving is enabled.
	ArchiveBaseUrl *string `pulumi:"archiveBaseUrl"`
	// Video file download URL. This URL can be used in conjunction with the video content authorization token to download the video MP4 file. The resulting MP4 file can be played on any standard media player. It is available when the video type is 'file' and video file is available for consumption.
	DownloadUrl *string `pulumi:"downloadUrl"`
	// Video preview image URLs. These URLs can be used in conjunction with the video content authorization token to download the most recent still image from the video archive in different resolutions. They are available when the video type is 'archive' and preview images are enabled.
	PreviewImageUrls *VideoPreviewImageUrlsResponse `pulumi:"previewImageUrls"`
	// Video low-latency streaming URL. The live content can be automatically played by the Azure Video Analyzer player widget. Alternatively, this URL can be used in conjunction with the video content authorization token to expose a WebSocket tunneled RTSP stream. It is available when the video type is 'archive' and a live, low-latency feed is available from the source.
	RtspTunnelUrl *string `pulumi:"rtspTunnelUrl"`
}

// Set of URLs to the video content.
type VideoContentUrlsResponseOutput struct{ *pulumi.OutputState }

func (VideoContentUrlsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoContentUrlsResponse)(nil)).Elem()
}

func (o VideoContentUrlsResponseOutput) ToVideoContentUrlsResponseOutput() VideoContentUrlsResponseOutput {
	return o
}

func (o VideoContentUrlsResponseOutput) ToVideoContentUrlsResponseOutputWithContext(ctx context.Context) VideoContentUrlsResponseOutput {
	return o
}

// Video archive streaming base URL. The archived content can be automatically played by the Azure Video Analyzer player widget. Alternatively, this URL can be used in conjunction with the video content authorization token on any compatible DASH or HLS players by appending the following to the base URL:
//
//   - HLSv4:     /manifest(format=m3u8-aapl).m3u8
//
//   - HLS CMAF:  /manifest(format=m3u8-cmaf)
//
//   - DASH CMAF: /manifest(format=mpd-time-cmaf)
//
//     Moreover, an ongoing video recording can be played in "live mode" with latencies which are approximately double of the chosen video segment length. It is available when the video type is 'archive' and video archiving is enabled.
func (o VideoContentUrlsResponseOutput) ArchiveBaseUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoContentUrlsResponse) *string { return v.ArchiveBaseUrl }).(pulumi.StringPtrOutput)
}

// Video file download URL. This URL can be used in conjunction with the video content authorization token to download the video MP4 file. The resulting MP4 file can be played on any standard media player. It is available when the video type is 'file' and video file is available for consumption.
func (o VideoContentUrlsResponseOutput) DownloadUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoContentUrlsResponse) *string { return v.DownloadUrl }).(pulumi.StringPtrOutput)
}

// Video preview image URLs. These URLs can be used in conjunction with the video content authorization token to download the most recent still image from the video archive in different resolutions. They are available when the video type is 'archive' and preview images are enabled.
func (o VideoContentUrlsResponseOutput) PreviewImageUrls() VideoPreviewImageUrlsResponsePtrOutput {
	return o.ApplyT(func(v VideoContentUrlsResponse) *VideoPreviewImageUrlsResponse { return v.PreviewImageUrls }).(VideoPreviewImageUrlsResponsePtrOutput)
}

// Video low-latency streaming URL. The live content can be automatically played by the Azure Video Analyzer player widget. Alternatively, this URL can be used in conjunction with the video content authorization token to expose a WebSocket tunneled RTSP stream. It is available when the video type is 'archive' and a live, low-latency feed is available from the source.
func (o VideoContentUrlsResponseOutput) RtspTunnelUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoContentUrlsResponse) *string { return v.RtspTunnelUrl }).(pulumi.StringPtrOutput)
}

// Optional properties to be used in case a new video resource needs to be created on the service. These will not take effect if the video already exists.
type VideoCreationProperties struct {
	// Optional description provided by the user. Value can be up to 2048 characters long.
	Description *string `pulumi:"description"`
	// Video retention period indicates how long the video is kept in storage. Value must be specified in ISO8601 duration format (i.e. "P1D" equals 1 day) and can vary between 1 day to 10 years, in 1 day increments. When absent (null), all video content is retained indefinitely. This property is only allowed for topologies where "kind" is set to "live".
	RetentionPeriod *string `pulumi:"retentionPeriod"`
	// Segment length indicates the length of individual content files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments. Changing this value after the initial call to create the video resource can lead to errors when uploading content to the archive. Default value is 30 seconds. This property is only allowed for topologies where "kind" is set to "live".
	SegmentLength *string `pulumi:"segmentLength"`
	// Optional title provided by the user. Value can be up to 256 characters long.
	Title *string `pulumi:"title"`
}

// VideoCreationPropertiesInput is an input type that accepts VideoCreationPropertiesArgs and VideoCreationPropertiesOutput values.
// You can construct a concrete instance of `VideoCreationPropertiesInput` via:
//
//	VideoCreationPropertiesArgs{...}
type VideoCreationPropertiesInput interface {
	pulumi.Input

	ToVideoCreationPropertiesOutput() VideoCreationPropertiesOutput
	ToVideoCreationPropertiesOutputWithContext(context.Context) VideoCreationPropertiesOutput
}

// Optional properties to be used in case a new video resource needs to be created on the service. These will not take effect if the video already exists.
type VideoCreationPropertiesArgs struct {
	// Optional description provided by the user. Value can be up to 2048 characters long.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Video retention period indicates how long the video is kept in storage. Value must be specified in ISO8601 duration format (i.e. "P1D" equals 1 day) and can vary between 1 day to 10 years, in 1 day increments. When absent (null), all video content is retained indefinitely. This property is only allowed for topologies where "kind" is set to "live".
	RetentionPeriod pulumi.StringPtrInput `pulumi:"retentionPeriod"`
	// Segment length indicates the length of individual content files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments. Changing this value after the initial call to create the video resource can lead to errors when uploading content to the archive. Default value is 30 seconds. This property is only allowed for topologies where "kind" is set to "live".
	SegmentLength pulumi.StringPtrInput `pulumi:"segmentLength"`
	// Optional title provided by the user. Value can be up to 256 characters long.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (VideoCreationPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoCreationProperties)(nil)).Elem()
}

func (i VideoCreationPropertiesArgs) ToVideoCreationPropertiesOutput() VideoCreationPropertiesOutput {
	return i.ToVideoCreationPropertiesOutputWithContext(context.Background())
}

func (i VideoCreationPropertiesArgs) ToVideoCreationPropertiesOutputWithContext(ctx context.Context) VideoCreationPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoCreationPropertiesOutput)
}

func (i VideoCreationPropertiesArgs) ToVideoCreationPropertiesPtrOutput() VideoCreationPropertiesPtrOutput {
	return i.ToVideoCreationPropertiesPtrOutputWithContext(context.Background())
}

func (i VideoCreationPropertiesArgs) ToVideoCreationPropertiesPtrOutputWithContext(ctx context.Context) VideoCreationPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoCreationPropertiesOutput).ToVideoCreationPropertiesPtrOutputWithContext(ctx)
}

// VideoCreationPropertiesPtrInput is an input type that accepts VideoCreationPropertiesArgs, VideoCreationPropertiesPtr and VideoCreationPropertiesPtrOutput values.
// You can construct a concrete instance of `VideoCreationPropertiesPtrInput` via:
//
//	        VideoCreationPropertiesArgs{...}
//
//	or:
//
//	        nil
type VideoCreationPropertiesPtrInput interface {
	pulumi.Input

	ToVideoCreationPropertiesPtrOutput() VideoCreationPropertiesPtrOutput
	ToVideoCreationPropertiesPtrOutputWithContext(context.Context) VideoCreationPropertiesPtrOutput
}

type videoCreationPropertiesPtrType VideoCreationPropertiesArgs

func VideoCreationPropertiesPtr(v *VideoCreationPropertiesArgs) VideoCreationPropertiesPtrInput {
	return (*videoCreationPropertiesPtrType)(v)
}

func (*videoCreationPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoCreationProperties)(nil)).Elem()
}

func (i *videoCreationPropertiesPtrType) ToVideoCreationPropertiesPtrOutput() VideoCreationPropertiesPtrOutput {
	return i.ToVideoCreationPropertiesPtrOutputWithContext(context.Background())
}

func (i *videoCreationPropertiesPtrType) ToVideoCreationPropertiesPtrOutputWithContext(ctx context.Context) VideoCreationPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoCreationPropertiesPtrOutput)
}

// Optional properties to be used in case a new video resource needs to be created on the service. These will not take effect if the video already exists.
type VideoCreationPropertiesOutput struct{ *pulumi.OutputState }

func (VideoCreationPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoCreationProperties)(nil)).Elem()
}

func (o VideoCreationPropertiesOutput) ToVideoCreationPropertiesOutput() VideoCreationPropertiesOutput {
	return o
}

func (o VideoCreationPropertiesOutput) ToVideoCreationPropertiesOutputWithContext(ctx context.Context) VideoCreationPropertiesOutput {
	return o
}

func (o VideoCreationPropertiesOutput) ToVideoCreationPropertiesPtrOutput() VideoCreationPropertiesPtrOutput {
	return o.ToVideoCreationPropertiesPtrOutputWithContext(context.Background())
}

func (o VideoCreationPropertiesOutput) ToVideoCreationPropertiesPtrOutputWithContext(ctx context.Context) VideoCreationPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VideoCreationProperties) *VideoCreationProperties {
		return &v
	}).(VideoCreationPropertiesPtrOutput)
}

// Optional description provided by the user. Value can be up to 2048 characters long.
func (o VideoCreationPropertiesOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoCreationProperties) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Video retention period indicates how long the video is kept in storage. Value must be specified in ISO8601 duration format (i.e. "P1D" equals 1 day) and can vary between 1 day to 10 years, in 1 day increments. When absent (null), all video content is retained indefinitely. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoCreationPropertiesOutput) RetentionPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoCreationProperties) *string { return v.RetentionPeriod }).(pulumi.StringPtrOutput)
}

// Segment length indicates the length of individual content files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments. Changing this value after the initial call to create the video resource can lead to errors when uploading content to the archive. Default value is 30 seconds. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoCreationPropertiesOutput) SegmentLength() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoCreationProperties) *string { return v.SegmentLength }).(pulumi.StringPtrOutput)
}

// Optional title provided by the user. Value can be up to 256 characters long.
func (o VideoCreationPropertiesOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoCreationProperties) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type VideoCreationPropertiesPtrOutput struct{ *pulumi.OutputState }

func (VideoCreationPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoCreationProperties)(nil)).Elem()
}

func (o VideoCreationPropertiesPtrOutput) ToVideoCreationPropertiesPtrOutput() VideoCreationPropertiesPtrOutput {
	return o
}

func (o VideoCreationPropertiesPtrOutput) ToVideoCreationPropertiesPtrOutputWithContext(ctx context.Context) VideoCreationPropertiesPtrOutput {
	return o
}

func (o VideoCreationPropertiesPtrOutput) Elem() VideoCreationPropertiesOutput {
	return o.ApplyT(func(v *VideoCreationProperties) VideoCreationProperties {
		if v != nil {
			return *v
		}
		var ret VideoCreationProperties
		return ret
	}).(VideoCreationPropertiesOutput)
}

// Optional description provided by the user. Value can be up to 2048 characters long.
func (o VideoCreationPropertiesPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoCreationProperties) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Video retention period indicates how long the video is kept in storage. Value must be specified in ISO8601 duration format (i.e. "P1D" equals 1 day) and can vary between 1 day to 10 years, in 1 day increments. When absent (null), all video content is retained indefinitely. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoCreationPropertiesPtrOutput) RetentionPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoCreationProperties) *string {
		if v == nil {
			return nil
		}
		return v.RetentionPeriod
	}).(pulumi.StringPtrOutput)
}

// Segment length indicates the length of individual content files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments. Changing this value after the initial call to create the video resource can lead to errors when uploading content to the archive. Default value is 30 seconds. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoCreationPropertiesPtrOutput) SegmentLength() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoCreationProperties) *string {
		if v == nil {
			return nil
		}
		return v.SegmentLength
	}).(pulumi.StringPtrOutput)
}

// Optional title provided by the user. Value can be up to 256 characters long.
func (o VideoCreationPropertiesPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoCreationProperties) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// Optional properties to be used in case a new video resource needs to be created on the service. These will not take effect if the video already exists.
type VideoCreationPropertiesResponse struct {
	// Optional description provided by the user. Value can be up to 2048 characters long.
	Description *string `pulumi:"description"`
	// Video retention period indicates how long the video is kept in storage. Value must be specified in ISO8601 duration format (i.e. "P1D" equals 1 day) and can vary between 1 day to 10 years, in 1 day increments. When absent (null), all video content is retained indefinitely. This property is only allowed for topologies where "kind" is set to "live".
	RetentionPeriod *string `pulumi:"retentionPeriod"`
	// Segment length indicates the length of individual content files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments. Changing this value after the initial call to create the video resource can lead to errors when uploading content to the archive. Default value is 30 seconds. This property is only allowed for topologies where "kind" is set to "live".
	SegmentLength *string `pulumi:"segmentLength"`
	// Optional title provided by the user. Value can be up to 256 characters long.
	Title *string `pulumi:"title"`
}

// Optional properties to be used in case a new video resource needs to be created on the service. These will not take effect if the video already exists.
type VideoCreationPropertiesResponseOutput struct{ *pulumi.OutputState }

func (VideoCreationPropertiesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoCreationPropertiesResponse)(nil)).Elem()
}

func (o VideoCreationPropertiesResponseOutput) ToVideoCreationPropertiesResponseOutput() VideoCreationPropertiesResponseOutput {
	return o
}

func (o VideoCreationPropertiesResponseOutput) ToVideoCreationPropertiesResponseOutputWithContext(ctx context.Context) VideoCreationPropertiesResponseOutput {
	return o
}

// Optional description provided by the user. Value can be up to 2048 characters long.
func (o VideoCreationPropertiesResponseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoCreationPropertiesResponse) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Video retention period indicates how long the video is kept in storage. Value must be specified in ISO8601 duration format (i.e. "P1D" equals 1 day) and can vary between 1 day to 10 years, in 1 day increments. When absent (null), all video content is retained indefinitely. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoCreationPropertiesResponseOutput) RetentionPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoCreationPropertiesResponse) *string { return v.RetentionPeriod }).(pulumi.StringPtrOutput)
}

// Segment length indicates the length of individual content files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments. Changing this value after the initial call to create the video resource can lead to errors when uploading content to the archive. Default value is 30 seconds. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoCreationPropertiesResponseOutput) SegmentLength() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoCreationPropertiesResponse) *string { return v.SegmentLength }).(pulumi.StringPtrOutput)
}

// Optional title provided by the user. Value can be up to 256 characters long.
func (o VideoCreationPropertiesResponseOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoCreationPropertiesResponse) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type VideoCreationPropertiesResponsePtrOutput struct{ *pulumi.OutputState }

func (VideoCreationPropertiesResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoCreationPropertiesResponse)(nil)).Elem()
}

func (o VideoCreationPropertiesResponsePtrOutput) ToVideoCreationPropertiesResponsePtrOutput() VideoCreationPropertiesResponsePtrOutput {
	return o
}

func (o VideoCreationPropertiesResponsePtrOutput) ToVideoCreationPropertiesResponsePtrOutputWithContext(ctx context.Context) VideoCreationPropertiesResponsePtrOutput {
	return o
}

func (o VideoCreationPropertiesResponsePtrOutput) Elem() VideoCreationPropertiesResponseOutput {
	return o.ApplyT(func(v *VideoCreationPropertiesResponse) VideoCreationPropertiesResponse {
		if v != nil {
			return *v
		}
		var ret VideoCreationPropertiesResponse
		return ret
	}).(VideoCreationPropertiesResponseOutput)
}

// Optional description provided by the user. Value can be up to 2048 characters long.
func (o VideoCreationPropertiesResponsePtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoCreationPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Video retention period indicates how long the video is kept in storage. Value must be specified in ISO8601 duration format (i.e. "P1D" equals 1 day) and can vary between 1 day to 10 years, in 1 day increments. When absent (null), all video content is retained indefinitely. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoCreationPropertiesResponsePtrOutput) RetentionPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoCreationPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return v.RetentionPeriod
	}).(pulumi.StringPtrOutput)
}

// Segment length indicates the length of individual content files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments. Changing this value after the initial call to create the video resource can lead to errors when uploading content to the archive. Default value is 30 seconds. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoCreationPropertiesResponsePtrOutput) SegmentLength() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoCreationPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return v.SegmentLength
	}).(pulumi.StringPtrOutput)
}

// Optional title provided by the user. Value can be up to 256 characters long.
func (o VideoCreationPropertiesResponsePtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoCreationPropertiesResponse) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// A custom preset for encoding video with the H.264 (AVC) codec.
type VideoEncoderH264 struct {
	// The maximum bitrate, in kilobits per second or Kbps, at which video should be encoded. If omitted, encoder sets it automatically to try and match the quality of the input video.
	BitrateKbps *string `pulumi:"bitrateKbps"`
	// The frame rate (in frames per second) of the encoded video. The value must be greater than zero, and less than or equal to 300. If omitted, the encoder uses the average frame rate of the input video.
	FrameRate *string `pulumi:"frameRate"`
	// Describes the resolution of the encoded video. If omitted, the encoder uses the resolution of the input video.
	Scale *VideoScale `pulumi:"scale"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.VideoEncoderH264'.
	Type string `pulumi:"type"`
}

// A custom preset for encoding video with the H.264 (AVC) codec.
type VideoEncoderH264Response struct {
	// The maximum bitrate, in kilobits per second or Kbps, at which video should be encoded. If omitted, encoder sets it automatically to try and match the quality of the input video.
	BitrateKbps *string `pulumi:"bitrateKbps"`
	// The frame rate (in frames per second) of the encoded video. The value must be greater than zero, and less than or equal to 300. If omitted, the encoder uses the average frame rate of the input video.
	FrameRate *string `pulumi:"frameRate"`
	// Describes the resolution of the encoded video. If omitted, the encoder uses the resolution of the input video.
	Scale *VideoScaleResponse `pulumi:"scale"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.VideoEncoderH264'.
	Type string `pulumi:"type"`
}

// Video flags contain information about the available video actions and its dynamic properties based on the current video state.
type VideoFlagsResponse struct {
	// Value indicating whether or not the video can be streamed. Only "archive" type videos can be streamed.
	CanStream bool `pulumi:"canStream"`
	// Value indicating whether or not there has ever been data recorded or uploaded into the video. Newly created videos have this value set to false.
	HasData bool `pulumi:"hasData"`
	// Value indicating whether or not the video is currently being referenced be an active pipeline. The fact that is being referenced, doesn't necessarily indicate that data is being received. For example, video recording may be gated on events or camera may not be accessible at the time.
	IsInUse bool `pulumi:"isInUse"`
}

// Video flags contain information about the available video actions and its dynamic properties based on the current video state.
type VideoFlagsResponseOutput struct{ *pulumi.OutputState }

func (VideoFlagsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoFlagsResponse)(nil)).Elem()
}

func (o VideoFlagsResponseOutput) ToVideoFlagsResponseOutput() VideoFlagsResponseOutput {
	return o
}

func (o VideoFlagsResponseOutput) ToVideoFlagsResponseOutputWithContext(ctx context.Context) VideoFlagsResponseOutput {
	return o
}

// Value indicating whether or not the video can be streamed. Only "archive" type videos can be streamed.
func (o VideoFlagsResponseOutput) CanStream() pulumi.BoolOutput {
	return o.ApplyT(func(v VideoFlagsResponse) bool { return v.CanStream }).(pulumi.BoolOutput)
}

// Value indicating whether or not there has ever been data recorded or uploaded into the video. Newly created videos have this value set to false.
func (o VideoFlagsResponseOutput) HasData() pulumi.BoolOutput {
	return o.ApplyT(func(v VideoFlagsResponse) bool { return v.HasData }).(pulumi.BoolOutput)
}

// Value indicating whether or not the video is currently being referenced be an active pipeline. The fact that is being referenced, doesn't necessarily indicate that data is being received. For example, video recording may be gated on events or camera may not be accessible at the time.
func (o VideoFlagsResponseOutput) IsInUse() pulumi.BoolOutput {
	return o.ApplyT(func(v VideoFlagsResponse) bool { return v.IsInUse }).(pulumi.BoolOutput)
}

// Contains information about the video and audio content.
type VideoMediaInfo struct {
	// Video segment length indicates the length of individual video files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments.
	SegmentLength *string `pulumi:"segmentLength"`
}

// VideoMediaInfoInput is an input type that accepts VideoMediaInfoArgs and VideoMediaInfoOutput values.
// You can construct a concrete instance of `VideoMediaInfoInput` via:
//
//	VideoMediaInfoArgs{...}
type VideoMediaInfoInput interface {
	pulumi.Input

	ToVideoMediaInfoOutput() VideoMediaInfoOutput
	ToVideoMediaInfoOutputWithContext(context.Context) VideoMediaInfoOutput
}

// Contains information about the video and audio content.
type VideoMediaInfoArgs struct {
	// Video segment length indicates the length of individual video files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments.
	SegmentLength pulumi.StringPtrInput `pulumi:"segmentLength"`
}

func (VideoMediaInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoMediaInfo)(nil)).Elem()
}

func (i VideoMediaInfoArgs) ToVideoMediaInfoOutput() VideoMediaInfoOutput {
	return i.ToVideoMediaInfoOutputWithContext(context.Background())
}

func (i VideoMediaInfoArgs) ToVideoMediaInfoOutputWithContext(ctx context.Context) VideoMediaInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoMediaInfoOutput)
}

func (i VideoMediaInfoArgs) ToVideoMediaInfoPtrOutput() VideoMediaInfoPtrOutput {
	return i.ToVideoMediaInfoPtrOutputWithContext(context.Background())
}

func (i VideoMediaInfoArgs) ToVideoMediaInfoPtrOutputWithContext(ctx context.Context) VideoMediaInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoMediaInfoOutput).ToVideoMediaInfoPtrOutputWithContext(ctx)
}

// VideoMediaInfoPtrInput is an input type that accepts VideoMediaInfoArgs, VideoMediaInfoPtr and VideoMediaInfoPtrOutput values.
// You can construct a concrete instance of `VideoMediaInfoPtrInput` via:
//
//	        VideoMediaInfoArgs{...}
//
//	or:
//
//	        nil
type VideoMediaInfoPtrInput interface {
	pulumi.Input

	ToVideoMediaInfoPtrOutput() VideoMediaInfoPtrOutput
	ToVideoMediaInfoPtrOutputWithContext(context.Context) VideoMediaInfoPtrOutput
}

type videoMediaInfoPtrType VideoMediaInfoArgs

func VideoMediaInfoPtr(v *VideoMediaInfoArgs) VideoMediaInfoPtrInput {
	return (*videoMediaInfoPtrType)(v)
}

func (*videoMediaInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoMediaInfo)(nil)).Elem()
}

func (i *videoMediaInfoPtrType) ToVideoMediaInfoPtrOutput() VideoMediaInfoPtrOutput {
	return i.ToVideoMediaInfoPtrOutputWithContext(context.Background())
}

func (i *videoMediaInfoPtrType) ToVideoMediaInfoPtrOutputWithContext(ctx context.Context) VideoMediaInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoMediaInfoPtrOutput)
}

// Contains information about the video and audio content.
type VideoMediaInfoOutput struct{ *pulumi.OutputState }

func (VideoMediaInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoMediaInfo)(nil)).Elem()
}

func (o VideoMediaInfoOutput) ToVideoMediaInfoOutput() VideoMediaInfoOutput {
	return o
}

func (o VideoMediaInfoOutput) ToVideoMediaInfoOutputWithContext(ctx context.Context) VideoMediaInfoOutput {
	return o
}

func (o VideoMediaInfoOutput) ToVideoMediaInfoPtrOutput() VideoMediaInfoPtrOutput {
	return o.ToVideoMediaInfoPtrOutputWithContext(context.Background())
}

func (o VideoMediaInfoOutput) ToVideoMediaInfoPtrOutputWithContext(ctx context.Context) VideoMediaInfoPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VideoMediaInfo) *VideoMediaInfo {
		return &v
	}).(VideoMediaInfoPtrOutput)
}

// Video segment length indicates the length of individual video files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments.
func (o VideoMediaInfoOutput) SegmentLength() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoMediaInfo) *string { return v.SegmentLength }).(pulumi.StringPtrOutput)
}

type VideoMediaInfoPtrOutput struct{ *pulumi.OutputState }

func (VideoMediaInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoMediaInfo)(nil)).Elem()
}

func (o VideoMediaInfoPtrOutput) ToVideoMediaInfoPtrOutput() VideoMediaInfoPtrOutput {
	return o
}

func (o VideoMediaInfoPtrOutput) ToVideoMediaInfoPtrOutputWithContext(ctx context.Context) VideoMediaInfoPtrOutput {
	return o
}

func (o VideoMediaInfoPtrOutput) Elem() VideoMediaInfoOutput {
	return o.ApplyT(func(v *VideoMediaInfo) VideoMediaInfo {
		if v != nil {
			return *v
		}
		var ret VideoMediaInfo
		return ret
	}).(VideoMediaInfoOutput)
}

// Video segment length indicates the length of individual video files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments.
func (o VideoMediaInfoPtrOutput) SegmentLength() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoMediaInfo) *string {
		if v == nil {
			return nil
		}
		return v.SegmentLength
	}).(pulumi.StringPtrOutput)
}

// Contains information about the video and audio content.
type VideoMediaInfoResponse struct {
	// Video segment length indicates the length of individual video files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments.
	SegmentLength *string `pulumi:"segmentLength"`
}

// Contains information about the video and audio content.
type VideoMediaInfoResponseOutput struct{ *pulumi.OutputState }

func (VideoMediaInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoMediaInfoResponse)(nil)).Elem()
}

func (o VideoMediaInfoResponseOutput) ToVideoMediaInfoResponseOutput() VideoMediaInfoResponseOutput {
	return o
}

func (o VideoMediaInfoResponseOutput) ToVideoMediaInfoResponseOutputWithContext(ctx context.Context) VideoMediaInfoResponseOutput {
	return o
}

// Video segment length indicates the length of individual video files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments.
func (o VideoMediaInfoResponseOutput) SegmentLength() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoMediaInfoResponse) *string { return v.SegmentLength }).(pulumi.StringPtrOutput)
}

type VideoMediaInfoResponsePtrOutput struct{ *pulumi.OutputState }

func (VideoMediaInfoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoMediaInfoResponse)(nil)).Elem()
}

func (o VideoMediaInfoResponsePtrOutput) ToVideoMediaInfoResponsePtrOutput() VideoMediaInfoResponsePtrOutput {
	return o
}

func (o VideoMediaInfoResponsePtrOutput) ToVideoMediaInfoResponsePtrOutputWithContext(ctx context.Context) VideoMediaInfoResponsePtrOutput {
	return o
}

func (o VideoMediaInfoResponsePtrOutput) Elem() VideoMediaInfoResponseOutput {
	return o.ApplyT(func(v *VideoMediaInfoResponse) VideoMediaInfoResponse {
		if v != nil {
			return *v
		}
		var ret VideoMediaInfoResponse
		return ret
	}).(VideoMediaInfoResponseOutput)
}

// Video segment length indicates the length of individual video files (segments) which are persisted to storage. Smaller segments provide lower archive playback latency but generate larger volume of storage transactions. Larger segments reduce the amount of storage transactions while increasing the archive playback latency. Value must be specified in ISO8601 duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds increments.
func (o VideoMediaInfoResponsePtrOutput) SegmentLength() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoMediaInfoResponse) *string {
		if v == nil {
			return nil
		}
		return v.SegmentLength
	}).(pulumi.StringPtrOutput)
}

// Video preview image URLs. These URLs can be used in conjunction with the video content authorization token to download the most recent still image from the video archive in different resolutions. They are available when the video type is 'archive' and preview images are enabled.
type VideoPreviewImageUrlsResponse struct {
	// High resolution preview image URL.
	Large *string `pulumi:"large"`
	// Medium resolution preview image URL.
	Medium *string `pulumi:"medium"`
	// Low resolution preview image URL.
	Small *string `pulumi:"small"`
}

// Video preview image URLs. These URLs can be used in conjunction with the video content authorization token to download the most recent still image from the video archive in different resolutions. They are available when the video type is 'archive' and preview images are enabled.
type VideoPreviewImageUrlsResponseOutput struct{ *pulumi.OutputState }

func (VideoPreviewImageUrlsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoPreviewImageUrlsResponse)(nil)).Elem()
}

func (o VideoPreviewImageUrlsResponseOutput) ToVideoPreviewImageUrlsResponseOutput() VideoPreviewImageUrlsResponseOutput {
	return o
}

func (o VideoPreviewImageUrlsResponseOutput) ToVideoPreviewImageUrlsResponseOutputWithContext(ctx context.Context) VideoPreviewImageUrlsResponseOutput {
	return o
}

// High resolution preview image URL.
func (o VideoPreviewImageUrlsResponseOutput) Large() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoPreviewImageUrlsResponse) *string { return v.Large }).(pulumi.StringPtrOutput)
}

// Medium resolution preview image URL.
func (o VideoPreviewImageUrlsResponseOutput) Medium() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoPreviewImageUrlsResponse) *string { return v.Medium }).(pulumi.StringPtrOutput)
}

// Low resolution preview image URL.
func (o VideoPreviewImageUrlsResponseOutput) Small() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoPreviewImageUrlsResponse) *string { return v.Small }).(pulumi.StringPtrOutput)
}

type VideoPreviewImageUrlsResponsePtrOutput struct{ *pulumi.OutputState }

func (VideoPreviewImageUrlsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoPreviewImageUrlsResponse)(nil)).Elem()
}

func (o VideoPreviewImageUrlsResponsePtrOutput) ToVideoPreviewImageUrlsResponsePtrOutput() VideoPreviewImageUrlsResponsePtrOutput {
	return o
}

func (o VideoPreviewImageUrlsResponsePtrOutput) ToVideoPreviewImageUrlsResponsePtrOutputWithContext(ctx context.Context) VideoPreviewImageUrlsResponsePtrOutput {
	return o
}

func (o VideoPreviewImageUrlsResponsePtrOutput) Elem() VideoPreviewImageUrlsResponseOutput {
	return o.ApplyT(func(v *VideoPreviewImageUrlsResponse) VideoPreviewImageUrlsResponse {
		if v != nil {
			return *v
		}
		var ret VideoPreviewImageUrlsResponse
		return ret
	}).(VideoPreviewImageUrlsResponseOutput)
}

// High resolution preview image URL.
func (o VideoPreviewImageUrlsResponsePtrOutput) Large() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoPreviewImageUrlsResponse) *string {
		if v == nil {
			return nil
		}
		return v.Large
	}).(pulumi.StringPtrOutput)
}

// Medium resolution preview image URL.
func (o VideoPreviewImageUrlsResponsePtrOutput) Medium() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoPreviewImageUrlsResponse) *string {
		if v == nil {
			return nil
		}
		return v.Medium
	}).(pulumi.StringPtrOutput)
}

// Low resolution preview image URL.
func (o VideoPreviewImageUrlsResponsePtrOutput) Small() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoPreviewImageUrlsResponse) *string {
		if v == nil {
			return nil
		}
		return v.Small
	}).(pulumi.StringPtrOutput)
}

// Optional flags used to change how video is published. These are only allowed for topologies where "kind" is set to "live".
type VideoPublishingOptions struct {
	// When set to 'true' content will not be archived or recorded. This is used, for example, when the topology is used only for low latency video streaming. Default is 'false'.  If set to 'true', then "disableRtspPublishing" must be set to 'false'.
	DisableArchive *string `pulumi:"disableArchive"`
	// When set to 'true' the RTSP playback URL will not be published, disabling low latency streaming. This is used, for example, when the topology is used only for archiving content. Default is 'false'.  If set to 'true', then "disableArchive" must be set to 'false'.
	DisableRtspPublishing *string `pulumi:"disableRtspPublishing"`
}

// VideoPublishingOptionsInput is an input type that accepts VideoPublishingOptionsArgs and VideoPublishingOptionsOutput values.
// You can construct a concrete instance of `VideoPublishingOptionsInput` via:
//
//	VideoPublishingOptionsArgs{...}
type VideoPublishingOptionsInput interface {
	pulumi.Input

	ToVideoPublishingOptionsOutput() VideoPublishingOptionsOutput
	ToVideoPublishingOptionsOutputWithContext(context.Context) VideoPublishingOptionsOutput
}

// Optional flags used to change how video is published. These are only allowed for topologies where "kind" is set to "live".
type VideoPublishingOptionsArgs struct {
	// When set to 'true' content will not be archived or recorded. This is used, for example, when the topology is used only for low latency video streaming. Default is 'false'.  If set to 'true', then "disableRtspPublishing" must be set to 'false'.
	DisableArchive pulumi.StringPtrInput `pulumi:"disableArchive"`
	// When set to 'true' the RTSP playback URL will not be published, disabling low latency streaming. This is used, for example, when the topology is used only for archiving content. Default is 'false'.  If set to 'true', then "disableArchive" must be set to 'false'.
	DisableRtspPublishing pulumi.StringPtrInput `pulumi:"disableRtspPublishing"`
}

func (VideoPublishingOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoPublishingOptions)(nil)).Elem()
}

func (i VideoPublishingOptionsArgs) ToVideoPublishingOptionsOutput() VideoPublishingOptionsOutput {
	return i.ToVideoPublishingOptionsOutputWithContext(context.Background())
}

func (i VideoPublishingOptionsArgs) ToVideoPublishingOptionsOutputWithContext(ctx context.Context) VideoPublishingOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoPublishingOptionsOutput)
}

func (i VideoPublishingOptionsArgs) ToVideoPublishingOptionsPtrOutput() VideoPublishingOptionsPtrOutput {
	return i.ToVideoPublishingOptionsPtrOutputWithContext(context.Background())
}

func (i VideoPublishingOptionsArgs) ToVideoPublishingOptionsPtrOutputWithContext(ctx context.Context) VideoPublishingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoPublishingOptionsOutput).ToVideoPublishingOptionsPtrOutputWithContext(ctx)
}

// VideoPublishingOptionsPtrInput is an input type that accepts VideoPublishingOptionsArgs, VideoPublishingOptionsPtr and VideoPublishingOptionsPtrOutput values.
// You can construct a concrete instance of `VideoPublishingOptionsPtrInput` via:
//
//	        VideoPublishingOptionsArgs{...}
//
//	or:
//
//	        nil
type VideoPublishingOptionsPtrInput interface {
	pulumi.Input

	ToVideoPublishingOptionsPtrOutput() VideoPublishingOptionsPtrOutput
	ToVideoPublishingOptionsPtrOutputWithContext(context.Context) VideoPublishingOptionsPtrOutput
}

type videoPublishingOptionsPtrType VideoPublishingOptionsArgs

func VideoPublishingOptionsPtr(v *VideoPublishingOptionsArgs) VideoPublishingOptionsPtrInput {
	return (*videoPublishingOptionsPtrType)(v)
}

func (*videoPublishingOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoPublishingOptions)(nil)).Elem()
}

func (i *videoPublishingOptionsPtrType) ToVideoPublishingOptionsPtrOutput() VideoPublishingOptionsPtrOutput {
	return i.ToVideoPublishingOptionsPtrOutputWithContext(context.Background())
}

func (i *videoPublishingOptionsPtrType) ToVideoPublishingOptionsPtrOutputWithContext(ctx context.Context) VideoPublishingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoPublishingOptionsPtrOutput)
}

// Optional flags used to change how video is published. These are only allowed for topologies where "kind" is set to "live".
type VideoPublishingOptionsOutput struct{ *pulumi.OutputState }

func (VideoPublishingOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoPublishingOptions)(nil)).Elem()
}

func (o VideoPublishingOptionsOutput) ToVideoPublishingOptionsOutput() VideoPublishingOptionsOutput {
	return o
}

func (o VideoPublishingOptionsOutput) ToVideoPublishingOptionsOutputWithContext(ctx context.Context) VideoPublishingOptionsOutput {
	return o
}

func (o VideoPublishingOptionsOutput) ToVideoPublishingOptionsPtrOutput() VideoPublishingOptionsPtrOutput {
	return o.ToVideoPublishingOptionsPtrOutputWithContext(context.Background())
}

func (o VideoPublishingOptionsOutput) ToVideoPublishingOptionsPtrOutputWithContext(ctx context.Context) VideoPublishingOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VideoPublishingOptions) *VideoPublishingOptions {
		return &v
	}).(VideoPublishingOptionsPtrOutput)
}

// When set to 'true' content will not be archived or recorded. This is used, for example, when the topology is used only for low latency video streaming. Default is 'false'.  If set to 'true', then "disableRtspPublishing" must be set to 'false'.
func (o VideoPublishingOptionsOutput) DisableArchive() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoPublishingOptions) *string { return v.DisableArchive }).(pulumi.StringPtrOutput)
}

// When set to 'true' the RTSP playback URL will not be published, disabling low latency streaming. This is used, for example, when the topology is used only for archiving content. Default is 'false'.  If set to 'true', then "disableArchive" must be set to 'false'.
func (o VideoPublishingOptionsOutput) DisableRtspPublishing() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoPublishingOptions) *string { return v.DisableRtspPublishing }).(pulumi.StringPtrOutput)
}

type VideoPublishingOptionsPtrOutput struct{ *pulumi.OutputState }

func (VideoPublishingOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoPublishingOptions)(nil)).Elem()
}

func (o VideoPublishingOptionsPtrOutput) ToVideoPublishingOptionsPtrOutput() VideoPublishingOptionsPtrOutput {
	return o
}

func (o VideoPublishingOptionsPtrOutput) ToVideoPublishingOptionsPtrOutputWithContext(ctx context.Context) VideoPublishingOptionsPtrOutput {
	return o
}

func (o VideoPublishingOptionsPtrOutput) Elem() VideoPublishingOptionsOutput {
	return o.ApplyT(func(v *VideoPublishingOptions) VideoPublishingOptions {
		if v != nil {
			return *v
		}
		var ret VideoPublishingOptions
		return ret
	}).(VideoPublishingOptionsOutput)
}

// When set to 'true' content will not be archived or recorded. This is used, for example, when the topology is used only for low latency video streaming. Default is 'false'.  If set to 'true', then "disableRtspPublishing" must be set to 'false'.
func (o VideoPublishingOptionsPtrOutput) DisableArchive() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoPublishingOptions) *string {
		if v == nil {
			return nil
		}
		return v.DisableArchive
	}).(pulumi.StringPtrOutput)
}

// When set to 'true' the RTSP playback URL will not be published, disabling low latency streaming. This is used, for example, when the topology is used only for archiving content. Default is 'false'.  If set to 'true', then "disableArchive" must be set to 'false'.
func (o VideoPublishingOptionsPtrOutput) DisableRtspPublishing() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoPublishingOptions) *string {
		if v == nil {
			return nil
		}
		return v.DisableRtspPublishing
	}).(pulumi.StringPtrOutput)
}

// Optional flags used to change how video is published. These are only allowed for topologies where "kind" is set to "live".
type VideoPublishingOptionsResponse struct {
	// When set to 'true' content will not be archived or recorded. This is used, for example, when the topology is used only for low latency video streaming. Default is 'false'.  If set to 'true', then "disableRtspPublishing" must be set to 'false'.
	DisableArchive *string `pulumi:"disableArchive"`
	// When set to 'true' the RTSP playback URL will not be published, disabling low latency streaming. This is used, for example, when the topology is used only for archiving content. Default is 'false'.  If set to 'true', then "disableArchive" must be set to 'false'.
	DisableRtspPublishing *string `pulumi:"disableRtspPublishing"`
}

// Optional flags used to change how video is published. These are only allowed for topologies where "kind" is set to "live".
type VideoPublishingOptionsResponseOutput struct{ *pulumi.OutputState }

func (VideoPublishingOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoPublishingOptionsResponse)(nil)).Elem()
}

func (o VideoPublishingOptionsResponseOutput) ToVideoPublishingOptionsResponseOutput() VideoPublishingOptionsResponseOutput {
	return o
}

func (o VideoPublishingOptionsResponseOutput) ToVideoPublishingOptionsResponseOutputWithContext(ctx context.Context) VideoPublishingOptionsResponseOutput {
	return o
}

// When set to 'true' content will not be archived or recorded. This is used, for example, when the topology is used only for low latency video streaming. Default is 'false'.  If set to 'true', then "disableRtspPublishing" must be set to 'false'.
func (o VideoPublishingOptionsResponseOutput) DisableArchive() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoPublishingOptionsResponse) *string { return v.DisableArchive }).(pulumi.StringPtrOutput)
}

// When set to 'true' the RTSP playback URL will not be published, disabling low latency streaming. This is used, for example, when the topology is used only for archiving content. Default is 'false'.  If set to 'true', then "disableArchive" must be set to 'false'.
func (o VideoPublishingOptionsResponseOutput) DisableRtspPublishing() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VideoPublishingOptionsResponse) *string { return v.DisableRtspPublishing }).(pulumi.StringPtrOutput)
}

type VideoPublishingOptionsResponsePtrOutput struct{ *pulumi.OutputState }

func (VideoPublishingOptionsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VideoPublishingOptionsResponse)(nil)).Elem()
}

func (o VideoPublishingOptionsResponsePtrOutput) ToVideoPublishingOptionsResponsePtrOutput() VideoPublishingOptionsResponsePtrOutput {
	return o
}

func (o VideoPublishingOptionsResponsePtrOutput) ToVideoPublishingOptionsResponsePtrOutputWithContext(ctx context.Context) VideoPublishingOptionsResponsePtrOutput {
	return o
}

func (o VideoPublishingOptionsResponsePtrOutput) Elem() VideoPublishingOptionsResponseOutput {
	return o.ApplyT(func(v *VideoPublishingOptionsResponse) VideoPublishingOptionsResponse {
		if v != nil {
			return *v
		}
		var ret VideoPublishingOptionsResponse
		return ret
	}).(VideoPublishingOptionsResponseOutput)
}

// When set to 'true' content will not be archived or recorded. This is used, for example, when the topology is used only for low latency video streaming. Default is 'false'.  If set to 'true', then "disableRtspPublishing" must be set to 'false'.
func (o VideoPublishingOptionsResponsePtrOutput) DisableArchive() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoPublishingOptionsResponse) *string {
		if v == nil {
			return nil
		}
		return v.DisableArchive
	}).(pulumi.StringPtrOutput)
}

// When set to 'true' the RTSP playback URL will not be published, disabling low latency streaming. This is used, for example, when the topology is used only for archiving content. Default is 'false'.  If set to 'true', then "disableArchive" must be set to 'false'.
func (o VideoPublishingOptionsResponsePtrOutput) DisableRtspPublishing() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VideoPublishingOptionsResponse) *string {
		if v == nil {
			return nil
		}
		return v.DisableRtspPublishing
	}).(pulumi.StringPtrOutput)
}

// The video scaling information.
type VideoScale struct {
	// The desired output video height.
	Height *string `pulumi:"height"`
	// Describes the video scaling mode to be applied. Default mode is 'Pad'. If the mode is 'Pad' or 'Stretch' then both width and height must be specified. Else if the mode is 'PreserveAspectRatio' then only one of width or height need be provided.
	Mode *string `pulumi:"mode"`
	// The desired output video width.
	Width *string `pulumi:"width"`
}

// The video scaling information.
type VideoScaleResponse struct {
	// The desired output video height.
	Height *string `pulumi:"height"`
	// Describes the video scaling mode to be applied. Default mode is 'Pad'. If the mode is 'Pad' or 'Stretch' then both width and height must be specified. Else if the mode is 'PreserveAspectRatio' then only one of width or height need be provided.
	Mode *string `pulumi:"mode"`
	// The desired output video width.
	Width *string `pulumi:"width"`
}

// A sequence of absolute datetime ranges as a string. The datetime values should follow IS08601, and the sum of the ranges should add up to 24 hours or less. Currently, there can be only one range specified in the sequence.
type VideoSequenceAbsoluteTimeMarkers struct {
	// The sequence of datetime ranges. Example: '[["2021-10-05T03:30:00Z", "2021-10-05T03:40:00Z"]]'.
	Ranges string `pulumi:"ranges"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.VideoSequenceAbsoluteTimeMarkers'.
	Type string `pulumi:"type"`
}

// A sequence of absolute datetime ranges as a string. The datetime values should follow IS08601, and the sum of the ranges should add up to 24 hours or less. Currently, there can be only one range specified in the sequence.
type VideoSequenceAbsoluteTimeMarkersResponse struct {
	// The sequence of datetime ranges. Example: '[["2021-10-05T03:30:00Z", "2021-10-05T03:40:00Z"]]'.
	Ranges string `pulumi:"ranges"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.VideoSequenceAbsoluteTimeMarkers'.
	Type string `pulumi:"type"`
}

// Video sink in a live topology allows for video and audio to be captured, optionally archived, and published via a video resource. If archiving is enabled, this results in a video of type 'archive'. If used in a batch topology, this allows for video and audio to be stored as a file, and published via a video resource of type 'file'
type VideoSink struct {
	// An array of upstream node references within the topology to be used as inputs for this node.
	Inputs []NodeInput `pulumi:"inputs"`
	// Node name. Must be unique within the topology.
	Name string `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.VideoSink'.
	Type string `pulumi:"type"`
	// Optional video properties to be used in case a new video resource needs to be created on the service.
	VideoCreationProperties *VideoCreationProperties `pulumi:"videoCreationProperties"`
	// Name of a new or existing video resource used to capture and publish content. Note: if downstream of RTSP source, and if disableArchive is set to true, then no content is archived.
	VideoName string `pulumi:"videoName"`
	// Options to change how the video sink publishes content via the video resource. This property is only allowed for topologies where "kind" is set to "live".
	VideoPublishingOptions *VideoPublishingOptions `pulumi:"videoPublishingOptions"`
}

// VideoSinkInput is an input type that accepts VideoSinkArgs and VideoSinkOutput values.
// You can construct a concrete instance of `VideoSinkInput` via:
//
//	VideoSinkArgs{...}
type VideoSinkInput interface {
	pulumi.Input

	ToVideoSinkOutput() VideoSinkOutput
	ToVideoSinkOutputWithContext(context.Context) VideoSinkOutput
}

// Video sink in a live topology allows for video and audio to be captured, optionally archived, and published via a video resource. If archiving is enabled, this results in a video of type 'archive'. If used in a batch topology, this allows for video and audio to be stored as a file, and published via a video resource of type 'file'
type VideoSinkArgs struct {
	// An array of upstream node references within the topology to be used as inputs for this node.
	Inputs NodeInputArrayInput `pulumi:"inputs"`
	// Node name. Must be unique within the topology.
	Name pulumi.StringInput `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.VideoSink'.
	Type pulumi.StringInput `pulumi:"type"`
	// Optional video properties to be used in case a new video resource needs to be created on the service.
	VideoCreationProperties VideoCreationPropertiesPtrInput `pulumi:"videoCreationProperties"`
	// Name of a new or existing video resource used to capture and publish content. Note: if downstream of RTSP source, and if disableArchive is set to true, then no content is archived.
	VideoName pulumi.StringInput `pulumi:"videoName"`
	// Options to change how the video sink publishes content via the video resource. This property is only allowed for topologies where "kind" is set to "live".
	VideoPublishingOptions VideoPublishingOptionsPtrInput `pulumi:"videoPublishingOptions"`
}

func (VideoSinkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoSink)(nil)).Elem()
}

func (i VideoSinkArgs) ToVideoSinkOutput() VideoSinkOutput {
	return i.ToVideoSinkOutputWithContext(context.Background())
}

func (i VideoSinkArgs) ToVideoSinkOutputWithContext(ctx context.Context) VideoSinkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoSinkOutput)
}

// VideoSinkArrayInput is an input type that accepts VideoSinkArray and VideoSinkArrayOutput values.
// You can construct a concrete instance of `VideoSinkArrayInput` via:
//
//	VideoSinkArray{ VideoSinkArgs{...} }
type VideoSinkArrayInput interface {
	pulumi.Input

	ToVideoSinkArrayOutput() VideoSinkArrayOutput
	ToVideoSinkArrayOutputWithContext(context.Context) VideoSinkArrayOutput
}

type VideoSinkArray []VideoSinkInput

func (VideoSinkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VideoSink)(nil)).Elem()
}

func (i VideoSinkArray) ToVideoSinkArrayOutput() VideoSinkArrayOutput {
	return i.ToVideoSinkArrayOutputWithContext(context.Background())
}

func (i VideoSinkArray) ToVideoSinkArrayOutputWithContext(ctx context.Context) VideoSinkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VideoSinkArrayOutput)
}

// Video sink in a live topology allows for video and audio to be captured, optionally archived, and published via a video resource. If archiving is enabled, this results in a video of type 'archive'. If used in a batch topology, this allows for video and audio to be stored as a file, and published via a video resource of type 'file'
type VideoSinkOutput struct{ *pulumi.OutputState }

func (VideoSinkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoSink)(nil)).Elem()
}

func (o VideoSinkOutput) ToVideoSinkOutput() VideoSinkOutput {
	return o
}

func (o VideoSinkOutput) ToVideoSinkOutputWithContext(ctx context.Context) VideoSinkOutput {
	return o
}

// An array of upstream node references within the topology to be used as inputs for this node.
func (o VideoSinkOutput) Inputs() NodeInputArrayOutput {
	return o.ApplyT(func(v VideoSink) []NodeInput { return v.Inputs }).(NodeInputArrayOutput)
}

// Node name. Must be unique within the topology.
func (o VideoSinkOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VideoSink) string { return v.Name }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.VideoAnalyzer.VideoSink'.
func (o VideoSinkOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VideoSink) string { return v.Type }).(pulumi.StringOutput)
}

// Optional video properties to be used in case a new video resource needs to be created on the service.
func (o VideoSinkOutput) VideoCreationProperties() VideoCreationPropertiesPtrOutput {
	return o.ApplyT(func(v VideoSink) *VideoCreationProperties { return v.VideoCreationProperties }).(VideoCreationPropertiesPtrOutput)
}

// Name of a new or existing video resource used to capture and publish content. Note: if downstream of RTSP source, and if disableArchive is set to true, then no content is archived.
func (o VideoSinkOutput) VideoName() pulumi.StringOutput {
	return o.ApplyT(func(v VideoSink) string { return v.VideoName }).(pulumi.StringOutput)
}

// Options to change how the video sink publishes content via the video resource. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoSinkOutput) VideoPublishingOptions() VideoPublishingOptionsPtrOutput {
	return o.ApplyT(func(v VideoSink) *VideoPublishingOptions { return v.VideoPublishingOptions }).(VideoPublishingOptionsPtrOutput)
}

type VideoSinkArrayOutput struct{ *pulumi.OutputState }

func (VideoSinkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VideoSink)(nil)).Elem()
}

func (o VideoSinkArrayOutput) ToVideoSinkArrayOutput() VideoSinkArrayOutput {
	return o
}

func (o VideoSinkArrayOutput) ToVideoSinkArrayOutputWithContext(ctx context.Context) VideoSinkArrayOutput {
	return o
}

func (o VideoSinkArrayOutput) Index(i pulumi.IntInput) VideoSinkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VideoSink {
		return vs[0].([]VideoSink)[vs[1].(int)]
	}).(VideoSinkOutput)
}

// Video sink in a live topology allows for video and audio to be captured, optionally archived, and published via a video resource. If archiving is enabled, this results in a video of type 'archive'. If used in a batch topology, this allows for video and audio to be stored as a file, and published via a video resource of type 'file'
type VideoSinkResponse struct {
	// An array of upstream node references within the topology to be used as inputs for this node.
	Inputs []NodeInputResponse `pulumi:"inputs"`
	// Node name. Must be unique within the topology.
	Name string `pulumi:"name"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.VideoSink'.
	Type string `pulumi:"type"`
	// Optional video properties to be used in case a new video resource needs to be created on the service.
	VideoCreationProperties *VideoCreationPropertiesResponse `pulumi:"videoCreationProperties"`
	// Name of a new or existing video resource used to capture and publish content. Note: if downstream of RTSP source, and if disableArchive is set to true, then no content is archived.
	VideoName string `pulumi:"videoName"`
	// Options to change how the video sink publishes content via the video resource. This property is only allowed for topologies where "kind" is set to "live".
	VideoPublishingOptions *VideoPublishingOptionsResponse `pulumi:"videoPublishingOptions"`
}

// Video sink in a live topology allows for video and audio to be captured, optionally archived, and published via a video resource. If archiving is enabled, this results in a video of type 'archive'. If used in a batch topology, this allows for video and audio to be stored as a file, and published via a video resource of type 'file'
type VideoSinkResponseOutput struct{ *pulumi.OutputState }

func (VideoSinkResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VideoSinkResponse)(nil)).Elem()
}

func (o VideoSinkResponseOutput) ToVideoSinkResponseOutput() VideoSinkResponseOutput {
	return o
}

func (o VideoSinkResponseOutput) ToVideoSinkResponseOutputWithContext(ctx context.Context) VideoSinkResponseOutput {
	return o
}

// An array of upstream node references within the topology to be used as inputs for this node.
func (o VideoSinkResponseOutput) Inputs() NodeInputResponseArrayOutput {
	return o.ApplyT(func(v VideoSinkResponse) []NodeInputResponse { return v.Inputs }).(NodeInputResponseArrayOutput)
}

// Node name. Must be unique within the topology.
func (o VideoSinkResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VideoSinkResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The discriminator for derived types.
// Expected value is '#Microsoft.VideoAnalyzer.VideoSink'.
func (o VideoSinkResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v VideoSinkResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Optional video properties to be used in case a new video resource needs to be created on the service.
func (o VideoSinkResponseOutput) VideoCreationProperties() VideoCreationPropertiesResponsePtrOutput {
	return o.ApplyT(func(v VideoSinkResponse) *VideoCreationPropertiesResponse { return v.VideoCreationProperties }).(VideoCreationPropertiesResponsePtrOutput)
}

// Name of a new or existing video resource used to capture and publish content. Note: if downstream of RTSP source, and if disableArchive is set to true, then no content is archived.
func (o VideoSinkResponseOutput) VideoName() pulumi.StringOutput {
	return o.ApplyT(func(v VideoSinkResponse) string { return v.VideoName }).(pulumi.StringOutput)
}

// Options to change how the video sink publishes content via the video resource. This property is only allowed for topologies where "kind" is set to "live".
func (o VideoSinkResponseOutput) VideoPublishingOptions() VideoPublishingOptionsResponsePtrOutput {
	return o.ApplyT(func(v VideoSinkResponse) *VideoPublishingOptionsResponse { return v.VideoPublishingOptions }).(VideoPublishingOptionsResponsePtrOutput)
}

type VideoSinkResponseArrayOutput struct{ *pulumi.OutputState }

func (VideoSinkResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VideoSinkResponse)(nil)).Elem()
}

func (o VideoSinkResponseArrayOutput) ToVideoSinkResponseArrayOutput() VideoSinkResponseArrayOutput {
	return o
}

func (o VideoSinkResponseArrayOutput) ToVideoSinkResponseArrayOutputWithContext(ctx context.Context) VideoSinkResponseArrayOutput {
	return o
}

func (o VideoSinkResponseArrayOutput) Index(i pulumi.IntInput) VideoSinkResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VideoSinkResponse {
		return vs[0].([]VideoSinkResponse)[vs[1].(int)]
	}).(VideoSinkResponseOutput)
}

// Video source allows for content from a Video Analyzer video resource to be ingested into a pipeline. Currently supported only with batch pipelines.
type VideoSource struct {
	// Node name. Must be unique within the topology.
	Name string `pulumi:"name"`
	// Describes a sequence of datetime ranges. The video source only picks up recorded media within these ranges.
	TimeSequences VideoSequenceAbsoluteTimeMarkers `pulumi:"timeSequences"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.VideoSource'.
	Type string `pulumi:"type"`
	// Name of the Video Analyzer video resource to be used as the source.
	VideoName string `pulumi:"videoName"`
}

// Video source allows for content from a Video Analyzer video resource to be ingested into a pipeline. Currently supported only with batch pipelines.
type VideoSourceResponse struct {
	// Node name. Must be unique within the topology.
	Name string `pulumi:"name"`
	// Describes a sequence of datetime ranges. The video source only picks up recorded media within these ranges.
	TimeSequences VideoSequenceAbsoluteTimeMarkersResponse `pulumi:"timeSequences"`
	// The discriminator for derived types.
	// Expected value is '#Microsoft.VideoAnalyzer.VideoSource'.
	Type string `pulumi:"type"`
	// Name of the Video Analyzer video resource to be used as the source.
	VideoName string `pulumi:"videoName"`
}

func init() {
	pulumi.RegisterOutputType(AccountEncryptionOutput{})
	pulumi.RegisterOutputType(AccountEncryptionPtrOutput{})
	pulumi.RegisterOutputType(AccountEncryptionResponseOutput{})
	pulumi.RegisterOutputType(AccountEncryptionResponsePtrOutput{})
	pulumi.RegisterOutputType(EncoderProcessorOutput{})
	pulumi.RegisterOutputType(EncoderProcessorArrayOutput{})
	pulumi.RegisterOutputType(EncoderProcessorResponseOutput{})
	pulumi.RegisterOutputType(EncoderProcessorResponseArrayOutput{})
	pulumi.RegisterOutputType(EndpointResponseOutput{})
	pulumi.RegisterOutputType(EndpointResponseArrayOutput{})
	pulumi.RegisterOutputType(GroupLevelAccessControlOutput{})
	pulumi.RegisterOutputType(GroupLevelAccessControlPtrOutput{})
	pulumi.RegisterOutputType(GroupLevelAccessControlResponseOutput{})
	pulumi.RegisterOutputType(GroupLevelAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(IotHubOutput{})
	pulumi.RegisterOutputType(IotHubArrayOutput{})
	pulumi.RegisterOutputType(IotHubResponseOutput{})
	pulumi.RegisterOutputType(IotHubResponseArrayOutput{})
	pulumi.RegisterOutputType(JwtAuthenticationOutput{})
	pulumi.RegisterOutputType(JwtAuthenticationPtrOutput{})
	pulumi.RegisterOutputType(JwtAuthenticationResponseOutput{})
	pulumi.RegisterOutputType(JwtAuthenticationResponsePtrOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesPtrOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesResponseOutput{})
	pulumi.RegisterOutputType(KeyVaultPropertiesResponsePtrOutput{})
	pulumi.RegisterOutputType(NetworkAccessControlOutput{})
	pulumi.RegisterOutputType(NetworkAccessControlPtrOutput{})
	pulumi.RegisterOutputType(NetworkAccessControlResponseOutput{})
	pulumi.RegisterOutputType(NetworkAccessControlResponsePtrOutput{})
	pulumi.RegisterOutputType(NodeInputOutput{})
	pulumi.RegisterOutputType(NodeInputArrayOutput{})
	pulumi.RegisterOutputType(NodeInputResponseOutput{})
	pulumi.RegisterOutputType(NodeInputResponseArrayOutput{})
	pulumi.RegisterOutputType(ParameterDeclarationOutput{})
	pulumi.RegisterOutputType(ParameterDeclarationArrayOutput{})
	pulumi.RegisterOutputType(ParameterDeclarationResponseOutput{})
	pulumi.RegisterOutputType(ParameterDeclarationResponseArrayOutput{})
	pulumi.RegisterOutputType(ParameterDefinitionOutput{})
	pulumi.RegisterOutputType(ParameterDefinitionArrayOutput{})
	pulumi.RegisterOutputType(ParameterDefinitionResponseOutput{})
	pulumi.RegisterOutputType(ParameterDefinitionResponseArrayOutput{})
	pulumi.RegisterOutputType(PipelineJobErrorResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointConnectionResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointConnectionResponseArrayOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResponseOutput{})
	pulumi.RegisterOutputType(PrivateEndpointResponsePtrOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateOutput{})
	pulumi.RegisterOutputType(PrivateLinkServiceConnectionStateResponseOutput{})
	pulumi.RegisterOutputType(ResourceIdentityOutput{})
	pulumi.RegisterOutputType(ResourceIdentityPtrOutput{})
	pulumi.RegisterOutputType(ResourceIdentityResponseOutput{})
	pulumi.RegisterOutputType(ResourceIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(SkuOutput{})
	pulumi.RegisterOutputType(SkuResponseOutput{})
	pulumi.RegisterOutputType(StorageAccountOutput{})
	pulumi.RegisterOutputType(StorageAccountArrayOutput{})
	pulumi.RegisterOutputType(StorageAccountResponseOutput{})
	pulumi.RegisterOutputType(StorageAccountResponseArrayOutput{})
	pulumi.RegisterOutputType(SystemDataResponseOutput{})
	pulumi.RegisterOutputType(TokenClaimOutput{})
	pulumi.RegisterOutputType(TokenClaimArrayOutput{})
	pulumi.RegisterOutputType(TokenClaimResponseOutput{})
	pulumi.RegisterOutputType(TokenClaimResponseArrayOutput{})
	pulumi.RegisterOutputType(UserAssignedManagedIdentityResponseOutput{})
	pulumi.RegisterOutputType(UserAssignedManagedIdentityResponseMapOutput{})
	pulumi.RegisterOutputType(VideoAnalyzerIdentityOutput{})
	pulumi.RegisterOutputType(VideoAnalyzerIdentityPtrOutput{})
	pulumi.RegisterOutputType(VideoAnalyzerIdentityResponseOutput{})
	pulumi.RegisterOutputType(VideoAnalyzerIdentityResponsePtrOutput{})
	pulumi.RegisterOutputType(VideoArchivalOutput{})
	pulumi.RegisterOutputType(VideoArchivalPtrOutput{})
	pulumi.RegisterOutputType(VideoArchivalResponseOutput{})
	pulumi.RegisterOutputType(VideoArchivalResponsePtrOutput{})
	pulumi.RegisterOutputType(VideoContentUrlsResponseOutput{})
	pulumi.RegisterOutputType(VideoCreationPropertiesOutput{})
	pulumi.RegisterOutputType(VideoCreationPropertiesPtrOutput{})
	pulumi.RegisterOutputType(VideoCreationPropertiesResponseOutput{})
	pulumi.RegisterOutputType(VideoCreationPropertiesResponsePtrOutput{})
	pulumi.RegisterOutputType(VideoFlagsResponseOutput{})
	pulumi.RegisterOutputType(VideoMediaInfoOutput{})
	pulumi.RegisterOutputType(VideoMediaInfoPtrOutput{})
	pulumi.RegisterOutputType(VideoMediaInfoResponseOutput{})
	pulumi.RegisterOutputType(VideoMediaInfoResponsePtrOutput{})
	pulumi.RegisterOutputType(VideoPreviewImageUrlsResponseOutput{})
	pulumi.RegisterOutputType(VideoPreviewImageUrlsResponsePtrOutput{})
	pulumi.RegisterOutputType(VideoPublishingOptionsOutput{})
	pulumi.RegisterOutputType(VideoPublishingOptionsPtrOutput{})
	pulumi.RegisterOutputType(VideoPublishingOptionsResponseOutput{})
	pulumi.RegisterOutputType(VideoPublishingOptionsResponsePtrOutput{})
	pulumi.RegisterOutputType(VideoSinkOutput{})
	pulumi.RegisterOutputType(VideoSinkArrayOutput{})
	pulumi.RegisterOutputType(VideoSinkResponseOutput{})
	pulumi.RegisterOutputType(VideoSinkResponseArrayOutput{})
}
