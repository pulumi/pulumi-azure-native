// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v20140401

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Autoscale notification.
type AutoscaleNotification struct {
	// the email notification.
	Email *EmailNotification `pulumi:"email"`
	// the operation associated with the notification and its value must be "scale"
	Operation OperationType `pulumi:"operation"`
	// the collection of webhook notifications.
	Webhooks []WebhookNotification `pulumi:"webhooks"`
}

// AutoscaleNotificationInput is an input type that accepts AutoscaleNotificationArgs and AutoscaleNotificationOutput values.
// You can construct a concrete instance of `AutoscaleNotificationInput` via:
//
//          AutoscaleNotificationArgs{...}
type AutoscaleNotificationInput interface {
	pulumi.Input

	ToAutoscaleNotificationOutput() AutoscaleNotificationOutput
	ToAutoscaleNotificationOutputWithContext(context.Context) AutoscaleNotificationOutput
}

// Autoscale notification.
type AutoscaleNotificationArgs struct {
	// the email notification.
	Email EmailNotificationPtrInput `pulumi:"email"`
	// the operation associated with the notification and its value must be "scale"
	Operation OperationTypeInput `pulumi:"operation"`
	// the collection of webhook notifications.
	Webhooks WebhookNotificationArrayInput `pulumi:"webhooks"`
}

func (AutoscaleNotificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoscaleNotification)(nil)).Elem()
}

func (i AutoscaleNotificationArgs) ToAutoscaleNotificationOutput() AutoscaleNotificationOutput {
	return i.ToAutoscaleNotificationOutputWithContext(context.Background())
}

func (i AutoscaleNotificationArgs) ToAutoscaleNotificationOutputWithContext(ctx context.Context) AutoscaleNotificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaleNotificationOutput)
}

// AutoscaleNotificationArrayInput is an input type that accepts AutoscaleNotificationArray and AutoscaleNotificationArrayOutput values.
// You can construct a concrete instance of `AutoscaleNotificationArrayInput` via:
//
//          AutoscaleNotificationArray{ AutoscaleNotificationArgs{...} }
type AutoscaleNotificationArrayInput interface {
	pulumi.Input

	ToAutoscaleNotificationArrayOutput() AutoscaleNotificationArrayOutput
	ToAutoscaleNotificationArrayOutputWithContext(context.Context) AutoscaleNotificationArrayOutput
}

type AutoscaleNotificationArray []AutoscaleNotificationInput

func (AutoscaleNotificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AutoscaleNotification)(nil)).Elem()
}

func (i AutoscaleNotificationArray) ToAutoscaleNotificationArrayOutput() AutoscaleNotificationArrayOutput {
	return i.ToAutoscaleNotificationArrayOutputWithContext(context.Background())
}

func (i AutoscaleNotificationArray) ToAutoscaleNotificationArrayOutputWithContext(ctx context.Context) AutoscaleNotificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaleNotificationArrayOutput)
}

// Autoscale notification.
type AutoscaleNotificationOutput struct{ *pulumi.OutputState }

func (AutoscaleNotificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoscaleNotification)(nil)).Elem()
}

func (o AutoscaleNotificationOutput) ToAutoscaleNotificationOutput() AutoscaleNotificationOutput {
	return o
}

func (o AutoscaleNotificationOutput) ToAutoscaleNotificationOutputWithContext(ctx context.Context) AutoscaleNotificationOutput {
	return o
}

// the email notification.
func (o AutoscaleNotificationOutput) Email() EmailNotificationPtrOutput {
	return o.ApplyT(func(v AutoscaleNotification) *EmailNotification { return v.Email }).(EmailNotificationPtrOutput)
}

// the operation associated with the notification and its value must be "scale"
func (o AutoscaleNotificationOutput) Operation() OperationTypeOutput {
	return o.ApplyT(func(v AutoscaleNotification) OperationType { return v.Operation }).(OperationTypeOutput)
}

// the collection of webhook notifications.
func (o AutoscaleNotificationOutput) Webhooks() WebhookNotificationArrayOutput {
	return o.ApplyT(func(v AutoscaleNotification) []WebhookNotification { return v.Webhooks }).(WebhookNotificationArrayOutput)
}

type AutoscaleNotificationArrayOutput struct{ *pulumi.OutputState }

func (AutoscaleNotificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AutoscaleNotification)(nil)).Elem()
}

func (o AutoscaleNotificationArrayOutput) ToAutoscaleNotificationArrayOutput() AutoscaleNotificationArrayOutput {
	return o
}

func (o AutoscaleNotificationArrayOutput) ToAutoscaleNotificationArrayOutputWithContext(ctx context.Context) AutoscaleNotificationArrayOutput {
	return o
}

func (o AutoscaleNotificationArrayOutput) Index(i pulumi.IntInput) AutoscaleNotificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AutoscaleNotification {
		return vs[0].([]AutoscaleNotification)[vs[1].(int)]
	}).(AutoscaleNotificationOutput)
}

// Autoscale notification.
type AutoscaleNotificationResponse struct {
	// the email notification.
	Email *EmailNotificationResponse `pulumi:"email"`
	// the operation associated with the notification and its value must be "scale"
	Operation string `pulumi:"operation"`
	// the collection of webhook notifications.
	Webhooks []WebhookNotificationResponse `pulumi:"webhooks"`
}

// AutoscaleNotificationResponseInput is an input type that accepts AutoscaleNotificationResponseArgs and AutoscaleNotificationResponseOutput values.
// You can construct a concrete instance of `AutoscaleNotificationResponseInput` via:
//
//          AutoscaleNotificationResponseArgs{...}
type AutoscaleNotificationResponseInput interface {
	pulumi.Input

	ToAutoscaleNotificationResponseOutput() AutoscaleNotificationResponseOutput
	ToAutoscaleNotificationResponseOutputWithContext(context.Context) AutoscaleNotificationResponseOutput
}

// Autoscale notification.
type AutoscaleNotificationResponseArgs struct {
	// the email notification.
	Email EmailNotificationResponsePtrInput `pulumi:"email"`
	// the operation associated with the notification and its value must be "scale"
	Operation pulumi.StringInput `pulumi:"operation"`
	// the collection of webhook notifications.
	Webhooks WebhookNotificationResponseArrayInput `pulumi:"webhooks"`
}

func (AutoscaleNotificationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoscaleNotificationResponse)(nil)).Elem()
}

func (i AutoscaleNotificationResponseArgs) ToAutoscaleNotificationResponseOutput() AutoscaleNotificationResponseOutput {
	return i.ToAutoscaleNotificationResponseOutputWithContext(context.Background())
}

func (i AutoscaleNotificationResponseArgs) ToAutoscaleNotificationResponseOutputWithContext(ctx context.Context) AutoscaleNotificationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaleNotificationResponseOutput)
}

// AutoscaleNotificationResponseArrayInput is an input type that accepts AutoscaleNotificationResponseArray and AutoscaleNotificationResponseArrayOutput values.
// You can construct a concrete instance of `AutoscaleNotificationResponseArrayInput` via:
//
//          AutoscaleNotificationResponseArray{ AutoscaleNotificationResponseArgs{...} }
type AutoscaleNotificationResponseArrayInput interface {
	pulumi.Input

	ToAutoscaleNotificationResponseArrayOutput() AutoscaleNotificationResponseArrayOutput
	ToAutoscaleNotificationResponseArrayOutputWithContext(context.Context) AutoscaleNotificationResponseArrayOutput
}

type AutoscaleNotificationResponseArray []AutoscaleNotificationResponseInput

func (AutoscaleNotificationResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AutoscaleNotificationResponse)(nil)).Elem()
}

func (i AutoscaleNotificationResponseArray) ToAutoscaleNotificationResponseArrayOutput() AutoscaleNotificationResponseArrayOutput {
	return i.ToAutoscaleNotificationResponseArrayOutputWithContext(context.Background())
}

func (i AutoscaleNotificationResponseArray) ToAutoscaleNotificationResponseArrayOutputWithContext(ctx context.Context) AutoscaleNotificationResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaleNotificationResponseArrayOutput)
}

// Autoscale notification.
type AutoscaleNotificationResponseOutput struct{ *pulumi.OutputState }

func (AutoscaleNotificationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoscaleNotificationResponse)(nil)).Elem()
}

func (o AutoscaleNotificationResponseOutput) ToAutoscaleNotificationResponseOutput() AutoscaleNotificationResponseOutput {
	return o
}

func (o AutoscaleNotificationResponseOutput) ToAutoscaleNotificationResponseOutputWithContext(ctx context.Context) AutoscaleNotificationResponseOutput {
	return o
}

// the email notification.
func (o AutoscaleNotificationResponseOutput) Email() EmailNotificationResponsePtrOutput {
	return o.ApplyT(func(v AutoscaleNotificationResponse) *EmailNotificationResponse { return v.Email }).(EmailNotificationResponsePtrOutput)
}

// the operation associated with the notification and its value must be "scale"
func (o AutoscaleNotificationResponseOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v AutoscaleNotificationResponse) string { return v.Operation }).(pulumi.StringOutput)
}

// the collection of webhook notifications.
func (o AutoscaleNotificationResponseOutput) Webhooks() WebhookNotificationResponseArrayOutput {
	return o.ApplyT(func(v AutoscaleNotificationResponse) []WebhookNotificationResponse { return v.Webhooks }).(WebhookNotificationResponseArrayOutput)
}

type AutoscaleNotificationResponseArrayOutput struct{ *pulumi.OutputState }

func (AutoscaleNotificationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AutoscaleNotificationResponse)(nil)).Elem()
}

func (o AutoscaleNotificationResponseArrayOutput) ToAutoscaleNotificationResponseArrayOutput() AutoscaleNotificationResponseArrayOutput {
	return o
}

func (o AutoscaleNotificationResponseArrayOutput) ToAutoscaleNotificationResponseArrayOutputWithContext(ctx context.Context) AutoscaleNotificationResponseArrayOutput {
	return o
}

func (o AutoscaleNotificationResponseArrayOutput) Index(i pulumi.IntInput) AutoscaleNotificationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AutoscaleNotificationResponse {
		return vs[0].([]AutoscaleNotificationResponse)[vs[1].(int)]
	}).(AutoscaleNotificationResponseOutput)
}

// Autoscale profile.
type AutoscaleProfile struct {
	// the number of instances that can be used during this profile.
	Capacity ScaleCapacity `pulumi:"capacity"`
	// the specific date-time for the profile. This element is not used if the Recurrence element is used.
	FixedDate *TimeWindow `pulumi:"fixedDate"`
	// the name of the profile.
	Name string `pulumi:"name"`
	// the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
	Recurrence *Recurrence `pulumi:"recurrence"`
	// the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
	Rules []ScaleRule `pulumi:"rules"`
}

// AutoscaleProfileInput is an input type that accepts AutoscaleProfileArgs and AutoscaleProfileOutput values.
// You can construct a concrete instance of `AutoscaleProfileInput` via:
//
//          AutoscaleProfileArgs{...}
type AutoscaleProfileInput interface {
	pulumi.Input

	ToAutoscaleProfileOutput() AutoscaleProfileOutput
	ToAutoscaleProfileOutputWithContext(context.Context) AutoscaleProfileOutput
}

// Autoscale profile.
type AutoscaleProfileArgs struct {
	// the number of instances that can be used during this profile.
	Capacity ScaleCapacityInput `pulumi:"capacity"`
	// the specific date-time for the profile. This element is not used if the Recurrence element is used.
	FixedDate TimeWindowPtrInput `pulumi:"fixedDate"`
	// the name of the profile.
	Name pulumi.StringInput `pulumi:"name"`
	// the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
	Recurrence RecurrencePtrInput `pulumi:"recurrence"`
	// the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
	Rules ScaleRuleArrayInput `pulumi:"rules"`
}

func (AutoscaleProfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoscaleProfile)(nil)).Elem()
}

func (i AutoscaleProfileArgs) ToAutoscaleProfileOutput() AutoscaleProfileOutput {
	return i.ToAutoscaleProfileOutputWithContext(context.Background())
}

func (i AutoscaleProfileArgs) ToAutoscaleProfileOutputWithContext(ctx context.Context) AutoscaleProfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaleProfileOutput)
}

// AutoscaleProfileArrayInput is an input type that accepts AutoscaleProfileArray and AutoscaleProfileArrayOutput values.
// You can construct a concrete instance of `AutoscaleProfileArrayInput` via:
//
//          AutoscaleProfileArray{ AutoscaleProfileArgs{...} }
type AutoscaleProfileArrayInput interface {
	pulumi.Input

	ToAutoscaleProfileArrayOutput() AutoscaleProfileArrayOutput
	ToAutoscaleProfileArrayOutputWithContext(context.Context) AutoscaleProfileArrayOutput
}

type AutoscaleProfileArray []AutoscaleProfileInput

func (AutoscaleProfileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AutoscaleProfile)(nil)).Elem()
}

func (i AutoscaleProfileArray) ToAutoscaleProfileArrayOutput() AutoscaleProfileArrayOutput {
	return i.ToAutoscaleProfileArrayOutputWithContext(context.Background())
}

func (i AutoscaleProfileArray) ToAutoscaleProfileArrayOutputWithContext(ctx context.Context) AutoscaleProfileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaleProfileArrayOutput)
}

// Autoscale profile.
type AutoscaleProfileOutput struct{ *pulumi.OutputState }

func (AutoscaleProfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoscaleProfile)(nil)).Elem()
}

func (o AutoscaleProfileOutput) ToAutoscaleProfileOutput() AutoscaleProfileOutput {
	return o
}

func (o AutoscaleProfileOutput) ToAutoscaleProfileOutputWithContext(ctx context.Context) AutoscaleProfileOutput {
	return o
}

// the number of instances that can be used during this profile.
func (o AutoscaleProfileOutput) Capacity() ScaleCapacityOutput {
	return o.ApplyT(func(v AutoscaleProfile) ScaleCapacity { return v.Capacity }).(ScaleCapacityOutput)
}

// the specific date-time for the profile. This element is not used if the Recurrence element is used.
func (o AutoscaleProfileOutput) FixedDate() TimeWindowPtrOutput {
	return o.ApplyT(func(v AutoscaleProfile) *TimeWindow { return v.FixedDate }).(TimeWindowPtrOutput)
}

// the name of the profile.
func (o AutoscaleProfileOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AutoscaleProfile) string { return v.Name }).(pulumi.StringOutput)
}

// the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
func (o AutoscaleProfileOutput) Recurrence() RecurrencePtrOutput {
	return o.ApplyT(func(v AutoscaleProfile) *Recurrence { return v.Recurrence }).(RecurrencePtrOutput)
}

// the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
func (o AutoscaleProfileOutput) Rules() ScaleRuleArrayOutput {
	return o.ApplyT(func(v AutoscaleProfile) []ScaleRule { return v.Rules }).(ScaleRuleArrayOutput)
}

type AutoscaleProfileArrayOutput struct{ *pulumi.OutputState }

func (AutoscaleProfileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AutoscaleProfile)(nil)).Elem()
}

func (o AutoscaleProfileArrayOutput) ToAutoscaleProfileArrayOutput() AutoscaleProfileArrayOutput {
	return o
}

func (o AutoscaleProfileArrayOutput) ToAutoscaleProfileArrayOutputWithContext(ctx context.Context) AutoscaleProfileArrayOutput {
	return o
}

func (o AutoscaleProfileArrayOutput) Index(i pulumi.IntInput) AutoscaleProfileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AutoscaleProfile {
		return vs[0].([]AutoscaleProfile)[vs[1].(int)]
	}).(AutoscaleProfileOutput)
}

// Autoscale profile.
type AutoscaleProfileResponse struct {
	// the number of instances that can be used during this profile.
	Capacity ScaleCapacityResponse `pulumi:"capacity"`
	// the specific date-time for the profile. This element is not used if the Recurrence element is used.
	FixedDate *TimeWindowResponse `pulumi:"fixedDate"`
	// the name of the profile.
	Name string `pulumi:"name"`
	// the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
	Recurrence *RecurrenceResponse `pulumi:"recurrence"`
	// the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
	Rules []ScaleRuleResponse `pulumi:"rules"`
}

// AutoscaleProfileResponseInput is an input type that accepts AutoscaleProfileResponseArgs and AutoscaleProfileResponseOutput values.
// You can construct a concrete instance of `AutoscaleProfileResponseInput` via:
//
//          AutoscaleProfileResponseArgs{...}
type AutoscaleProfileResponseInput interface {
	pulumi.Input

	ToAutoscaleProfileResponseOutput() AutoscaleProfileResponseOutput
	ToAutoscaleProfileResponseOutputWithContext(context.Context) AutoscaleProfileResponseOutput
}

// Autoscale profile.
type AutoscaleProfileResponseArgs struct {
	// the number of instances that can be used during this profile.
	Capacity ScaleCapacityResponseInput `pulumi:"capacity"`
	// the specific date-time for the profile. This element is not used if the Recurrence element is used.
	FixedDate TimeWindowResponsePtrInput `pulumi:"fixedDate"`
	// the name of the profile.
	Name pulumi.StringInput `pulumi:"name"`
	// the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
	Recurrence RecurrenceResponsePtrInput `pulumi:"recurrence"`
	// the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
	Rules ScaleRuleResponseArrayInput `pulumi:"rules"`
}

func (AutoscaleProfileResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoscaleProfileResponse)(nil)).Elem()
}

func (i AutoscaleProfileResponseArgs) ToAutoscaleProfileResponseOutput() AutoscaleProfileResponseOutput {
	return i.ToAutoscaleProfileResponseOutputWithContext(context.Background())
}

func (i AutoscaleProfileResponseArgs) ToAutoscaleProfileResponseOutputWithContext(ctx context.Context) AutoscaleProfileResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaleProfileResponseOutput)
}

// AutoscaleProfileResponseArrayInput is an input type that accepts AutoscaleProfileResponseArray and AutoscaleProfileResponseArrayOutput values.
// You can construct a concrete instance of `AutoscaleProfileResponseArrayInput` via:
//
//          AutoscaleProfileResponseArray{ AutoscaleProfileResponseArgs{...} }
type AutoscaleProfileResponseArrayInput interface {
	pulumi.Input

	ToAutoscaleProfileResponseArrayOutput() AutoscaleProfileResponseArrayOutput
	ToAutoscaleProfileResponseArrayOutputWithContext(context.Context) AutoscaleProfileResponseArrayOutput
}

type AutoscaleProfileResponseArray []AutoscaleProfileResponseInput

func (AutoscaleProfileResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AutoscaleProfileResponse)(nil)).Elem()
}

func (i AutoscaleProfileResponseArray) ToAutoscaleProfileResponseArrayOutput() AutoscaleProfileResponseArrayOutput {
	return i.ToAutoscaleProfileResponseArrayOutputWithContext(context.Background())
}

func (i AutoscaleProfileResponseArray) ToAutoscaleProfileResponseArrayOutputWithContext(ctx context.Context) AutoscaleProfileResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutoscaleProfileResponseArrayOutput)
}

// Autoscale profile.
type AutoscaleProfileResponseOutput struct{ *pulumi.OutputState }

func (AutoscaleProfileResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AutoscaleProfileResponse)(nil)).Elem()
}

func (o AutoscaleProfileResponseOutput) ToAutoscaleProfileResponseOutput() AutoscaleProfileResponseOutput {
	return o
}

func (o AutoscaleProfileResponseOutput) ToAutoscaleProfileResponseOutputWithContext(ctx context.Context) AutoscaleProfileResponseOutput {
	return o
}

// the number of instances that can be used during this profile.
func (o AutoscaleProfileResponseOutput) Capacity() ScaleCapacityResponseOutput {
	return o.ApplyT(func(v AutoscaleProfileResponse) ScaleCapacityResponse { return v.Capacity }).(ScaleCapacityResponseOutput)
}

// the specific date-time for the profile. This element is not used if the Recurrence element is used.
func (o AutoscaleProfileResponseOutput) FixedDate() TimeWindowResponsePtrOutput {
	return o.ApplyT(func(v AutoscaleProfileResponse) *TimeWindowResponse { return v.FixedDate }).(TimeWindowResponsePtrOutput)
}

// the name of the profile.
func (o AutoscaleProfileResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AutoscaleProfileResponse) string { return v.Name }).(pulumi.StringOutput)
}

// the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
func (o AutoscaleProfileResponseOutput) Recurrence() RecurrenceResponsePtrOutput {
	return o.ApplyT(func(v AutoscaleProfileResponse) *RecurrenceResponse { return v.Recurrence }).(RecurrenceResponsePtrOutput)
}

// the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified.
func (o AutoscaleProfileResponseOutput) Rules() ScaleRuleResponseArrayOutput {
	return o.ApplyT(func(v AutoscaleProfileResponse) []ScaleRuleResponse { return v.Rules }).(ScaleRuleResponseArrayOutput)
}

type AutoscaleProfileResponseArrayOutput struct{ *pulumi.OutputState }

func (AutoscaleProfileResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AutoscaleProfileResponse)(nil)).Elem()
}

func (o AutoscaleProfileResponseArrayOutput) ToAutoscaleProfileResponseArrayOutput() AutoscaleProfileResponseArrayOutput {
	return o
}

func (o AutoscaleProfileResponseArrayOutput) ToAutoscaleProfileResponseArrayOutputWithContext(ctx context.Context) AutoscaleProfileResponseArrayOutput {
	return o
}

func (o AutoscaleProfileResponseArrayOutput) Index(i pulumi.IntInput) AutoscaleProfileResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AutoscaleProfileResponse {
		return vs[0].([]AutoscaleProfileResponse)[vs[1].(int)]
	}).(AutoscaleProfileResponseOutput)
}

// Email notification of an autoscale event.
type EmailNotification struct {
	// the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
	CustomEmails []string `pulumi:"customEmails"`
	// a value indicating whether to send email to subscription administrator.
	SendToSubscriptionAdministrator *bool `pulumi:"sendToSubscriptionAdministrator"`
	// a value indicating whether to send email to subscription co-administrators.
	SendToSubscriptionCoAdministrators *bool `pulumi:"sendToSubscriptionCoAdministrators"`
}

// EmailNotificationInput is an input type that accepts EmailNotificationArgs and EmailNotificationOutput values.
// You can construct a concrete instance of `EmailNotificationInput` via:
//
//          EmailNotificationArgs{...}
type EmailNotificationInput interface {
	pulumi.Input

	ToEmailNotificationOutput() EmailNotificationOutput
	ToEmailNotificationOutputWithContext(context.Context) EmailNotificationOutput
}

// Email notification of an autoscale event.
type EmailNotificationArgs struct {
	// the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
	CustomEmails pulumi.StringArrayInput `pulumi:"customEmails"`
	// a value indicating whether to send email to subscription administrator.
	SendToSubscriptionAdministrator pulumi.BoolPtrInput `pulumi:"sendToSubscriptionAdministrator"`
	// a value indicating whether to send email to subscription co-administrators.
	SendToSubscriptionCoAdministrators pulumi.BoolPtrInput `pulumi:"sendToSubscriptionCoAdministrators"`
}

func (EmailNotificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EmailNotification)(nil)).Elem()
}

func (i EmailNotificationArgs) ToEmailNotificationOutput() EmailNotificationOutput {
	return i.ToEmailNotificationOutputWithContext(context.Background())
}

func (i EmailNotificationArgs) ToEmailNotificationOutputWithContext(ctx context.Context) EmailNotificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmailNotificationOutput)
}

func (i EmailNotificationArgs) ToEmailNotificationPtrOutput() EmailNotificationPtrOutput {
	return i.ToEmailNotificationPtrOutputWithContext(context.Background())
}

func (i EmailNotificationArgs) ToEmailNotificationPtrOutputWithContext(ctx context.Context) EmailNotificationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmailNotificationOutput).ToEmailNotificationPtrOutputWithContext(ctx)
}

// EmailNotificationPtrInput is an input type that accepts EmailNotificationArgs, EmailNotificationPtr and EmailNotificationPtrOutput values.
// You can construct a concrete instance of `EmailNotificationPtrInput` via:
//
//          EmailNotificationArgs{...}
//
//  or:
//
//          nil
type EmailNotificationPtrInput interface {
	pulumi.Input

	ToEmailNotificationPtrOutput() EmailNotificationPtrOutput
	ToEmailNotificationPtrOutputWithContext(context.Context) EmailNotificationPtrOutput
}

type emailNotificationPtrType EmailNotificationArgs

func EmailNotificationPtr(v *EmailNotificationArgs) EmailNotificationPtrInput {
	return (*emailNotificationPtrType)(v)
}

func (*emailNotificationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EmailNotification)(nil)).Elem()
}

func (i *emailNotificationPtrType) ToEmailNotificationPtrOutput() EmailNotificationPtrOutput {
	return i.ToEmailNotificationPtrOutputWithContext(context.Background())
}

func (i *emailNotificationPtrType) ToEmailNotificationPtrOutputWithContext(ctx context.Context) EmailNotificationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmailNotificationPtrOutput)
}

// Email notification of an autoscale event.
type EmailNotificationOutput struct{ *pulumi.OutputState }

func (EmailNotificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EmailNotification)(nil)).Elem()
}

func (o EmailNotificationOutput) ToEmailNotificationOutput() EmailNotificationOutput {
	return o
}

func (o EmailNotificationOutput) ToEmailNotificationOutputWithContext(ctx context.Context) EmailNotificationOutput {
	return o
}

func (o EmailNotificationOutput) ToEmailNotificationPtrOutput() EmailNotificationPtrOutput {
	return o.ToEmailNotificationPtrOutputWithContext(context.Background())
}

func (o EmailNotificationOutput) ToEmailNotificationPtrOutputWithContext(ctx context.Context) EmailNotificationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EmailNotification) *EmailNotification {
		return &v
	}).(EmailNotificationPtrOutput)
}

// the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
func (o EmailNotificationOutput) CustomEmails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v EmailNotification) []string { return v.CustomEmails }).(pulumi.StringArrayOutput)
}

// a value indicating whether to send email to subscription administrator.
func (o EmailNotificationOutput) SendToSubscriptionAdministrator() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EmailNotification) *bool { return v.SendToSubscriptionAdministrator }).(pulumi.BoolPtrOutput)
}

// a value indicating whether to send email to subscription co-administrators.
func (o EmailNotificationOutput) SendToSubscriptionCoAdministrators() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EmailNotification) *bool { return v.SendToSubscriptionCoAdministrators }).(pulumi.BoolPtrOutput)
}

type EmailNotificationPtrOutput struct{ *pulumi.OutputState }

func (EmailNotificationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EmailNotification)(nil)).Elem()
}

func (o EmailNotificationPtrOutput) ToEmailNotificationPtrOutput() EmailNotificationPtrOutput {
	return o
}

func (o EmailNotificationPtrOutput) ToEmailNotificationPtrOutputWithContext(ctx context.Context) EmailNotificationPtrOutput {
	return o
}

func (o EmailNotificationPtrOutput) Elem() EmailNotificationOutput {
	return o.ApplyT(func(v *EmailNotification) EmailNotification {
		if v != nil {
			return *v
		}
		var ret EmailNotification
		return ret
	}).(EmailNotificationOutput)
}

// the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
func (o EmailNotificationPtrOutput) CustomEmails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *EmailNotification) []string {
		if v == nil {
			return nil
		}
		return v.CustomEmails
	}).(pulumi.StringArrayOutput)
}

// a value indicating whether to send email to subscription administrator.
func (o EmailNotificationPtrOutput) SendToSubscriptionAdministrator() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EmailNotification) *bool {
		if v == nil {
			return nil
		}
		return v.SendToSubscriptionAdministrator
	}).(pulumi.BoolPtrOutput)
}

// a value indicating whether to send email to subscription co-administrators.
func (o EmailNotificationPtrOutput) SendToSubscriptionCoAdministrators() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EmailNotification) *bool {
		if v == nil {
			return nil
		}
		return v.SendToSubscriptionCoAdministrators
	}).(pulumi.BoolPtrOutput)
}

// Email notification of an autoscale event.
type EmailNotificationResponse struct {
	// the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
	CustomEmails []string `pulumi:"customEmails"`
	// a value indicating whether to send email to subscription administrator.
	SendToSubscriptionAdministrator *bool `pulumi:"sendToSubscriptionAdministrator"`
	// a value indicating whether to send email to subscription co-administrators.
	SendToSubscriptionCoAdministrators *bool `pulumi:"sendToSubscriptionCoAdministrators"`
}

// EmailNotificationResponseInput is an input type that accepts EmailNotificationResponseArgs and EmailNotificationResponseOutput values.
// You can construct a concrete instance of `EmailNotificationResponseInput` via:
//
//          EmailNotificationResponseArgs{...}
type EmailNotificationResponseInput interface {
	pulumi.Input

	ToEmailNotificationResponseOutput() EmailNotificationResponseOutput
	ToEmailNotificationResponseOutputWithContext(context.Context) EmailNotificationResponseOutput
}

// Email notification of an autoscale event.
type EmailNotificationResponseArgs struct {
	// the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
	CustomEmails pulumi.StringArrayInput `pulumi:"customEmails"`
	// a value indicating whether to send email to subscription administrator.
	SendToSubscriptionAdministrator pulumi.BoolPtrInput `pulumi:"sendToSubscriptionAdministrator"`
	// a value indicating whether to send email to subscription co-administrators.
	SendToSubscriptionCoAdministrators pulumi.BoolPtrInput `pulumi:"sendToSubscriptionCoAdministrators"`
}

func (EmailNotificationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EmailNotificationResponse)(nil)).Elem()
}

func (i EmailNotificationResponseArgs) ToEmailNotificationResponseOutput() EmailNotificationResponseOutput {
	return i.ToEmailNotificationResponseOutputWithContext(context.Background())
}

func (i EmailNotificationResponseArgs) ToEmailNotificationResponseOutputWithContext(ctx context.Context) EmailNotificationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmailNotificationResponseOutput)
}

func (i EmailNotificationResponseArgs) ToEmailNotificationResponsePtrOutput() EmailNotificationResponsePtrOutput {
	return i.ToEmailNotificationResponsePtrOutputWithContext(context.Background())
}

func (i EmailNotificationResponseArgs) ToEmailNotificationResponsePtrOutputWithContext(ctx context.Context) EmailNotificationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmailNotificationResponseOutput).ToEmailNotificationResponsePtrOutputWithContext(ctx)
}

// EmailNotificationResponsePtrInput is an input type that accepts EmailNotificationResponseArgs, EmailNotificationResponsePtr and EmailNotificationResponsePtrOutput values.
// You can construct a concrete instance of `EmailNotificationResponsePtrInput` via:
//
//          EmailNotificationResponseArgs{...}
//
//  or:
//
//          nil
type EmailNotificationResponsePtrInput interface {
	pulumi.Input

	ToEmailNotificationResponsePtrOutput() EmailNotificationResponsePtrOutput
	ToEmailNotificationResponsePtrOutputWithContext(context.Context) EmailNotificationResponsePtrOutput
}

type emailNotificationResponsePtrType EmailNotificationResponseArgs

func EmailNotificationResponsePtr(v *EmailNotificationResponseArgs) EmailNotificationResponsePtrInput {
	return (*emailNotificationResponsePtrType)(v)
}

func (*emailNotificationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EmailNotificationResponse)(nil)).Elem()
}

func (i *emailNotificationResponsePtrType) ToEmailNotificationResponsePtrOutput() EmailNotificationResponsePtrOutput {
	return i.ToEmailNotificationResponsePtrOutputWithContext(context.Background())
}

func (i *emailNotificationResponsePtrType) ToEmailNotificationResponsePtrOutputWithContext(ctx context.Context) EmailNotificationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmailNotificationResponsePtrOutput)
}

// Email notification of an autoscale event.
type EmailNotificationResponseOutput struct{ *pulumi.OutputState }

func (EmailNotificationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EmailNotificationResponse)(nil)).Elem()
}

func (o EmailNotificationResponseOutput) ToEmailNotificationResponseOutput() EmailNotificationResponseOutput {
	return o
}

func (o EmailNotificationResponseOutput) ToEmailNotificationResponseOutputWithContext(ctx context.Context) EmailNotificationResponseOutput {
	return o
}

func (o EmailNotificationResponseOutput) ToEmailNotificationResponsePtrOutput() EmailNotificationResponsePtrOutput {
	return o.ToEmailNotificationResponsePtrOutputWithContext(context.Background())
}

func (o EmailNotificationResponseOutput) ToEmailNotificationResponsePtrOutputWithContext(ctx context.Context) EmailNotificationResponsePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EmailNotificationResponse) *EmailNotificationResponse {
		return &v
	}).(EmailNotificationResponsePtrOutput)
}

// the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
func (o EmailNotificationResponseOutput) CustomEmails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v EmailNotificationResponse) []string { return v.CustomEmails }).(pulumi.StringArrayOutput)
}

// a value indicating whether to send email to subscription administrator.
func (o EmailNotificationResponseOutput) SendToSubscriptionAdministrator() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EmailNotificationResponse) *bool { return v.SendToSubscriptionAdministrator }).(pulumi.BoolPtrOutput)
}

// a value indicating whether to send email to subscription co-administrators.
func (o EmailNotificationResponseOutput) SendToSubscriptionCoAdministrators() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v EmailNotificationResponse) *bool { return v.SendToSubscriptionCoAdministrators }).(pulumi.BoolPtrOutput)
}

type EmailNotificationResponsePtrOutput struct{ *pulumi.OutputState }

func (EmailNotificationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EmailNotificationResponse)(nil)).Elem()
}

func (o EmailNotificationResponsePtrOutput) ToEmailNotificationResponsePtrOutput() EmailNotificationResponsePtrOutput {
	return o
}

func (o EmailNotificationResponsePtrOutput) ToEmailNotificationResponsePtrOutputWithContext(ctx context.Context) EmailNotificationResponsePtrOutput {
	return o
}

func (o EmailNotificationResponsePtrOutput) Elem() EmailNotificationResponseOutput {
	return o.ApplyT(func(v *EmailNotificationResponse) EmailNotificationResponse {
		if v != nil {
			return *v
		}
		var ret EmailNotificationResponse
		return ret
	}).(EmailNotificationResponseOutput)
}

// the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
func (o EmailNotificationResponsePtrOutput) CustomEmails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *EmailNotificationResponse) []string {
		if v == nil {
			return nil
		}
		return v.CustomEmails
	}).(pulumi.StringArrayOutput)
}

// a value indicating whether to send email to subscription administrator.
func (o EmailNotificationResponsePtrOutput) SendToSubscriptionAdministrator() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EmailNotificationResponse) *bool {
		if v == nil {
			return nil
		}
		return v.SendToSubscriptionAdministrator
	}).(pulumi.BoolPtrOutput)
}

// a value indicating whether to send email to subscription co-administrators.
func (o EmailNotificationResponsePtrOutput) SendToSubscriptionCoAdministrators() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *EmailNotificationResponse) *bool {
		if v == nil {
			return nil
		}
		return v.SendToSubscriptionCoAdministrators
	}).(pulumi.BoolPtrOutput)
}

// A rule condition based on a certain number of locations failing.
type LocationThresholdRuleCondition struct {
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource interface{} `pulumi:"dataSource"`
	// the number of locations that must fail to activate the alert.
	FailedLocationCount int `pulumi:"failedLocationCount"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition'.
	OdataType string `pulumi:"odataType"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize *string `pulumi:"windowSize"`
}

// LocationThresholdRuleConditionInput is an input type that accepts LocationThresholdRuleConditionArgs and LocationThresholdRuleConditionOutput values.
// You can construct a concrete instance of `LocationThresholdRuleConditionInput` via:
//
//          LocationThresholdRuleConditionArgs{...}
type LocationThresholdRuleConditionInput interface {
	pulumi.Input

	ToLocationThresholdRuleConditionOutput() LocationThresholdRuleConditionOutput
	ToLocationThresholdRuleConditionOutputWithContext(context.Context) LocationThresholdRuleConditionOutput
}

// A rule condition based on a certain number of locations failing.
type LocationThresholdRuleConditionArgs struct {
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource pulumi.Input `pulumi:"dataSource"`
	// the number of locations that must fail to activate the alert.
	FailedLocationCount pulumi.IntInput `pulumi:"failedLocationCount"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize pulumi.StringPtrInput `pulumi:"windowSize"`
}

func (LocationThresholdRuleConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationThresholdRuleCondition)(nil)).Elem()
}

func (i LocationThresholdRuleConditionArgs) ToLocationThresholdRuleConditionOutput() LocationThresholdRuleConditionOutput {
	return i.ToLocationThresholdRuleConditionOutputWithContext(context.Background())
}

func (i LocationThresholdRuleConditionArgs) ToLocationThresholdRuleConditionOutputWithContext(ctx context.Context) LocationThresholdRuleConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationThresholdRuleConditionOutput)
}

// A rule condition based on a certain number of locations failing.
type LocationThresholdRuleConditionOutput struct{ *pulumi.OutputState }

func (LocationThresholdRuleConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationThresholdRuleCondition)(nil)).Elem()
}

func (o LocationThresholdRuleConditionOutput) ToLocationThresholdRuleConditionOutput() LocationThresholdRuleConditionOutput {
	return o
}

func (o LocationThresholdRuleConditionOutput) ToLocationThresholdRuleConditionOutputWithContext(ctx context.Context) LocationThresholdRuleConditionOutput {
	return o
}

// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
func (o LocationThresholdRuleConditionOutput) DataSource() pulumi.AnyOutput {
	return o.ApplyT(func(v LocationThresholdRuleCondition) interface{} { return v.DataSource }).(pulumi.AnyOutput)
}

// the number of locations that must fail to activate the alert.
func (o LocationThresholdRuleConditionOutput) FailedLocationCount() pulumi.IntOutput {
	return o.ApplyT(func(v LocationThresholdRuleCondition) int { return v.FailedLocationCount }).(pulumi.IntOutput)
}

// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
// Expected value is 'Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition'.
func (o LocationThresholdRuleConditionOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v LocationThresholdRuleCondition) string { return v.OdataType }).(pulumi.StringOutput)
}

// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
func (o LocationThresholdRuleConditionOutput) WindowSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LocationThresholdRuleCondition) *string { return v.WindowSize }).(pulumi.StringPtrOutput)
}

// A rule condition based on a certain number of locations failing.
type LocationThresholdRuleConditionResponse struct {
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource interface{} `pulumi:"dataSource"`
	// the number of locations that must fail to activate the alert.
	FailedLocationCount int `pulumi:"failedLocationCount"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition'.
	OdataType string `pulumi:"odataType"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize *string `pulumi:"windowSize"`
}

// LocationThresholdRuleConditionResponseInput is an input type that accepts LocationThresholdRuleConditionResponseArgs and LocationThresholdRuleConditionResponseOutput values.
// You can construct a concrete instance of `LocationThresholdRuleConditionResponseInput` via:
//
//          LocationThresholdRuleConditionResponseArgs{...}
type LocationThresholdRuleConditionResponseInput interface {
	pulumi.Input

	ToLocationThresholdRuleConditionResponseOutput() LocationThresholdRuleConditionResponseOutput
	ToLocationThresholdRuleConditionResponseOutputWithContext(context.Context) LocationThresholdRuleConditionResponseOutput
}

// A rule condition based on a certain number of locations failing.
type LocationThresholdRuleConditionResponseArgs struct {
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource pulumi.Input `pulumi:"dataSource"`
	// the number of locations that must fail to activate the alert.
	FailedLocationCount pulumi.IntInput `pulumi:"failedLocationCount"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize pulumi.StringPtrInput `pulumi:"windowSize"`
}

func (LocationThresholdRuleConditionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationThresholdRuleConditionResponse)(nil)).Elem()
}

func (i LocationThresholdRuleConditionResponseArgs) ToLocationThresholdRuleConditionResponseOutput() LocationThresholdRuleConditionResponseOutput {
	return i.ToLocationThresholdRuleConditionResponseOutputWithContext(context.Background())
}

func (i LocationThresholdRuleConditionResponseArgs) ToLocationThresholdRuleConditionResponseOutputWithContext(ctx context.Context) LocationThresholdRuleConditionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationThresholdRuleConditionResponseOutput)
}

// A rule condition based on a certain number of locations failing.
type LocationThresholdRuleConditionResponseOutput struct{ *pulumi.OutputState }

func (LocationThresholdRuleConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationThresholdRuleConditionResponse)(nil)).Elem()
}

func (o LocationThresholdRuleConditionResponseOutput) ToLocationThresholdRuleConditionResponseOutput() LocationThresholdRuleConditionResponseOutput {
	return o
}

func (o LocationThresholdRuleConditionResponseOutput) ToLocationThresholdRuleConditionResponseOutputWithContext(ctx context.Context) LocationThresholdRuleConditionResponseOutput {
	return o
}

// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
func (o LocationThresholdRuleConditionResponseOutput) DataSource() pulumi.AnyOutput {
	return o.ApplyT(func(v LocationThresholdRuleConditionResponse) interface{} { return v.DataSource }).(pulumi.AnyOutput)
}

// the number of locations that must fail to activate the alert.
func (o LocationThresholdRuleConditionResponseOutput) FailedLocationCount() pulumi.IntOutput {
	return o.ApplyT(func(v LocationThresholdRuleConditionResponse) int { return v.FailedLocationCount }).(pulumi.IntOutput)
}

// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
// Expected value is 'Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition'.
func (o LocationThresholdRuleConditionResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v LocationThresholdRuleConditionResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
func (o LocationThresholdRuleConditionResponseOutput) WindowSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LocationThresholdRuleConditionResponse) *string { return v.WindowSize }).(pulumi.StringPtrOutput)
}

// How the data that is collected should be combined over time.
type ManagementEventAggregationCondition struct {
	// the condition operator.
	Operator *ConditionOperator `pulumi:"operator"`
	// The threshold value that activates the alert.
	Threshold *float64 `pulumi:"threshold"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize *string `pulumi:"windowSize"`
}

// ManagementEventAggregationConditionInput is an input type that accepts ManagementEventAggregationConditionArgs and ManagementEventAggregationConditionOutput values.
// You can construct a concrete instance of `ManagementEventAggregationConditionInput` via:
//
//          ManagementEventAggregationConditionArgs{...}
type ManagementEventAggregationConditionInput interface {
	pulumi.Input

	ToManagementEventAggregationConditionOutput() ManagementEventAggregationConditionOutput
	ToManagementEventAggregationConditionOutputWithContext(context.Context) ManagementEventAggregationConditionOutput
}

// How the data that is collected should be combined over time.
type ManagementEventAggregationConditionArgs struct {
	// the condition operator.
	Operator ConditionOperatorPtrInput `pulumi:"operator"`
	// The threshold value that activates the alert.
	Threshold pulumi.Float64PtrInput `pulumi:"threshold"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize pulumi.StringPtrInput `pulumi:"windowSize"`
}

func (ManagementEventAggregationConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagementEventAggregationCondition)(nil)).Elem()
}

func (i ManagementEventAggregationConditionArgs) ToManagementEventAggregationConditionOutput() ManagementEventAggregationConditionOutput {
	return i.ToManagementEventAggregationConditionOutputWithContext(context.Background())
}

func (i ManagementEventAggregationConditionArgs) ToManagementEventAggregationConditionOutputWithContext(ctx context.Context) ManagementEventAggregationConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementEventAggregationConditionOutput)
}

func (i ManagementEventAggregationConditionArgs) ToManagementEventAggregationConditionPtrOutput() ManagementEventAggregationConditionPtrOutput {
	return i.ToManagementEventAggregationConditionPtrOutputWithContext(context.Background())
}

func (i ManagementEventAggregationConditionArgs) ToManagementEventAggregationConditionPtrOutputWithContext(ctx context.Context) ManagementEventAggregationConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementEventAggregationConditionOutput).ToManagementEventAggregationConditionPtrOutputWithContext(ctx)
}

// ManagementEventAggregationConditionPtrInput is an input type that accepts ManagementEventAggregationConditionArgs, ManagementEventAggregationConditionPtr and ManagementEventAggregationConditionPtrOutput values.
// You can construct a concrete instance of `ManagementEventAggregationConditionPtrInput` via:
//
//          ManagementEventAggregationConditionArgs{...}
//
//  or:
//
//          nil
type ManagementEventAggregationConditionPtrInput interface {
	pulumi.Input

	ToManagementEventAggregationConditionPtrOutput() ManagementEventAggregationConditionPtrOutput
	ToManagementEventAggregationConditionPtrOutputWithContext(context.Context) ManagementEventAggregationConditionPtrOutput
}

type managementEventAggregationConditionPtrType ManagementEventAggregationConditionArgs

func ManagementEventAggregationConditionPtr(v *ManagementEventAggregationConditionArgs) ManagementEventAggregationConditionPtrInput {
	return (*managementEventAggregationConditionPtrType)(v)
}

func (*managementEventAggregationConditionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagementEventAggregationCondition)(nil)).Elem()
}

func (i *managementEventAggregationConditionPtrType) ToManagementEventAggregationConditionPtrOutput() ManagementEventAggregationConditionPtrOutput {
	return i.ToManagementEventAggregationConditionPtrOutputWithContext(context.Background())
}

func (i *managementEventAggregationConditionPtrType) ToManagementEventAggregationConditionPtrOutputWithContext(ctx context.Context) ManagementEventAggregationConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementEventAggregationConditionPtrOutput)
}

// How the data that is collected should be combined over time.
type ManagementEventAggregationConditionOutput struct{ *pulumi.OutputState }

func (ManagementEventAggregationConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagementEventAggregationCondition)(nil)).Elem()
}

func (o ManagementEventAggregationConditionOutput) ToManagementEventAggregationConditionOutput() ManagementEventAggregationConditionOutput {
	return o
}

func (o ManagementEventAggregationConditionOutput) ToManagementEventAggregationConditionOutputWithContext(ctx context.Context) ManagementEventAggregationConditionOutput {
	return o
}

func (o ManagementEventAggregationConditionOutput) ToManagementEventAggregationConditionPtrOutput() ManagementEventAggregationConditionPtrOutput {
	return o.ToManagementEventAggregationConditionPtrOutputWithContext(context.Background())
}

func (o ManagementEventAggregationConditionOutput) ToManagementEventAggregationConditionPtrOutputWithContext(ctx context.Context) ManagementEventAggregationConditionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ManagementEventAggregationCondition) *ManagementEventAggregationCondition {
		return &v
	}).(ManagementEventAggregationConditionPtrOutput)
}

// the condition operator.
func (o ManagementEventAggregationConditionOutput) Operator() ConditionOperatorPtrOutput {
	return o.ApplyT(func(v ManagementEventAggregationCondition) *ConditionOperator { return v.Operator }).(ConditionOperatorPtrOutput)
}

// The threshold value that activates the alert.
func (o ManagementEventAggregationConditionOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ManagementEventAggregationCondition) *float64 { return v.Threshold }).(pulumi.Float64PtrOutput)
}

// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
func (o ManagementEventAggregationConditionOutput) WindowSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagementEventAggregationCondition) *string { return v.WindowSize }).(pulumi.StringPtrOutput)
}

type ManagementEventAggregationConditionPtrOutput struct{ *pulumi.OutputState }

func (ManagementEventAggregationConditionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagementEventAggregationCondition)(nil)).Elem()
}

func (o ManagementEventAggregationConditionPtrOutput) ToManagementEventAggregationConditionPtrOutput() ManagementEventAggregationConditionPtrOutput {
	return o
}

func (o ManagementEventAggregationConditionPtrOutput) ToManagementEventAggregationConditionPtrOutputWithContext(ctx context.Context) ManagementEventAggregationConditionPtrOutput {
	return o
}

func (o ManagementEventAggregationConditionPtrOutput) Elem() ManagementEventAggregationConditionOutput {
	return o.ApplyT(func(v *ManagementEventAggregationCondition) ManagementEventAggregationCondition {
		if v != nil {
			return *v
		}
		var ret ManagementEventAggregationCondition
		return ret
	}).(ManagementEventAggregationConditionOutput)
}

// the condition operator.
func (o ManagementEventAggregationConditionPtrOutput) Operator() ConditionOperatorPtrOutput {
	return o.ApplyT(func(v *ManagementEventAggregationCondition) *ConditionOperator {
		if v == nil {
			return nil
		}
		return v.Operator
	}).(ConditionOperatorPtrOutput)
}

// The threshold value that activates the alert.
func (o ManagementEventAggregationConditionPtrOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ManagementEventAggregationCondition) *float64 {
		if v == nil {
			return nil
		}
		return v.Threshold
	}).(pulumi.Float64PtrOutput)
}

// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
func (o ManagementEventAggregationConditionPtrOutput) WindowSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagementEventAggregationCondition) *string {
		if v == nil {
			return nil
		}
		return v.WindowSize
	}).(pulumi.StringPtrOutput)
}

// How the data that is collected should be combined over time.
type ManagementEventAggregationConditionResponse struct {
	// the condition operator.
	Operator *string `pulumi:"operator"`
	// The threshold value that activates the alert.
	Threshold *float64 `pulumi:"threshold"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize *string `pulumi:"windowSize"`
}

// ManagementEventAggregationConditionResponseInput is an input type that accepts ManagementEventAggregationConditionResponseArgs and ManagementEventAggregationConditionResponseOutput values.
// You can construct a concrete instance of `ManagementEventAggregationConditionResponseInput` via:
//
//          ManagementEventAggregationConditionResponseArgs{...}
type ManagementEventAggregationConditionResponseInput interface {
	pulumi.Input

	ToManagementEventAggregationConditionResponseOutput() ManagementEventAggregationConditionResponseOutput
	ToManagementEventAggregationConditionResponseOutputWithContext(context.Context) ManagementEventAggregationConditionResponseOutput
}

// How the data that is collected should be combined over time.
type ManagementEventAggregationConditionResponseArgs struct {
	// the condition operator.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// The threshold value that activates the alert.
	Threshold pulumi.Float64PtrInput `pulumi:"threshold"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize pulumi.StringPtrInput `pulumi:"windowSize"`
}

func (ManagementEventAggregationConditionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagementEventAggregationConditionResponse)(nil)).Elem()
}

func (i ManagementEventAggregationConditionResponseArgs) ToManagementEventAggregationConditionResponseOutput() ManagementEventAggregationConditionResponseOutput {
	return i.ToManagementEventAggregationConditionResponseOutputWithContext(context.Background())
}

func (i ManagementEventAggregationConditionResponseArgs) ToManagementEventAggregationConditionResponseOutputWithContext(ctx context.Context) ManagementEventAggregationConditionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementEventAggregationConditionResponseOutput)
}

func (i ManagementEventAggregationConditionResponseArgs) ToManagementEventAggregationConditionResponsePtrOutput() ManagementEventAggregationConditionResponsePtrOutput {
	return i.ToManagementEventAggregationConditionResponsePtrOutputWithContext(context.Background())
}

func (i ManagementEventAggregationConditionResponseArgs) ToManagementEventAggregationConditionResponsePtrOutputWithContext(ctx context.Context) ManagementEventAggregationConditionResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementEventAggregationConditionResponseOutput).ToManagementEventAggregationConditionResponsePtrOutputWithContext(ctx)
}

// ManagementEventAggregationConditionResponsePtrInput is an input type that accepts ManagementEventAggregationConditionResponseArgs, ManagementEventAggregationConditionResponsePtr and ManagementEventAggregationConditionResponsePtrOutput values.
// You can construct a concrete instance of `ManagementEventAggregationConditionResponsePtrInput` via:
//
//          ManagementEventAggregationConditionResponseArgs{...}
//
//  or:
//
//          nil
type ManagementEventAggregationConditionResponsePtrInput interface {
	pulumi.Input

	ToManagementEventAggregationConditionResponsePtrOutput() ManagementEventAggregationConditionResponsePtrOutput
	ToManagementEventAggregationConditionResponsePtrOutputWithContext(context.Context) ManagementEventAggregationConditionResponsePtrOutput
}

type managementEventAggregationConditionResponsePtrType ManagementEventAggregationConditionResponseArgs

func ManagementEventAggregationConditionResponsePtr(v *ManagementEventAggregationConditionResponseArgs) ManagementEventAggregationConditionResponsePtrInput {
	return (*managementEventAggregationConditionResponsePtrType)(v)
}

func (*managementEventAggregationConditionResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagementEventAggregationConditionResponse)(nil)).Elem()
}

func (i *managementEventAggregationConditionResponsePtrType) ToManagementEventAggregationConditionResponsePtrOutput() ManagementEventAggregationConditionResponsePtrOutput {
	return i.ToManagementEventAggregationConditionResponsePtrOutputWithContext(context.Background())
}

func (i *managementEventAggregationConditionResponsePtrType) ToManagementEventAggregationConditionResponsePtrOutputWithContext(ctx context.Context) ManagementEventAggregationConditionResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementEventAggregationConditionResponsePtrOutput)
}

// How the data that is collected should be combined over time.
type ManagementEventAggregationConditionResponseOutput struct{ *pulumi.OutputState }

func (ManagementEventAggregationConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagementEventAggregationConditionResponse)(nil)).Elem()
}

func (o ManagementEventAggregationConditionResponseOutput) ToManagementEventAggregationConditionResponseOutput() ManagementEventAggregationConditionResponseOutput {
	return o
}

func (o ManagementEventAggregationConditionResponseOutput) ToManagementEventAggregationConditionResponseOutputWithContext(ctx context.Context) ManagementEventAggregationConditionResponseOutput {
	return o
}

func (o ManagementEventAggregationConditionResponseOutput) ToManagementEventAggregationConditionResponsePtrOutput() ManagementEventAggregationConditionResponsePtrOutput {
	return o.ToManagementEventAggregationConditionResponsePtrOutputWithContext(context.Background())
}

func (o ManagementEventAggregationConditionResponseOutput) ToManagementEventAggregationConditionResponsePtrOutputWithContext(ctx context.Context) ManagementEventAggregationConditionResponsePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ManagementEventAggregationConditionResponse) *ManagementEventAggregationConditionResponse {
		return &v
	}).(ManagementEventAggregationConditionResponsePtrOutput)
}

// the condition operator.
func (o ManagementEventAggregationConditionResponseOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagementEventAggregationConditionResponse) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// The threshold value that activates the alert.
func (o ManagementEventAggregationConditionResponseOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ManagementEventAggregationConditionResponse) *float64 { return v.Threshold }).(pulumi.Float64PtrOutput)
}

// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
func (o ManagementEventAggregationConditionResponseOutput) WindowSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ManagementEventAggregationConditionResponse) *string { return v.WindowSize }).(pulumi.StringPtrOutput)
}

type ManagementEventAggregationConditionResponsePtrOutput struct{ *pulumi.OutputState }

func (ManagementEventAggregationConditionResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagementEventAggregationConditionResponse)(nil)).Elem()
}

func (o ManagementEventAggregationConditionResponsePtrOutput) ToManagementEventAggregationConditionResponsePtrOutput() ManagementEventAggregationConditionResponsePtrOutput {
	return o
}

func (o ManagementEventAggregationConditionResponsePtrOutput) ToManagementEventAggregationConditionResponsePtrOutputWithContext(ctx context.Context) ManagementEventAggregationConditionResponsePtrOutput {
	return o
}

func (o ManagementEventAggregationConditionResponsePtrOutput) Elem() ManagementEventAggregationConditionResponseOutput {
	return o.ApplyT(func(v *ManagementEventAggregationConditionResponse) ManagementEventAggregationConditionResponse {
		if v != nil {
			return *v
		}
		var ret ManagementEventAggregationConditionResponse
		return ret
	}).(ManagementEventAggregationConditionResponseOutput)
}

// the condition operator.
func (o ManagementEventAggregationConditionResponsePtrOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagementEventAggregationConditionResponse) *string {
		if v == nil {
			return nil
		}
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// The threshold value that activates the alert.
func (o ManagementEventAggregationConditionResponsePtrOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ManagementEventAggregationConditionResponse) *float64 {
		if v == nil {
			return nil
		}
		return v.Threshold
	}).(pulumi.Float64PtrOutput)
}

// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
func (o ManagementEventAggregationConditionResponsePtrOutput) WindowSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagementEventAggregationConditionResponse) *string {
		if v == nil {
			return nil
		}
		return v.WindowSize
	}).(pulumi.StringPtrOutput)
}

// A management event rule condition.
type ManagementEventRuleCondition struct {
	// How the data that is collected should be combined over time and when the alert is activated. Note that for management event alerts aggregation is optional – if it is not provided then any event will cause the alert to activate.
	Aggregation *ManagementEventAggregationCondition `pulumi:"aggregation"`
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource interface{} `pulumi:"dataSource"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition'.
	OdataType string `pulumi:"odataType"`
}

// ManagementEventRuleConditionInput is an input type that accepts ManagementEventRuleConditionArgs and ManagementEventRuleConditionOutput values.
// You can construct a concrete instance of `ManagementEventRuleConditionInput` via:
//
//          ManagementEventRuleConditionArgs{...}
type ManagementEventRuleConditionInput interface {
	pulumi.Input

	ToManagementEventRuleConditionOutput() ManagementEventRuleConditionOutput
	ToManagementEventRuleConditionOutputWithContext(context.Context) ManagementEventRuleConditionOutput
}

// A management event rule condition.
type ManagementEventRuleConditionArgs struct {
	// How the data that is collected should be combined over time and when the alert is activated. Note that for management event alerts aggregation is optional – if it is not provided then any event will cause the alert to activate.
	Aggregation ManagementEventAggregationConditionPtrInput `pulumi:"aggregation"`
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource pulumi.Input `pulumi:"dataSource"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ManagementEventRuleConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagementEventRuleCondition)(nil)).Elem()
}

func (i ManagementEventRuleConditionArgs) ToManagementEventRuleConditionOutput() ManagementEventRuleConditionOutput {
	return i.ToManagementEventRuleConditionOutputWithContext(context.Background())
}

func (i ManagementEventRuleConditionArgs) ToManagementEventRuleConditionOutputWithContext(ctx context.Context) ManagementEventRuleConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementEventRuleConditionOutput)
}

// A management event rule condition.
type ManagementEventRuleConditionOutput struct{ *pulumi.OutputState }

func (ManagementEventRuleConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagementEventRuleCondition)(nil)).Elem()
}

func (o ManagementEventRuleConditionOutput) ToManagementEventRuleConditionOutput() ManagementEventRuleConditionOutput {
	return o
}

func (o ManagementEventRuleConditionOutput) ToManagementEventRuleConditionOutputWithContext(ctx context.Context) ManagementEventRuleConditionOutput {
	return o
}

// How the data that is collected should be combined over time and when the alert is activated. Note that for management event alerts aggregation is optional – if it is not provided then any event will cause the alert to activate.
func (o ManagementEventRuleConditionOutput) Aggregation() ManagementEventAggregationConditionPtrOutput {
	return o.ApplyT(func(v ManagementEventRuleCondition) *ManagementEventAggregationCondition { return v.Aggregation }).(ManagementEventAggregationConditionPtrOutput)
}

// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
func (o ManagementEventRuleConditionOutput) DataSource() pulumi.AnyOutput {
	return o.ApplyT(func(v ManagementEventRuleCondition) interface{} { return v.DataSource }).(pulumi.AnyOutput)
}

// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
// Expected value is 'Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition'.
func (o ManagementEventRuleConditionOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ManagementEventRuleCondition) string { return v.OdataType }).(pulumi.StringOutput)
}

// A management event rule condition.
type ManagementEventRuleConditionResponse struct {
	// How the data that is collected should be combined over time and when the alert is activated. Note that for management event alerts aggregation is optional – if it is not provided then any event will cause the alert to activate.
	Aggregation *ManagementEventAggregationConditionResponse `pulumi:"aggregation"`
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource interface{} `pulumi:"dataSource"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition'.
	OdataType string `pulumi:"odataType"`
}

// ManagementEventRuleConditionResponseInput is an input type that accepts ManagementEventRuleConditionResponseArgs and ManagementEventRuleConditionResponseOutput values.
// You can construct a concrete instance of `ManagementEventRuleConditionResponseInput` via:
//
//          ManagementEventRuleConditionResponseArgs{...}
type ManagementEventRuleConditionResponseInput interface {
	pulumi.Input

	ToManagementEventRuleConditionResponseOutput() ManagementEventRuleConditionResponseOutput
	ToManagementEventRuleConditionResponseOutputWithContext(context.Context) ManagementEventRuleConditionResponseOutput
}

// A management event rule condition.
type ManagementEventRuleConditionResponseArgs struct {
	// How the data that is collected should be combined over time and when the alert is activated. Note that for management event alerts aggregation is optional – if it is not provided then any event will cause the alert to activate.
	Aggregation ManagementEventAggregationConditionResponsePtrInput `pulumi:"aggregation"`
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource pulumi.Input `pulumi:"dataSource"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
}

func (ManagementEventRuleConditionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagementEventRuleConditionResponse)(nil)).Elem()
}

func (i ManagementEventRuleConditionResponseArgs) ToManagementEventRuleConditionResponseOutput() ManagementEventRuleConditionResponseOutput {
	return i.ToManagementEventRuleConditionResponseOutputWithContext(context.Background())
}

func (i ManagementEventRuleConditionResponseArgs) ToManagementEventRuleConditionResponseOutputWithContext(ctx context.Context) ManagementEventRuleConditionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagementEventRuleConditionResponseOutput)
}

// A management event rule condition.
type ManagementEventRuleConditionResponseOutput struct{ *pulumi.OutputState }

func (ManagementEventRuleConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagementEventRuleConditionResponse)(nil)).Elem()
}

func (o ManagementEventRuleConditionResponseOutput) ToManagementEventRuleConditionResponseOutput() ManagementEventRuleConditionResponseOutput {
	return o
}

func (o ManagementEventRuleConditionResponseOutput) ToManagementEventRuleConditionResponseOutputWithContext(ctx context.Context) ManagementEventRuleConditionResponseOutput {
	return o
}

// How the data that is collected should be combined over time and when the alert is activated. Note that for management event alerts aggregation is optional – if it is not provided then any event will cause the alert to activate.
func (o ManagementEventRuleConditionResponseOutput) Aggregation() ManagementEventAggregationConditionResponsePtrOutput {
	return o.ApplyT(func(v ManagementEventRuleConditionResponse) *ManagementEventAggregationConditionResponse {
		return v.Aggregation
	}).(ManagementEventAggregationConditionResponsePtrOutput)
}

// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
func (o ManagementEventRuleConditionResponseOutput) DataSource() pulumi.AnyOutput {
	return o.ApplyT(func(v ManagementEventRuleConditionResponse) interface{} { return v.DataSource }).(pulumi.AnyOutput)
}

// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
// Expected value is 'Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition'.
func (o ManagementEventRuleConditionResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ManagementEventRuleConditionResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The trigger that results in a scaling action.
type MetricTrigger struct {
	// List of dimension conditions. For example: [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
	Dimensions []ScaleRuleMetricDimension `pulumi:"dimensions"`
	// a value indicating whether metric should divide per instance.
	DividePerInstance *bool `pulumi:"dividePerInstance"`
	// the name of the metric that defines what the rule monitors.
	MetricName string `pulumi:"metricName"`
	// the namespace of the metric that defines what the rule monitors.
	MetricNamespace *string `pulumi:"metricNamespace"`
	// the location of the resource the rule monitors.
	MetricResourceLocation *string `pulumi:"metricResourceLocation"`
	// the resource identifier of the resource the rule monitors.
	MetricResourceUri string `pulumi:"metricResourceUri"`
	// the operator that is used to compare the metric data and the threshold.
	Operator ComparisonOperationType `pulumi:"operator"`
	// the metric statistic type. How the metrics from multiple instances are combined.
	Statistic MetricStatisticType `pulumi:"statistic"`
	// the threshold of the metric that triggers the scale action.
	Threshold float64 `pulumi:"threshold"`
	// time aggregation type. How the data that is collected should be combined over time. The default value is Average.
	TimeAggregation TimeAggregationType `pulumi:"timeAggregation"`
	// the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.
	TimeGrain string `pulumi:"timeGrain"`
	// the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
	TimeWindow string `pulumi:"timeWindow"`
}

// MetricTriggerInput is an input type that accepts MetricTriggerArgs and MetricTriggerOutput values.
// You can construct a concrete instance of `MetricTriggerInput` via:
//
//          MetricTriggerArgs{...}
type MetricTriggerInput interface {
	pulumi.Input

	ToMetricTriggerOutput() MetricTriggerOutput
	ToMetricTriggerOutputWithContext(context.Context) MetricTriggerOutput
}

// The trigger that results in a scaling action.
type MetricTriggerArgs struct {
	// List of dimension conditions. For example: [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
	Dimensions ScaleRuleMetricDimensionArrayInput `pulumi:"dimensions"`
	// a value indicating whether metric should divide per instance.
	DividePerInstance pulumi.BoolPtrInput `pulumi:"dividePerInstance"`
	// the name of the metric that defines what the rule monitors.
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// the namespace of the metric that defines what the rule monitors.
	MetricNamespace pulumi.StringPtrInput `pulumi:"metricNamespace"`
	// the location of the resource the rule monitors.
	MetricResourceLocation pulumi.StringPtrInput `pulumi:"metricResourceLocation"`
	// the resource identifier of the resource the rule monitors.
	MetricResourceUri pulumi.StringInput `pulumi:"metricResourceUri"`
	// the operator that is used to compare the metric data and the threshold.
	Operator ComparisonOperationTypeInput `pulumi:"operator"`
	// the metric statistic type. How the metrics from multiple instances are combined.
	Statistic MetricStatisticTypeInput `pulumi:"statistic"`
	// the threshold of the metric that triggers the scale action.
	Threshold pulumi.Float64Input `pulumi:"threshold"`
	// time aggregation type. How the data that is collected should be combined over time. The default value is Average.
	TimeAggregation TimeAggregationTypeInput `pulumi:"timeAggregation"`
	// the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.
	TimeGrain pulumi.StringInput `pulumi:"timeGrain"`
	// the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
	TimeWindow pulumi.StringInput `pulumi:"timeWindow"`
}

func (MetricTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricTrigger)(nil)).Elem()
}

func (i MetricTriggerArgs) ToMetricTriggerOutput() MetricTriggerOutput {
	return i.ToMetricTriggerOutputWithContext(context.Background())
}

func (i MetricTriggerArgs) ToMetricTriggerOutputWithContext(ctx context.Context) MetricTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricTriggerOutput)
}

// The trigger that results in a scaling action.
type MetricTriggerOutput struct{ *pulumi.OutputState }

func (MetricTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricTrigger)(nil)).Elem()
}

func (o MetricTriggerOutput) ToMetricTriggerOutput() MetricTriggerOutput {
	return o
}

func (o MetricTriggerOutput) ToMetricTriggerOutputWithContext(ctx context.Context) MetricTriggerOutput {
	return o
}

// List of dimension conditions. For example: [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
func (o MetricTriggerOutput) Dimensions() ScaleRuleMetricDimensionArrayOutput {
	return o.ApplyT(func(v MetricTrigger) []ScaleRuleMetricDimension { return v.Dimensions }).(ScaleRuleMetricDimensionArrayOutput)
}

// a value indicating whether metric should divide per instance.
func (o MetricTriggerOutput) DividePerInstance() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v MetricTrigger) *bool { return v.DividePerInstance }).(pulumi.BoolPtrOutput)
}

// the name of the metric that defines what the rule monitors.
func (o MetricTriggerOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTrigger) string { return v.MetricName }).(pulumi.StringOutput)
}

// the namespace of the metric that defines what the rule monitors.
func (o MetricTriggerOutput) MetricNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricTrigger) *string { return v.MetricNamespace }).(pulumi.StringPtrOutput)
}

// the location of the resource the rule monitors.
func (o MetricTriggerOutput) MetricResourceLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricTrigger) *string { return v.MetricResourceLocation }).(pulumi.StringPtrOutput)
}

// the resource identifier of the resource the rule monitors.
func (o MetricTriggerOutput) MetricResourceUri() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTrigger) string { return v.MetricResourceUri }).(pulumi.StringOutput)
}

// the operator that is used to compare the metric data and the threshold.
func (o MetricTriggerOutput) Operator() ComparisonOperationTypeOutput {
	return o.ApplyT(func(v MetricTrigger) ComparisonOperationType { return v.Operator }).(ComparisonOperationTypeOutput)
}

// the metric statistic type. How the metrics from multiple instances are combined.
func (o MetricTriggerOutput) Statistic() MetricStatisticTypeOutput {
	return o.ApplyT(func(v MetricTrigger) MetricStatisticType { return v.Statistic }).(MetricStatisticTypeOutput)
}

// the threshold of the metric that triggers the scale action.
func (o MetricTriggerOutput) Threshold() pulumi.Float64Output {
	return o.ApplyT(func(v MetricTrigger) float64 { return v.Threshold }).(pulumi.Float64Output)
}

// time aggregation type. How the data that is collected should be combined over time. The default value is Average.
func (o MetricTriggerOutput) TimeAggregation() TimeAggregationTypeOutput {
	return o.ApplyT(func(v MetricTrigger) TimeAggregationType { return v.TimeAggregation }).(TimeAggregationTypeOutput)
}

// the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.
func (o MetricTriggerOutput) TimeGrain() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTrigger) string { return v.TimeGrain }).(pulumi.StringOutput)
}

// the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
func (o MetricTriggerOutput) TimeWindow() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTrigger) string { return v.TimeWindow }).(pulumi.StringOutput)
}

// The trigger that results in a scaling action.
type MetricTriggerResponse struct {
	// List of dimension conditions. For example: [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
	Dimensions []ScaleRuleMetricDimensionResponse `pulumi:"dimensions"`
	// a value indicating whether metric should divide per instance.
	DividePerInstance *bool `pulumi:"dividePerInstance"`
	// the name of the metric that defines what the rule monitors.
	MetricName string `pulumi:"metricName"`
	// the namespace of the metric that defines what the rule monitors.
	MetricNamespace *string `pulumi:"metricNamespace"`
	// the location of the resource the rule monitors.
	MetricResourceLocation *string `pulumi:"metricResourceLocation"`
	// the resource identifier of the resource the rule monitors.
	MetricResourceUri string `pulumi:"metricResourceUri"`
	// the operator that is used to compare the metric data and the threshold.
	Operator string `pulumi:"operator"`
	// the metric statistic type. How the metrics from multiple instances are combined.
	Statistic string `pulumi:"statistic"`
	// the threshold of the metric that triggers the scale action.
	Threshold float64 `pulumi:"threshold"`
	// time aggregation type. How the data that is collected should be combined over time. The default value is Average.
	TimeAggregation string `pulumi:"timeAggregation"`
	// the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.
	TimeGrain string `pulumi:"timeGrain"`
	// the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
	TimeWindow string `pulumi:"timeWindow"`
}

// MetricTriggerResponseInput is an input type that accepts MetricTriggerResponseArgs and MetricTriggerResponseOutput values.
// You can construct a concrete instance of `MetricTriggerResponseInput` via:
//
//          MetricTriggerResponseArgs{...}
type MetricTriggerResponseInput interface {
	pulumi.Input

	ToMetricTriggerResponseOutput() MetricTriggerResponseOutput
	ToMetricTriggerResponseOutputWithContext(context.Context) MetricTriggerResponseOutput
}

// The trigger that results in a scaling action.
type MetricTriggerResponseArgs struct {
	// List of dimension conditions. For example: [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
	Dimensions ScaleRuleMetricDimensionResponseArrayInput `pulumi:"dimensions"`
	// a value indicating whether metric should divide per instance.
	DividePerInstance pulumi.BoolPtrInput `pulumi:"dividePerInstance"`
	// the name of the metric that defines what the rule monitors.
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// the namespace of the metric that defines what the rule monitors.
	MetricNamespace pulumi.StringPtrInput `pulumi:"metricNamespace"`
	// the location of the resource the rule monitors.
	MetricResourceLocation pulumi.StringPtrInput `pulumi:"metricResourceLocation"`
	// the resource identifier of the resource the rule monitors.
	MetricResourceUri pulumi.StringInput `pulumi:"metricResourceUri"`
	// the operator that is used to compare the metric data and the threshold.
	Operator pulumi.StringInput `pulumi:"operator"`
	// the metric statistic type. How the metrics from multiple instances are combined.
	Statistic pulumi.StringInput `pulumi:"statistic"`
	// the threshold of the metric that triggers the scale action.
	Threshold pulumi.Float64Input `pulumi:"threshold"`
	// time aggregation type. How the data that is collected should be combined over time. The default value is Average.
	TimeAggregation pulumi.StringInput `pulumi:"timeAggregation"`
	// the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.
	TimeGrain pulumi.StringInput `pulumi:"timeGrain"`
	// the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
	TimeWindow pulumi.StringInput `pulumi:"timeWindow"`
}

func (MetricTriggerResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricTriggerResponse)(nil)).Elem()
}

func (i MetricTriggerResponseArgs) ToMetricTriggerResponseOutput() MetricTriggerResponseOutput {
	return i.ToMetricTriggerResponseOutputWithContext(context.Background())
}

func (i MetricTriggerResponseArgs) ToMetricTriggerResponseOutputWithContext(ctx context.Context) MetricTriggerResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricTriggerResponseOutput)
}

// The trigger that results in a scaling action.
type MetricTriggerResponseOutput struct{ *pulumi.OutputState }

func (MetricTriggerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricTriggerResponse)(nil)).Elem()
}

func (o MetricTriggerResponseOutput) ToMetricTriggerResponseOutput() MetricTriggerResponseOutput {
	return o
}

func (o MetricTriggerResponseOutput) ToMetricTriggerResponseOutputWithContext(ctx context.Context) MetricTriggerResponseOutput {
	return o
}

// List of dimension conditions. For example: [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
func (o MetricTriggerResponseOutput) Dimensions() ScaleRuleMetricDimensionResponseArrayOutput {
	return o.ApplyT(func(v MetricTriggerResponse) []ScaleRuleMetricDimensionResponse { return v.Dimensions }).(ScaleRuleMetricDimensionResponseArrayOutput)
}

// a value indicating whether metric should divide per instance.
func (o MetricTriggerResponseOutput) DividePerInstance() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v MetricTriggerResponse) *bool { return v.DividePerInstance }).(pulumi.BoolPtrOutput)
}

// the name of the metric that defines what the rule monitors.
func (o MetricTriggerResponseOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTriggerResponse) string { return v.MetricName }).(pulumi.StringOutput)
}

// the namespace of the metric that defines what the rule monitors.
func (o MetricTriggerResponseOutput) MetricNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricTriggerResponse) *string { return v.MetricNamespace }).(pulumi.StringPtrOutput)
}

// the location of the resource the rule monitors.
func (o MetricTriggerResponseOutput) MetricResourceLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricTriggerResponse) *string { return v.MetricResourceLocation }).(pulumi.StringPtrOutput)
}

// the resource identifier of the resource the rule monitors.
func (o MetricTriggerResponseOutput) MetricResourceUri() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTriggerResponse) string { return v.MetricResourceUri }).(pulumi.StringOutput)
}

// the operator that is used to compare the metric data and the threshold.
func (o MetricTriggerResponseOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTriggerResponse) string { return v.Operator }).(pulumi.StringOutput)
}

// the metric statistic type. How the metrics from multiple instances are combined.
func (o MetricTriggerResponseOutput) Statistic() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTriggerResponse) string { return v.Statistic }).(pulumi.StringOutput)
}

// the threshold of the metric that triggers the scale action.
func (o MetricTriggerResponseOutput) Threshold() pulumi.Float64Output {
	return o.ApplyT(func(v MetricTriggerResponse) float64 { return v.Threshold }).(pulumi.Float64Output)
}

// time aggregation type. How the data that is collected should be combined over time. The default value is Average.
func (o MetricTriggerResponseOutput) TimeAggregation() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTriggerResponse) string { return v.TimeAggregation }).(pulumi.StringOutput)
}

// the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.
func (o MetricTriggerResponseOutput) TimeGrain() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTriggerResponse) string { return v.TimeGrain }).(pulumi.StringOutput)
}

// the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
func (o MetricTriggerResponseOutput) TimeWindow() pulumi.StringOutput {
	return o.ApplyT(func(v MetricTriggerResponse) string { return v.TimeWindow }).(pulumi.StringOutput)
}

// The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
type Recurrence struct {
	// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
	Frequency RecurrenceFrequency `pulumi:"frequency"`
	// the scheduling constraints for when the profile begins.
	Schedule RecurrentSchedule `pulumi:"schedule"`
}

// RecurrenceInput is an input type that accepts RecurrenceArgs and RecurrenceOutput values.
// You can construct a concrete instance of `RecurrenceInput` via:
//
//          RecurrenceArgs{...}
type RecurrenceInput interface {
	pulumi.Input

	ToRecurrenceOutput() RecurrenceOutput
	ToRecurrenceOutputWithContext(context.Context) RecurrenceOutput
}

// The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
type RecurrenceArgs struct {
	// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
	Frequency RecurrenceFrequencyInput `pulumi:"frequency"`
	// the scheduling constraints for when the profile begins.
	Schedule RecurrentScheduleInput `pulumi:"schedule"`
}

func (RecurrenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Recurrence)(nil)).Elem()
}

func (i RecurrenceArgs) ToRecurrenceOutput() RecurrenceOutput {
	return i.ToRecurrenceOutputWithContext(context.Background())
}

func (i RecurrenceArgs) ToRecurrenceOutputWithContext(ctx context.Context) RecurrenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceOutput)
}

func (i RecurrenceArgs) ToRecurrencePtrOutput() RecurrencePtrOutput {
	return i.ToRecurrencePtrOutputWithContext(context.Background())
}

func (i RecurrenceArgs) ToRecurrencePtrOutputWithContext(ctx context.Context) RecurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceOutput).ToRecurrencePtrOutputWithContext(ctx)
}

// RecurrencePtrInput is an input type that accepts RecurrenceArgs, RecurrencePtr and RecurrencePtrOutput values.
// You can construct a concrete instance of `RecurrencePtrInput` via:
//
//          RecurrenceArgs{...}
//
//  or:
//
//          nil
type RecurrencePtrInput interface {
	pulumi.Input

	ToRecurrencePtrOutput() RecurrencePtrOutput
	ToRecurrencePtrOutputWithContext(context.Context) RecurrencePtrOutput
}

type recurrencePtrType RecurrenceArgs

func RecurrencePtr(v *RecurrenceArgs) RecurrencePtrInput {
	return (*recurrencePtrType)(v)
}

func (*recurrencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Recurrence)(nil)).Elem()
}

func (i *recurrencePtrType) ToRecurrencePtrOutput() RecurrencePtrOutput {
	return i.ToRecurrencePtrOutputWithContext(context.Background())
}

func (i *recurrencePtrType) ToRecurrencePtrOutputWithContext(ctx context.Context) RecurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrencePtrOutput)
}

// The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
type RecurrenceOutput struct{ *pulumi.OutputState }

func (RecurrenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Recurrence)(nil)).Elem()
}

func (o RecurrenceOutput) ToRecurrenceOutput() RecurrenceOutput {
	return o
}

func (o RecurrenceOutput) ToRecurrenceOutputWithContext(ctx context.Context) RecurrenceOutput {
	return o
}

func (o RecurrenceOutput) ToRecurrencePtrOutput() RecurrencePtrOutput {
	return o.ToRecurrencePtrOutputWithContext(context.Background())
}

func (o RecurrenceOutput) ToRecurrencePtrOutputWithContext(ctx context.Context) RecurrencePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Recurrence) *Recurrence {
		return &v
	}).(RecurrencePtrOutput)
}

// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
func (o RecurrenceOutput) Frequency() RecurrenceFrequencyOutput {
	return o.ApplyT(func(v Recurrence) RecurrenceFrequency { return v.Frequency }).(RecurrenceFrequencyOutput)
}

// the scheduling constraints for when the profile begins.
func (o RecurrenceOutput) Schedule() RecurrentScheduleOutput {
	return o.ApplyT(func(v Recurrence) RecurrentSchedule { return v.Schedule }).(RecurrentScheduleOutput)
}

type RecurrencePtrOutput struct{ *pulumi.OutputState }

func (RecurrencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Recurrence)(nil)).Elem()
}

func (o RecurrencePtrOutput) ToRecurrencePtrOutput() RecurrencePtrOutput {
	return o
}

func (o RecurrencePtrOutput) ToRecurrencePtrOutputWithContext(ctx context.Context) RecurrencePtrOutput {
	return o
}

func (o RecurrencePtrOutput) Elem() RecurrenceOutput {
	return o.ApplyT(func(v *Recurrence) Recurrence {
		if v != nil {
			return *v
		}
		var ret Recurrence
		return ret
	}).(RecurrenceOutput)
}

// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
func (o RecurrencePtrOutput) Frequency() RecurrenceFrequencyPtrOutput {
	return o.ApplyT(func(v *Recurrence) *RecurrenceFrequency {
		if v == nil {
			return nil
		}
		return &v.Frequency
	}).(RecurrenceFrequencyPtrOutput)
}

// the scheduling constraints for when the profile begins.
func (o RecurrencePtrOutput) Schedule() RecurrentSchedulePtrOutput {
	return o.ApplyT(func(v *Recurrence) *RecurrentSchedule {
		if v == nil {
			return nil
		}
		return &v.Schedule
	}).(RecurrentSchedulePtrOutput)
}

// The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
type RecurrenceResponse struct {
	// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
	Frequency string `pulumi:"frequency"`
	// the scheduling constraints for when the profile begins.
	Schedule RecurrentScheduleResponse `pulumi:"schedule"`
}

// RecurrenceResponseInput is an input type that accepts RecurrenceResponseArgs and RecurrenceResponseOutput values.
// You can construct a concrete instance of `RecurrenceResponseInput` via:
//
//          RecurrenceResponseArgs{...}
type RecurrenceResponseInput interface {
	pulumi.Input

	ToRecurrenceResponseOutput() RecurrenceResponseOutput
	ToRecurrenceResponseOutputWithContext(context.Context) RecurrenceResponseOutput
}

// The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
type RecurrenceResponseArgs struct {
	// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
	Frequency pulumi.StringInput `pulumi:"frequency"`
	// the scheduling constraints for when the profile begins.
	Schedule RecurrentScheduleResponseInput `pulumi:"schedule"`
}

func (RecurrenceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrenceResponse)(nil)).Elem()
}

func (i RecurrenceResponseArgs) ToRecurrenceResponseOutput() RecurrenceResponseOutput {
	return i.ToRecurrenceResponseOutputWithContext(context.Background())
}

func (i RecurrenceResponseArgs) ToRecurrenceResponseOutputWithContext(ctx context.Context) RecurrenceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceResponseOutput)
}

func (i RecurrenceResponseArgs) ToRecurrenceResponsePtrOutput() RecurrenceResponsePtrOutput {
	return i.ToRecurrenceResponsePtrOutputWithContext(context.Background())
}

func (i RecurrenceResponseArgs) ToRecurrenceResponsePtrOutputWithContext(ctx context.Context) RecurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceResponseOutput).ToRecurrenceResponsePtrOutputWithContext(ctx)
}

// RecurrenceResponsePtrInput is an input type that accepts RecurrenceResponseArgs, RecurrenceResponsePtr and RecurrenceResponsePtrOutput values.
// You can construct a concrete instance of `RecurrenceResponsePtrInput` via:
//
//          RecurrenceResponseArgs{...}
//
//  or:
//
//          nil
type RecurrenceResponsePtrInput interface {
	pulumi.Input

	ToRecurrenceResponsePtrOutput() RecurrenceResponsePtrOutput
	ToRecurrenceResponsePtrOutputWithContext(context.Context) RecurrenceResponsePtrOutput
}

type recurrenceResponsePtrType RecurrenceResponseArgs

func RecurrenceResponsePtr(v *RecurrenceResponseArgs) RecurrenceResponsePtrInput {
	return (*recurrenceResponsePtrType)(v)
}

func (*recurrenceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrenceResponse)(nil)).Elem()
}

func (i *recurrenceResponsePtrType) ToRecurrenceResponsePtrOutput() RecurrenceResponsePtrOutput {
	return i.ToRecurrenceResponsePtrOutputWithContext(context.Background())
}

func (i *recurrenceResponsePtrType) ToRecurrenceResponsePtrOutputWithContext(ctx context.Context) RecurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrenceResponsePtrOutput)
}

// The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
type RecurrenceResponseOutput struct{ *pulumi.OutputState }

func (RecurrenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrenceResponse)(nil)).Elem()
}

func (o RecurrenceResponseOutput) ToRecurrenceResponseOutput() RecurrenceResponseOutput {
	return o
}

func (o RecurrenceResponseOutput) ToRecurrenceResponseOutputWithContext(ctx context.Context) RecurrenceResponseOutput {
	return o
}

func (o RecurrenceResponseOutput) ToRecurrenceResponsePtrOutput() RecurrenceResponsePtrOutput {
	return o.ToRecurrenceResponsePtrOutputWithContext(context.Background())
}

func (o RecurrenceResponseOutput) ToRecurrenceResponsePtrOutputWithContext(ctx context.Context) RecurrenceResponsePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RecurrenceResponse) *RecurrenceResponse {
		return &v
	}).(RecurrenceResponsePtrOutput)
}

// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
func (o RecurrenceResponseOutput) Frequency() pulumi.StringOutput {
	return o.ApplyT(func(v RecurrenceResponse) string { return v.Frequency }).(pulumi.StringOutput)
}

// the scheduling constraints for when the profile begins.
func (o RecurrenceResponseOutput) Schedule() RecurrentScheduleResponseOutput {
	return o.ApplyT(func(v RecurrenceResponse) RecurrentScheduleResponse { return v.Schedule }).(RecurrentScheduleResponseOutput)
}

type RecurrenceResponsePtrOutput struct{ *pulumi.OutputState }

func (RecurrenceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrenceResponse)(nil)).Elem()
}

func (o RecurrenceResponsePtrOutput) ToRecurrenceResponsePtrOutput() RecurrenceResponsePtrOutput {
	return o
}

func (o RecurrenceResponsePtrOutput) ToRecurrenceResponsePtrOutputWithContext(ctx context.Context) RecurrenceResponsePtrOutput {
	return o
}

func (o RecurrenceResponsePtrOutput) Elem() RecurrenceResponseOutput {
	return o.ApplyT(func(v *RecurrenceResponse) RecurrenceResponse {
		if v != nil {
			return *v
		}
		var ret RecurrenceResponse
		return ret
	}).(RecurrenceResponseOutput)
}

// the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning each week will have the same set of profiles. For example, to set a daily schedule, set **schedule** to every day of the week. The frequency property specifies that the schedule is repeated weekly.
func (o RecurrenceResponsePtrOutput) Frequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Frequency
	}).(pulumi.StringPtrOutput)
}

// the scheduling constraints for when the profile begins.
func (o RecurrenceResponsePtrOutput) Schedule() RecurrentScheduleResponsePtrOutput {
	return o.ApplyT(func(v *RecurrenceResponse) *RecurrentScheduleResponse {
		if v == nil {
			return nil
		}
		return &v.Schedule
	}).(RecurrentScheduleResponsePtrOutput)
}

// The scheduling constraints for when the profile begins.
type RecurrentSchedule struct {
	// the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
	Days []string `pulumi:"days"`
	// A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
	Hours []int `pulumi:"hours"`
	// A collection of minutes at which the profile takes effect at.
	Minutes []int `pulumi:"minutes"`
	// the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone string `pulumi:"timeZone"`
}

// RecurrentScheduleInput is an input type that accepts RecurrentScheduleArgs and RecurrentScheduleOutput values.
// You can construct a concrete instance of `RecurrentScheduleInput` via:
//
//          RecurrentScheduleArgs{...}
type RecurrentScheduleInput interface {
	pulumi.Input

	ToRecurrentScheduleOutput() RecurrentScheduleOutput
	ToRecurrentScheduleOutputWithContext(context.Context) RecurrentScheduleOutput
}

// The scheduling constraints for when the profile begins.
type RecurrentScheduleArgs struct {
	// the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
	Days pulumi.StringArrayInput `pulumi:"days"`
	// A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
	Hours pulumi.IntArrayInput `pulumi:"hours"`
	// A collection of minutes at which the profile takes effect at.
	Minutes pulumi.IntArrayInput `pulumi:"minutes"`
	// the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone pulumi.StringInput `pulumi:"timeZone"`
}

func (RecurrentScheduleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrentSchedule)(nil)).Elem()
}

func (i RecurrentScheduleArgs) ToRecurrentScheduleOutput() RecurrentScheduleOutput {
	return i.ToRecurrentScheduleOutputWithContext(context.Background())
}

func (i RecurrentScheduleArgs) ToRecurrentScheduleOutputWithContext(ctx context.Context) RecurrentScheduleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrentScheduleOutput)
}

func (i RecurrentScheduleArgs) ToRecurrentSchedulePtrOutput() RecurrentSchedulePtrOutput {
	return i.ToRecurrentSchedulePtrOutputWithContext(context.Background())
}

func (i RecurrentScheduleArgs) ToRecurrentSchedulePtrOutputWithContext(ctx context.Context) RecurrentSchedulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrentScheduleOutput).ToRecurrentSchedulePtrOutputWithContext(ctx)
}

// RecurrentSchedulePtrInput is an input type that accepts RecurrentScheduleArgs, RecurrentSchedulePtr and RecurrentSchedulePtrOutput values.
// You can construct a concrete instance of `RecurrentSchedulePtrInput` via:
//
//          RecurrentScheduleArgs{...}
//
//  or:
//
//          nil
type RecurrentSchedulePtrInput interface {
	pulumi.Input

	ToRecurrentSchedulePtrOutput() RecurrentSchedulePtrOutput
	ToRecurrentSchedulePtrOutputWithContext(context.Context) RecurrentSchedulePtrOutput
}

type recurrentSchedulePtrType RecurrentScheduleArgs

func RecurrentSchedulePtr(v *RecurrentScheduleArgs) RecurrentSchedulePtrInput {
	return (*recurrentSchedulePtrType)(v)
}

func (*recurrentSchedulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrentSchedule)(nil)).Elem()
}

func (i *recurrentSchedulePtrType) ToRecurrentSchedulePtrOutput() RecurrentSchedulePtrOutput {
	return i.ToRecurrentSchedulePtrOutputWithContext(context.Background())
}

func (i *recurrentSchedulePtrType) ToRecurrentSchedulePtrOutputWithContext(ctx context.Context) RecurrentSchedulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrentSchedulePtrOutput)
}

// The scheduling constraints for when the profile begins.
type RecurrentScheduleOutput struct{ *pulumi.OutputState }

func (RecurrentScheduleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrentSchedule)(nil)).Elem()
}

func (o RecurrentScheduleOutput) ToRecurrentScheduleOutput() RecurrentScheduleOutput {
	return o
}

func (o RecurrentScheduleOutput) ToRecurrentScheduleOutputWithContext(ctx context.Context) RecurrentScheduleOutput {
	return o
}

func (o RecurrentScheduleOutput) ToRecurrentSchedulePtrOutput() RecurrentSchedulePtrOutput {
	return o.ToRecurrentSchedulePtrOutputWithContext(context.Background())
}

func (o RecurrentScheduleOutput) ToRecurrentSchedulePtrOutputWithContext(ctx context.Context) RecurrentSchedulePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RecurrentSchedule) *RecurrentSchedule {
		return &v
	}).(RecurrentSchedulePtrOutput)
}

// the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
func (o RecurrentScheduleOutput) Days() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RecurrentSchedule) []string { return v.Days }).(pulumi.StringArrayOutput)
}

// A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
func (o RecurrentScheduleOutput) Hours() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrentSchedule) []int { return v.Hours }).(pulumi.IntArrayOutput)
}

// A collection of minutes at which the profile takes effect at.
func (o RecurrentScheduleOutput) Minutes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrentSchedule) []int { return v.Minutes }).(pulumi.IntArrayOutput)
}

// the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
func (o RecurrentScheduleOutput) TimeZone() pulumi.StringOutput {
	return o.ApplyT(func(v RecurrentSchedule) string { return v.TimeZone }).(pulumi.StringOutput)
}

type RecurrentSchedulePtrOutput struct{ *pulumi.OutputState }

func (RecurrentSchedulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrentSchedule)(nil)).Elem()
}

func (o RecurrentSchedulePtrOutput) ToRecurrentSchedulePtrOutput() RecurrentSchedulePtrOutput {
	return o
}

func (o RecurrentSchedulePtrOutput) ToRecurrentSchedulePtrOutputWithContext(ctx context.Context) RecurrentSchedulePtrOutput {
	return o
}

func (o RecurrentSchedulePtrOutput) Elem() RecurrentScheduleOutput {
	return o.ApplyT(func(v *RecurrentSchedule) RecurrentSchedule {
		if v != nil {
			return *v
		}
		var ret RecurrentSchedule
		return ret
	}).(RecurrentScheduleOutput)
}

// the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
func (o RecurrentSchedulePtrOutput) Days() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RecurrentSchedule) []string {
		if v == nil {
			return nil
		}
		return v.Days
	}).(pulumi.StringArrayOutput)
}

// A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
func (o RecurrentSchedulePtrOutput) Hours() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrentSchedule) []int {
		if v == nil {
			return nil
		}
		return v.Hours
	}).(pulumi.IntArrayOutput)
}

// A collection of minutes at which the profile takes effect at.
func (o RecurrentSchedulePtrOutput) Minutes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrentSchedule) []int {
		if v == nil {
			return nil
		}
		return v.Minutes
	}).(pulumi.IntArrayOutput)
}

// the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
func (o RecurrentSchedulePtrOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrentSchedule) *string {
		if v == nil {
			return nil
		}
		return &v.TimeZone
	}).(pulumi.StringPtrOutput)
}

// The scheduling constraints for when the profile begins.
type RecurrentScheduleResponse struct {
	// the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
	Days []string `pulumi:"days"`
	// A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
	Hours []int `pulumi:"hours"`
	// A collection of minutes at which the profile takes effect at.
	Minutes []int `pulumi:"minutes"`
	// the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone string `pulumi:"timeZone"`
}

// RecurrentScheduleResponseInput is an input type that accepts RecurrentScheduleResponseArgs and RecurrentScheduleResponseOutput values.
// You can construct a concrete instance of `RecurrentScheduleResponseInput` via:
//
//          RecurrentScheduleResponseArgs{...}
type RecurrentScheduleResponseInput interface {
	pulumi.Input

	ToRecurrentScheduleResponseOutput() RecurrentScheduleResponseOutput
	ToRecurrentScheduleResponseOutputWithContext(context.Context) RecurrentScheduleResponseOutput
}

// The scheduling constraints for when the profile begins.
type RecurrentScheduleResponseArgs struct {
	// the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
	Days pulumi.StringArrayInput `pulumi:"days"`
	// A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
	Hours pulumi.IntArrayInput `pulumi:"hours"`
	// A collection of minutes at which the profile takes effect at.
	Minutes pulumi.IntArrayInput `pulumi:"minutes"`
	// the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone pulumi.StringInput `pulumi:"timeZone"`
}

func (RecurrentScheduleResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrentScheduleResponse)(nil)).Elem()
}

func (i RecurrentScheduleResponseArgs) ToRecurrentScheduleResponseOutput() RecurrentScheduleResponseOutput {
	return i.ToRecurrentScheduleResponseOutputWithContext(context.Background())
}

func (i RecurrentScheduleResponseArgs) ToRecurrentScheduleResponseOutputWithContext(ctx context.Context) RecurrentScheduleResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrentScheduleResponseOutput)
}

func (i RecurrentScheduleResponseArgs) ToRecurrentScheduleResponsePtrOutput() RecurrentScheduleResponsePtrOutput {
	return i.ToRecurrentScheduleResponsePtrOutputWithContext(context.Background())
}

func (i RecurrentScheduleResponseArgs) ToRecurrentScheduleResponsePtrOutputWithContext(ctx context.Context) RecurrentScheduleResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrentScheduleResponseOutput).ToRecurrentScheduleResponsePtrOutputWithContext(ctx)
}

// RecurrentScheduleResponsePtrInput is an input type that accepts RecurrentScheduleResponseArgs, RecurrentScheduleResponsePtr and RecurrentScheduleResponsePtrOutput values.
// You can construct a concrete instance of `RecurrentScheduleResponsePtrInput` via:
//
//          RecurrentScheduleResponseArgs{...}
//
//  or:
//
//          nil
type RecurrentScheduleResponsePtrInput interface {
	pulumi.Input

	ToRecurrentScheduleResponsePtrOutput() RecurrentScheduleResponsePtrOutput
	ToRecurrentScheduleResponsePtrOutputWithContext(context.Context) RecurrentScheduleResponsePtrOutput
}

type recurrentScheduleResponsePtrType RecurrentScheduleResponseArgs

func RecurrentScheduleResponsePtr(v *RecurrentScheduleResponseArgs) RecurrentScheduleResponsePtrInput {
	return (*recurrentScheduleResponsePtrType)(v)
}

func (*recurrentScheduleResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrentScheduleResponse)(nil)).Elem()
}

func (i *recurrentScheduleResponsePtrType) ToRecurrentScheduleResponsePtrOutput() RecurrentScheduleResponsePtrOutput {
	return i.ToRecurrentScheduleResponsePtrOutputWithContext(context.Background())
}

func (i *recurrentScheduleResponsePtrType) ToRecurrentScheduleResponsePtrOutputWithContext(ctx context.Context) RecurrentScheduleResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurrentScheduleResponsePtrOutput)
}

// The scheduling constraints for when the profile begins.
type RecurrentScheduleResponseOutput struct{ *pulumi.OutputState }

func (RecurrentScheduleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurrentScheduleResponse)(nil)).Elem()
}

func (o RecurrentScheduleResponseOutput) ToRecurrentScheduleResponseOutput() RecurrentScheduleResponseOutput {
	return o
}

func (o RecurrentScheduleResponseOutput) ToRecurrentScheduleResponseOutputWithContext(ctx context.Context) RecurrentScheduleResponseOutput {
	return o
}

func (o RecurrentScheduleResponseOutput) ToRecurrentScheduleResponsePtrOutput() RecurrentScheduleResponsePtrOutput {
	return o.ToRecurrentScheduleResponsePtrOutputWithContext(context.Background())
}

func (o RecurrentScheduleResponseOutput) ToRecurrentScheduleResponsePtrOutputWithContext(ctx context.Context) RecurrentScheduleResponsePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RecurrentScheduleResponse) *RecurrentScheduleResponse {
		return &v
	}).(RecurrentScheduleResponsePtrOutput)
}

// the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
func (o RecurrentScheduleResponseOutput) Days() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RecurrentScheduleResponse) []string { return v.Days }).(pulumi.StringArrayOutput)
}

// A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
func (o RecurrentScheduleResponseOutput) Hours() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrentScheduleResponse) []int { return v.Hours }).(pulumi.IntArrayOutput)
}

// A collection of minutes at which the profile takes effect at.
func (o RecurrentScheduleResponseOutput) Minutes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RecurrentScheduleResponse) []int { return v.Minutes }).(pulumi.IntArrayOutput)
}

// the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
func (o RecurrentScheduleResponseOutput) TimeZone() pulumi.StringOutput {
	return o.ApplyT(func(v RecurrentScheduleResponse) string { return v.TimeZone }).(pulumi.StringOutput)
}

type RecurrentScheduleResponsePtrOutput struct{ *pulumi.OutputState }

func (RecurrentScheduleResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurrentScheduleResponse)(nil)).Elem()
}

func (o RecurrentScheduleResponsePtrOutput) ToRecurrentScheduleResponsePtrOutput() RecurrentScheduleResponsePtrOutput {
	return o
}

func (o RecurrentScheduleResponsePtrOutput) ToRecurrentScheduleResponsePtrOutputWithContext(ctx context.Context) RecurrentScheduleResponsePtrOutput {
	return o
}

func (o RecurrentScheduleResponsePtrOutput) Elem() RecurrentScheduleResponseOutput {
	return o.ApplyT(func(v *RecurrentScheduleResponse) RecurrentScheduleResponse {
		if v != nil {
			return *v
		}
		var ret RecurrentScheduleResponse
		return ret
	}).(RecurrentScheduleResponseOutput)
}

// the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
func (o RecurrentScheduleResponsePtrOutput) Days() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RecurrentScheduleResponse) []string {
		if v == nil {
			return nil
		}
		return v.Days
	}).(pulumi.StringArrayOutput)
}

// A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
func (o RecurrentScheduleResponsePtrOutput) Hours() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrentScheduleResponse) []int {
		if v == nil {
			return nil
		}
		return v.Hours
	}).(pulumi.IntArrayOutput)
}

// A collection of minutes at which the profile takes effect at.
func (o RecurrentScheduleResponsePtrOutput) Minutes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *RecurrentScheduleResponse) []int {
		if v == nil {
			return nil
		}
		return v.Minutes
	}).(pulumi.IntArrayOutput)
}

// the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
func (o RecurrentScheduleResponsePtrOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RecurrentScheduleResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TimeZone
	}).(pulumi.StringPtrOutput)
}

// Specifies the action to send email when the rule condition is evaluated. The discriminator is always RuleEmailAction in this case.
type RuleEmailAction struct {
	// the list of administrator's custom email addresses to notify of the activation of the alert.
	CustomEmails []string `pulumi:"customEmails"`
	// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleEmailAction'.
	OdataType string `pulumi:"odataType"`
	// Whether the administrators (service and co-administrators) of the service should be notified when the alert is activated.
	SendToServiceOwners *bool `pulumi:"sendToServiceOwners"`
}

// RuleEmailActionInput is an input type that accepts RuleEmailActionArgs and RuleEmailActionOutput values.
// You can construct a concrete instance of `RuleEmailActionInput` via:
//
//          RuleEmailActionArgs{...}
type RuleEmailActionInput interface {
	pulumi.Input

	ToRuleEmailActionOutput() RuleEmailActionOutput
	ToRuleEmailActionOutputWithContext(context.Context) RuleEmailActionOutput
}

// Specifies the action to send email when the rule condition is evaluated. The discriminator is always RuleEmailAction in this case.
type RuleEmailActionArgs struct {
	// the list of administrator's custom email addresses to notify of the activation of the alert.
	CustomEmails pulumi.StringArrayInput `pulumi:"customEmails"`
	// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleEmailAction'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Whether the administrators (service and co-administrators) of the service should be notified when the alert is activated.
	SendToServiceOwners pulumi.BoolPtrInput `pulumi:"sendToServiceOwners"`
}

func (RuleEmailActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleEmailAction)(nil)).Elem()
}

func (i RuleEmailActionArgs) ToRuleEmailActionOutput() RuleEmailActionOutput {
	return i.ToRuleEmailActionOutputWithContext(context.Background())
}

func (i RuleEmailActionArgs) ToRuleEmailActionOutputWithContext(ctx context.Context) RuleEmailActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleEmailActionOutput)
}

// Specifies the action to send email when the rule condition is evaluated. The discriminator is always RuleEmailAction in this case.
type RuleEmailActionOutput struct{ *pulumi.OutputState }

func (RuleEmailActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleEmailAction)(nil)).Elem()
}

func (o RuleEmailActionOutput) ToRuleEmailActionOutput() RuleEmailActionOutput {
	return o
}

func (o RuleEmailActionOutput) ToRuleEmailActionOutputWithContext(ctx context.Context) RuleEmailActionOutput {
	return o
}

// the list of administrator's custom email addresses to notify of the activation of the alert.
func (o RuleEmailActionOutput) CustomEmails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleEmailAction) []string { return v.CustomEmails }).(pulumi.StringArrayOutput)
}

// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleEmailAction'.
func (o RuleEmailActionOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleEmailAction) string { return v.OdataType }).(pulumi.StringOutput)
}

// Whether the administrators (service and co-administrators) of the service should be notified when the alert is activated.
func (o RuleEmailActionOutput) SendToServiceOwners() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v RuleEmailAction) *bool { return v.SendToServiceOwners }).(pulumi.BoolPtrOutput)
}

// Specifies the action to send email when the rule condition is evaluated. The discriminator is always RuleEmailAction in this case.
type RuleEmailActionResponse struct {
	// the list of administrator's custom email addresses to notify of the activation of the alert.
	CustomEmails []string `pulumi:"customEmails"`
	// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleEmailAction'.
	OdataType string `pulumi:"odataType"`
	// Whether the administrators (service and co-administrators) of the service should be notified when the alert is activated.
	SendToServiceOwners *bool `pulumi:"sendToServiceOwners"`
}

// RuleEmailActionResponseInput is an input type that accepts RuleEmailActionResponseArgs and RuleEmailActionResponseOutput values.
// You can construct a concrete instance of `RuleEmailActionResponseInput` via:
//
//          RuleEmailActionResponseArgs{...}
type RuleEmailActionResponseInput interface {
	pulumi.Input

	ToRuleEmailActionResponseOutput() RuleEmailActionResponseOutput
	ToRuleEmailActionResponseOutputWithContext(context.Context) RuleEmailActionResponseOutput
}

// Specifies the action to send email when the rule condition is evaluated. The discriminator is always RuleEmailAction in this case.
type RuleEmailActionResponseArgs struct {
	// the list of administrator's custom email addresses to notify of the activation of the alert.
	CustomEmails pulumi.StringArrayInput `pulumi:"customEmails"`
	// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleEmailAction'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// Whether the administrators (service and co-administrators) of the service should be notified when the alert is activated.
	SendToServiceOwners pulumi.BoolPtrInput `pulumi:"sendToServiceOwners"`
}

func (RuleEmailActionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleEmailActionResponse)(nil)).Elem()
}

func (i RuleEmailActionResponseArgs) ToRuleEmailActionResponseOutput() RuleEmailActionResponseOutput {
	return i.ToRuleEmailActionResponseOutputWithContext(context.Background())
}

func (i RuleEmailActionResponseArgs) ToRuleEmailActionResponseOutputWithContext(ctx context.Context) RuleEmailActionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleEmailActionResponseOutput)
}

// Specifies the action to send email when the rule condition is evaluated. The discriminator is always RuleEmailAction in this case.
type RuleEmailActionResponseOutput struct{ *pulumi.OutputState }

func (RuleEmailActionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleEmailActionResponse)(nil)).Elem()
}

func (o RuleEmailActionResponseOutput) ToRuleEmailActionResponseOutput() RuleEmailActionResponseOutput {
	return o
}

func (o RuleEmailActionResponseOutput) ToRuleEmailActionResponseOutputWithContext(ctx context.Context) RuleEmailActionResponseOutput {
	return o
}

// the list of administrator's custom email addresses to notify of the activation of the alert.
func (o RuleEmailActionResponseOutput) CustomEmails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleEmailActionResponse) []string { return v.CustomEmails }).(pulumi.StringArrayOutput)
}

// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleEmailAction'.
func (o RuleEmailActionResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleEmailActionResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// Whether the administrators (service and co-administrators) of the service should be notified when the alert is activated.
func (o RuleEmailActionResponseOutput) SendToServiceOwners() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v RuleEmailActionResponse) *bool { return v.SendToServiceOwners }).(pulumi.BoolPtrOutput)
}

// The claims for a rule management event data source.
type RuleManagementEventClaimsDataSource struct {
	// the email address.
	EmailAddress *string `pulumi:"emailAddress"`
}

// RuleManagementEventClaimsDataSourceInput is an input type that accepts RuleManagementEventClaimsDataSourceArgs and RuleManagementEventClaimsDataSourceOutput values.
// You can construct a concrete instance of `RuleManagementEventClaimsDataSourceInput` via:
//
//          RuleManagementEventClaimsDataSourceArgs{...}
type RuleManagementEventClaimsDataSourceInput interface {
	pulumi.Input

	ToRuleManagementEventClaimsDataSourceOutput() RuleManagementEventClaimsDataSourceOutput
	ToRuleManagementEventClaimsDataSourceOutputWithContext(context.Context) RuleManagementEventClaimsDataSourceOutput
}

// The claims for a rule management event data source.
type RuleManagementEventClaimsDataSourceArgs struct {
	// the email address.
	EmailAddress pulumi.StringPtrInput `pulumi:"emailAddress"`
}

func (RuleManagementEventClaimsDataSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleManagementEventClaimsDataSource)(nil)).Elem()
}

func (i RuleManagementEventClaimsDataSourceArgs) ToRuleManagementEventClaimsDataSourceOutput() RuleManagementEventClaimsDataSourceOutput {
	return i.ToRuleManagementEventClaimsDataSourceOutputWithContext(context.Background())
}

func (i RuleManagementEventClaimsDataSourceArgs) ToRuleManagementEventClaimsDataSourceOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleManagementEventClaimsDataSourceOutput)
}

func (i RuleManagementEventClaimsDataSourceArgs) ToRuleManagementEventClaimsDataSourcePtrOutput() RuleManagementEventClaimsDataSourcePtrOutput {
	return i.ToRuleManagementEventClaimsDataSourcePtrOutputWithContext(context.Background())
}

func (i RuleManagementEventClaimsDataSourceArgs) ToRuleManagementEventClaimsDataSourcePtrOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleManagementEventClaimsDataSourceOutput).ToRuleManagementEventClaimsDataSourcePtrOutputWithContext(ctx)
}

// RuleManagementEventClaimsDataSourcePtrInput is an input type that accepts RuleManagementEventClaimsDataSourceArgs, RuleManagementEventClaimsDataSourcePtr and RuleManagementEventClaimsDataSourcePtrOutput values.
// You can construct a concrete instance of `RuleManagementEventClaimsDataSourcePtrInput` via:
//
//          RuleManagementEventClaimsDataSourceArgs{...}
//
//  or:
//
//          nil
type RuleManagementEventClaimsDataSourcePtrInput interface {
	pulumi.Input

	ToRuleManagementEventClaimsDataSourcePtrOutput() RuleManagementEventClaimsDataSourcePtrOutput
	ToRuleManagementEventClaimsDataSourcePtrOutputWithContext(context.Context) RuleManagementEventClaimsDataSourcePtrOutput
}

type ruleManagementEventClaimsDataSourcePtrType RuleManagementEventClaimsDataSourceArgs

func RuleManagementEventClaimsDataSourcePtr(v *RuleManagementEventClaimsDataSourceArgs) RuleManagementEventClaimsDataSourcePtrInput {
	return (*ruleManagementEventClaimsDataSourcePtrType)(v)
}

func (*ruleManagementEventClaimsDataSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleManagementEventClaimsDataSource)(nil)).Elem()
}

func (i *ruleManagementEventClaimsDataSourcePtrType) ToRuleManagementEventClaimsDataSourcePtrOutput() RuleManagementEventClaimsDataSourcePtrOutput {
	return i.ToRuleManagementEventClaimsDataSourcePtrOutputWithContext(context.Background())
}

func (i *ruleManagementEventClaimsDataSourcePtrType) ToRuleManagementEventClaimsDataSourcePtrOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleManagementEventClaimsDataSourcePtrOutput)
}

// The claims for a rule management event data source.
type RuleManagementEventClaimsDataSourceOutput struct{ *pulumi.OutputState }

func (RuleManagementEventClaimsDataSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleManagementEventClaimsDataSource)(nil)).Elem()
}

func (o RuleManagementEventClaimsDataSourceOutput) ToRuleManagementEventClaimsDataSourceOutput() RuleManagementEventClaimsDataSourceOutput {
	return o
}

func (o RuleManagementEventClaimsDataSourceOutput) ToRuleManagementEventClaimsDataSourceOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourceOutput {
	return o
}

func (o RuleManagementEventClaimsDataSourceOutput) ToRuleManagementEventClaimsDataSourcePtrOutput() RuleManagementEventClaimsDataSourcePtrOutput {
	return o.ToRuleManagementEventClaimsDataSourcePtrOutputWithContext(context.Background())
}

func (o RuleManagementEventClaimsDataSourceOutput) ToRuleManagementEventClaimsDataSourcePtrOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleManagementEventClaimsDataSource) *RuleManagementEventClaimsDataSource {
		return &v
	}).(RuleManagementEventClaimsDataSourcePtrOutput)
}

// the email address.
func (o RuleManagementEventClaimsDataSourceOutput) EmailAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventClaimsDataSource) *string { return v.EmailAddress }).(pulumi.StringPtrOutput)
}

type RuleManagementEventClaimsDataSourcePtrOutput struct{ *pulumi.OutputState }

func (RuleManagementEventClaimsDataSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleManagementEventClaimsDataSource)(nil)).Elem()
}

func (o RuleManagementEventClaimsDataSourcePtrOutput) ToRuleManagementEventClaimsDataSourcePtrOutput() RuleManagementEventClaimsDataSourcePtrOutput {
	return o
}

func (o RuleManagementEventClaimsDataSourcePtrOutput) ToRuleManagementEventClaimsDataSourcePtrOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourcePtrOutput {
	return o
}

func (o RuleManagementEventClaimsDataSourcePtrOutput) Elem() RuleManagementEventClaimsDataSourceOutput {
	return o.ApplyT(func(v *RuleManagementEventClaimsDataSource) RuleManagementEventClaimsDataSource {
		if v != nil {
			return *v
		}
		var ret RuleManagementEventClaimsDataSource
		return ret
	}).(RuleManagementEventClaimsDataSourceOutput)
}

// the email address.
func (o RuleManagementEventClaimsDataSourcePtrOutput) EmailAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleManagementEventClaimsDataSource) *string {
		if v == nil {
			return nil
		}
		return v.EmailAddress
	}).(pulumi.StringPtrOutput)
}

// The claims for a rule management event data source.
type RuleManagementEventClaimsDataSourceResponse struct {
	// the email address.
	EmailAddress *string `pulumi:"emailAddress"`
}

// RuleManagementEventClaimsDataSourceResponseInput is an input type that accepts RuleManagementEventClaimsDataSourceResponseArgs and RuleManagementEventClaimsDataSourceResponseOutput values.
// You can construct a concrete instance of `RuleManagementEventClaimsDataSourceResponseInput` via:
//
//          RuleManagementEventClaimsDataSourceResponseArgs{...}
type RuleManagementEventClaimsDataSourceResponseInput interface {
	pulumi.Input

	ToRuleManagementEventClaimsDataSourceResponseOutput() RuleManagementEventClaimsDataSourceResponseOutput
	ToRuleManagementEventClaimsDataSourceResponseOutputWithContext(context.Context) RuleManagementEventClaimsDataSourceResponseOutput
}

// The claims for a rule management event data source.
type RuleManagementEventClaimsDataSourceResponseArgs struct {
	// the email address.
	EmailAddress pulumi.StringPtrInput `pulumi:"emailAddress"`
}

func (RuleManagementEventClaimsDataSourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleManagementEventClaimsDataSourceResponse)(nil)).Elem()
}

func (i RuleManagementEventClaimsDataSourceResponseArgs) ToRuleManagementEventClaimsDataSourceResponseOutput() RuleManagementEventClaimsDataSourceResponseOutput {
	return i.ToRuleManagementEventClaimsDataSourceResponseOutputWithContext(context.Background())
}

func (i RuleManagementEventClaimsDataSourceResponseArgs) ToRuleManagementEventClaimsDataSourceResponseOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleManagementEventClaimsDataSourceResponseOutput)
}

func (i RuleManagementEventClaimsDataSourceResponseArgs) ToRuleManagementEventClaimsDataSourceResponsePtrOutput() RuleManagementEventClaimsDataSourceResponsePtrOutput {
	return i.ToRuleManagementEventClaimsDataSourceResponsePtrOutputWithContext(context.Background())
}

func (i RuleManagementEventClaimsDataSourceResponseArgs) ToRuleManagementEventClaimsDataSourceResponsePtrOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleManagementEventClaimsDataSourceResponseOutput).ToRuleManagementEventClaimsDataSourceResponsePtrOutputWithContext(ctx)
}

// RuleManagementEventClaimsDataSourceResponsePtrInput is an input type that accepts RuleManagementEventClaimsDataSourceResponseArgs, RuleManagementEventClaimsDataSourceResponsePtr and RuleManagementEventClaimsDataSourceResponsePtrOutput values.
// You can construct a concrete instance of `RuleManagementEventClaimsDataSourceResponsePtrInput` via:
//
//          RuleManagementEventClaimsDataSourceResponseArgs{...}
//
//  or:
//
//          nil
type RuleManagementEventClaimsDataSourceResponsePtrInput interface {
	pulumi.Input

	ToRuleManagementEventClaimsDataSourceResponsePtrOutput() RuleManagementEventClaimsDataSourceResponsePtrOutput
	ToRuleManagementEventClaimsDataSourceResponsePtrOutputWithContext(context.Context) RuleManagementEventClaimsDataSourceResponsePtrOutput
}

type ruleManagementEventClaimsDataSourceResponsePtrType RuleManagementEventClaimsDataSourceResponseArgs

func RuleManagementEventClaimsDataSourceResponsePtr(v *RuleManagementEventClaimsDataSourceResponseArgs) RuleManagementEventClaimsDataSourceResponsePtrInput {
	return (*ruleManagementEventClaimsDataSourceResponsePtrType)(v)
}

func (*ruleManagementEventClaimsDataSourceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleManagementEventClaimsDataSourceResponse)(nil)).Elem()
}

func (i *ruleManagementEventClaimsDataSourceResponsePtrType) ToRuleManagementEventClaimsDataSourceResponsePtrOutput() RuleManagementEventClaimsDataSourceResponsePtrOutput {
	return i.ToRuleManagementEventClaimsDataSourceResponsePtrOutputWithContext(context.Background())
}

func (i *ruleManagementEventClaimsDataSourceResponsePtrType) ToRuleManagementEventClaimsDataSourceResponsePtrOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleManagementEventClaimsDataSourceResponsePtrOutput)
}

// The claims for a rule management event data source.
type RuleManagementEventClaimsDataSourceResponseOutput struct{ *pulumi.OutputState }

func (RuleManagementEventClaimsDataSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleManagementEventClaimsDataSourceResponse)(nil)).Elem()
}

func (o RuleManagementEventClaimsDataSourceResponseOutput) ToRuleManagementEventClaimsDataSourceResponseOutput() RuleManagementEventClaimsDataSourceResponseOutput {
	return o
}

func (o RuleManagementEventClaimsDataSourceResponseOutput) ToRuleManagementEventClaimsDataSourceResponseOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourceResponseOutput {
	return o
}

func (o RuleManagementEventClaimsDataSourceResponseOutput) ToRuleManagementEventClaimsDataSourceResponsePtrOutput() RuleManagementEventClaimsDataSourceResponsePtrOutput {
	return o.ToRuleManagementEventClaimsDataSourceResponsePtrOutputWithContext(context.Background())
}

func (o RuleManagementEventClaimsDataSourceResponseOutput) ToRuleManagementEventClaimsDataSourceResponsePtrOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourceResponsePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleManagementEventClaimsDataSourceResponse) *RuleManagementEventClaimsDataSourceResponse {
		return &v
	}).(RuleManagementEventClaimsDataSourceResponsePtrOutput)
}

// the email address.
func (o RuleManagementEventClaimsDataSourceResponseOutput) EmailAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventClaimsDataSourceResponse) *string { return v.EmailAddress }).(pulumi.StringPtrOutput)
}

type RuleManagementEventClaimsDataSourceResponsePtrOutput struct{ *pulumi.OutputState }

func (RuleManagementEventClaimsDataSourceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleManagementEventClaimsDataSourceResponse)(nil)).Elem()
}

func (o RuleManagementEventClaimsDataSourceResponsePtrOutput) ToRuleManagementEventClaimsDataSourceResponsePtrOutput() RuleManagementEventClaimsDataSourceResponsePtrOutput {
	return o
}

func (o RuleManagementEventClaimsDataSourceResponsePtrOutput) ToRuleManagementEventClaimsDataSourceResponsePtrOutputWithContext(ctx context.Context) RuleManagementEventClaimsDataSourceResponsePtrOutput {
	return o
}

func (o RuleManagementEventClaimsDataSourceResponsePtrOutput) Elem() RuleManagementEventClaimsDataSourceResponseOutput {
	return o.ApplyT(func(v *RuleManagementEventClaimsDataSourceResponse) RuleManagementEventClaimsDataSourceResponse {
		if v != nil {
			return *v
		}
		var ret RuleManagementEventClaimsDataSourceResponse
		return ret
	}).(RuleManagementEventClaimsDataSourceResponseOutput)
}

// the email address.
func (o RuleManagementEventClaimsDataSourceResponsePtrOutput) EmailAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleManagementEventClaimsDataSourceResponse) *string {
		if v == nil {
			return nil
		}
		return v.EmailAddress
	}).(pulumi.StringPtrOutput)
}

// A rule management event data source. The discriminator fields is always RuleManagementEventDataSource in this case.
type RuleManagementEventDataSource struct {
	// the claims.
	Claims *RuleManagementEventClaimsDataSource `pulumi:"claims"`
	// the event name.
	EventName *string `pulumi:"eventName"`
	// the event source.
	EventSource *string `pulumi:"eventSource"`
	// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	LegacyResourceId *string `pulumi:"legacyResourceId"`
	// the level.
	Level *string `pulumi:"level"`
	// the namespace of the metric.
	MetricNamespace *string `pulumi:"metricNamespace"`
	// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource'.
	OdataType string `pulumi:"odataType"`
	// The name of the operation that should be checked for. If no name is provided, any operation will match.
	OperationName *string `pulumi:"operationName"`
	// the resource group name.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// the location of the resource.
	ResourceLocation *string `pulumi:"resourceLocation"`
	// the resource provider name.
	ResourceProviderName *string `pulumi:"resourceProviderName"`
	// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	ResourceUri *string `pulumi:"resourceUri"`
	// The status of the operation that should be checked for. If no status is provided, any status will match.
	Status *string `pulumi:"status"`
	// the substatus.
	SubStatus *string `pulumi:"subStatus"`
}

// RuleManagementEventDataSourceInput is an input type that accepts RuleManagementEventDataSourceArgs and RuleManagementEventDataSourceOutput values.
// You can construct a concrete instance of `RuleManagementEventDataSourceInput` via:
//
//          RuleManagementEventDataSourceArgs{...}
type RuleManagementEventDataSourceInput interface {
	pulumi.Input

	ToRuleManagementEventDataSourceOutput() RuleManagementEventDataSourceOutput
	ToRuleManagementEventDataSourceOutputWithContext(context.Context) RuleManagementEventDataSourceOutput
}

// A rule management event data source. The discriminator fields is always RuleManagementEventDataSource in this case.
type RuleManagementEventDataSourceArgs struct {
	// the claims.
	Claims RuleManagementEventClaimsDataSourcePtrInput `pulumi:"claims"`
	// the event name.
	EventName pulumi.StringPtrInput `pulumi:"eventName"`
	// the event source.
	EventSource pulumi.StringPtrInput `pulumi:"eventSource"`
	// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	LegacyResourceId pulumi.StringPtrInput `pulumi:"legacyResourceId"`
	// the level.
	Level pulumi.StringPtrInput `pulumi:"level"`
	// the namespace of the metric.
	MetricNamespace pulumi.StringPtrInput `pulumi:"metricNamespace"`
	// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The name of the operation that should be checked for. If no name is provided, any operation will match.
	OperationName pulumi.StringPtrInput `pulumi:"operationName"`
	// the resource group name.
	ResourceGroupName pulumi.StringPtrInput `pulumi:"resourceGroupName"`
	// the location of the resource.
	ResourceLocation pulumi.StringPtrInput `pulumi:"resourceLocation"`
	// the resource provider name.
	ResourceProviderName pulumi.StringPtrInput `pulumi:"resourceProviderName"`
	// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	ResourceUri pulumi.StringPtrInput `pulumi:"resourceUri"`
	// The status of the operation that should be checked for. If no status is provided, any status will match.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// the substatus.
	SubStatus pulumi.StringPtrInput `pulumi:"subStatus"`
}

func (RuleManagementEventDataSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleManagementEventDataSource)(nil)).Elem()
}

func (i RuleManagementEventDataSourceArgs) ToRuleManagementEventDataSourceOutput() RuleManagementEventDataSourceOutput {
	return i.ToRuleManagementEventDataSourceOutputWithContext(context.Background())
}

func (i RuleManagementEventDataSourceArgs) ToRuleManagementEventDataSourceOutputWithContext(ctx context.Context) RuleManagementEventDataSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleManagementEventDataSourceOutput)
}

// A rule management event data source. The discriminator fields is always RuleManagementEventDataSource in this case.
type RuleManagementEventDataSourceOutput struct{ *pulumi.OutputState }

func (RuleManagementEventDataSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleManagementEventDataSource)(nil)).Elem()
}

func (o RuleManagementEventDataSourceOutput) ToRuleManagementEventDataSourceOutput() RuleManagementEventDataSourceOutput {
	return o
}

func (o RuleManagementEventDataSourceOutput) ToRuleManagementEventDataSourceOutputWithContext(ctx context.Context) RuleManagementEventDataSourceOutput {
	return o
}

// the claims.
func (o RuleManagementEventDataSourceOutput) Claims() RuleManagementEventClaimsDataSourcePtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *RuleManagementEventClaimsDataSource { return v.Claims }).(RuleManagementEventClaimsDataSourcePtrOutput)
}

// the event name.
func (o RuleManagementEventDataSourceOutput) EventName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.EventName }).(pulumi.StringPtrOutput)
}

// the event source.
func (o RuleManagementEventDataSourceOutput) EventSource() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.EventSource }).(pulumi.StringPtrOutput)
}

// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
func (o RuleManagementEventDataSourceOutput) LegacyResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.LegacyResourceId }).(pulumi.StringPtrOutput)
}

// the level.
func (o RuleManagementEventDataSourceOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.Level }).(pulumi.StringPtrOutput)
}

// the namespace of the metric.
func (o RuleManagementEventDataSourceOutput) MetricNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.MetricNamespace }).(pulumi.StringPtrOutput)
}

// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource'.
func (o RuleManagementEventDataSourceOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) string { return v.OdataType }).(pulumi.StringOutput)
}

// The name of the operation that should be checked for. If no name is provided, any operation will match.
func (o RuleManagementEventDataSourceOutput) OperationName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.OperationName }).(pulumi.StringPtrOutput)
}

// the resource group name.
func (o RuleManagementEventDataSourceOutput) ResourceGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.ResourceGroupName }).(pulumi.StringPtrOutput)
}

// the location of the resource.
func (o RuleManagementEventDataSourceOutput) ResourceLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.ResourceLocation }).(pulumi.StringPtrOutput)
}

// the resource provider name.
func (o RuleManagementEventDataSourceOutput) ResourceProviderName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.ResourceProviderName }).(pulumi.StringPtrOutput)
}

// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
func (o RuleManagementEventDataSourceOutput) ResourceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.ResourceUri }).(pulumi.StringPtrOutput)
}

// The status of the operation that should be checked for. If no status is provided, any status will match.
func (o RuleManagementEventDataSourceOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// the substatus.
func (o RuleManagementEventDataSourceOutput) SubStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSource) *string { return v.SubStatus }).(pulumi.StringPtrOutput)
}

// A rule management event data source. The discriminator fields is always RuleManagementEventDataSource in this case.
type RuleManagementEventDataSourceResponse struct {
	// the claims.
	Claims *RuleManagementEventClaimsDataSourceResponse `pulumi:"claims"`
	// the event name.
	EventName *string `pulumi:"eventName"`
	// the event source.
	EventSource *string `pulumi:"eventSource"`
	// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	LegacyResourceId *string `pulumi:"legacyResourceId"`
	// the level.
	Level *string `pulumi:"level"`
	// the namespace of the metric.
	MetricNamespace *string `pulumi:"metricNamespace"`
	// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource'.
	OdataType string `pulumi:"odataType"`
	// The name of the operation that should be checked for. If no name is provided, any operation will match.
	OperationName *string `pulumi:"operationName"`
	// the resource group name.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// the location of the resource.
	ResourceLocation *string `pulumi:"resourceLocation"`
	// the resource provider name.
	ResourceProviderName *string `pulumi:"resourceProviderName"`
	// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	ResourceUri *string `pulumi:"resourceUri"`
	// The status of the operation that should be checked for. If no status is provided, any status will match.
	Status *string `pulumi:"status"`
	// the substatus.
	SubStatus *string `pulumi:"subStatus"`
}

// RuleManagementEventDataSourceResponseInput is an input type that accepts RuleManagementEventDataSourceResponseArgs and RuleManagementEventDataSourceResponseOutput values.
// You can construct a concrete instance of `RuleManagementEventDataSourceResponseInput` via:
//
//          RuleManagementEventDataSourceResponseArgs{...}
type RuleManagementEventDataSourceResponseInput interface {
	pulumi.Input

	ToRuleManagementEventDataSourceResponseOutput() RuleManagementEventDataSourceResponseOutput
	ToRuleManagementEventDataSourceResponseOutputWithContext(context.Context) RuleManagementEventDataSourceResponseOutput
}

// A rule management event data source. The discriminator fields is always RuleManagementEventDataSource in this case.
type RuleManagementEventDataSourceResponseArgs struct {
	// the claims.
	Claims RuleManagementEventClaimsDataSourceResponsePtrInput `pulumi:"claims"`
	// the event name.
	EventName pulumi.StringPtrInput `pulumi:"eventName"`
	// the event source.
	EventSource pulumi.StringPtrInput `pulumi:"eventSource"`
	// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	LegacyResourceId pulumi.StringPtrInput `pulumi:"legacyResourceId"`
	// the level.
	Level pulumi.StringPtrInput `pulumi:"level"`
	// the namespace of the metric.
	MetricNamespace pulumi.StringPtrInput `pulumi:"metricNamespace"`
	// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// The name of the operation that should be checked for. If no name is provided, any operation will match.
	OperationName pulumi.StringPtrInput `pulumi:"operationName"`
	// the resource group name.
	ResourceGroupName pulumi.StringPtrInput `pulumi:"resourceGroupName"`
	// the location of the resource.
	ResourceLocation pulumi.StringPtrInput `pulumi:"resourceLocation"`
	// the resource provider name.
	ResourceProviderName pulumi.StringPtrInput `pulumi:"resourceProviderName"`
	// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	ResourceUri pulumi.StringPtrInput `pulumi:"resourceUri"`
	// The status of the operation that should be checked for. If no status is provided, any status will match.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// the substatus.
	SubStatus pulumi.StringPtrInput `pulumi:"subStatus"`
}

func (RuleManagementEventDataSourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleManagementEventDataSourceResponse)(nil)).Elem()
}

func (i RuleManagementEventDataSourceResponseArgs) ToRuleManagementEventDataSourceResponseOutput() RuleManagementEventDataSourceResponseOutput {
	return i.ToRuleManagementEventDataSourceResponseOutputWithContext(context.Background())
}

func (i RuleManagementEventDataSourceResponseArgs) ToRuleManagementEventDataSourceResponseOutputWithContext(ctx context.Context) RuleManagementEventDataSourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleManagementEventDataSourceResponseOutput)
}

// A rule management event data source. The discriminator fields is always RuleManagementEventDataSource in this case.
type RuleManagementEventDataSourceResponseOutput struct{ *pulumi.OutputState }

func (RuleManagementEventDataSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleManagementEventDataSourceResponse)(nil)).Elem()
}

func (o RuleManagementEventDataSourceResponseOutput) ToRuleManagementEventDataSourceResponseOutput() RuleManagementEventDataSourceResponseOutput {
	return o
}

func (o RuleManagementEventDataSourceResponseOutput) ToRuleManagementEventDataSourceResponseOutputWithContext(ctx context.Context) RuleManagementEventDataSourceResponseOutput {
	return o
}

// the claims.
func (o RuleManagementEventDataSourceResponseOutput) Claims() RuleManagementEventClaimsDataSourceResponsePtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *RuleManagementEventClaimsDataSourceResponse {
		return v.Claims
	}).(RuleManagementEventClaimsDataSourceResponsePtrOutput)
}

// the event name.
func (o RuleManagementEventDataSourceResponseOutput) EventName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.EventName }).(pulumi.StringPtrOutput)
}

// the event source.
func (o RuleManagementEventDataSourceResponseOutput) EventSource() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.EventSource }).(pulumi.StringPtrOutput)
}

// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
func (o RuleManagementEventDataSourceResponseOutput) LegacyResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.LegacyResourceId }).(pulumi.StringPtrOutput)
}

// the level.
func (o RuleManagementEventDataSourceResponseOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.Level }).(pulumi.StringPtrOutput)
}

// the namespace of the metric.
func (o RuleManagementEventDataSourceResponseOutput) MetricNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.MetricNamespace }).(pulumi.StringPtrOutput)
}

// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource'.
func (o RuleManagementEventDataSourceResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// The name of the operation that should be checked for. If no name is provided, any operation will match.
func (o RuleManagementEventDataSourceResponseOutput) OperationName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.OperationName }).(pulumi.StringPtrOutput)
}

// the resource group name.
func (o RuleManagementEventDataSourceResponseOutput) ResourceGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.ResourceGroupName }).(pulumi.StringPtrOutput)
}

// the location of the resource.
func (o RuleManagementEventDataSourceResponseOutput) ResourceLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.ResourceLocation }).(pulumi.StringPtrOutput)
}

// the resource provider name.
func (o RuleManagementEventDataSourceResponseOutput) ResourceProviderName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.ResourceProviderName }).(pulumi.StringPtrOutput)
}

// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
func (o RuleManagementEventDataSourceResponseOutput) ResourceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.ResourceUri }).(pulumi.StringPtrOutput)
}

// The status of the operation that should be checked for. If no status is provided, any status will match.
func (o RuleManagementEventDataSourceResponseOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// the substatus.
func (o RuleManagementEventDataSourceResponseOutput) SubStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleManagementEventDataSourceResponse) *string { return v.SubStatus }).(pulumi.StringPtrOutput)
}

// A rule metric data source. The discriminator value is always RuleMetricDataSource in this case.
type RuleMetricDataSource struct {
	// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	LegacyResourceId *string `pulumi:"legacyResourceId"`
	// the name of the metric that defines what the rule monitors.
	MetricName *string `pulumi:"metricName"`
	// the namespace of the metric.
	MetricNamespace *string `pulumi:"metricNamespace"`
	// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource'.
	OdataType string `pulumi:"odataType"`
	// the location of the resource.
	ResourceLocation *string `pulumi:"resourceLocation"`
	// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	ResourceUri *string `pulumi:"resourceUri"`
}

// RuleMetricDataSourceInput is an input type that accepts RuleMetricDataSourceArgs and RuleMetricDataSourceOutput values.
// You can construct a concrete instance of `RuleMetricDataSourceInput` via:
//
//          RuleMetricDataSourceArgs{...}
type RuleMetricDataSourceInput interface {
	pulumi.Input

	ToRuleMetricDataSourceOutput() RuleMetricDataSourceOutput
	ToRuleMetricDataSourceOutputWithContext(context.Context) RuleMetricDataSourceOutput
}

// A rule metric data source. The discriminator value is always RuleMetricDataSource in this case.
type RuleMetricDataSourceArgs struct {
	// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	LegacyResourceId pulumi.StringPtrInput `pulumi:"legacyResourceId"`
	// the name of the metric that defines what the rule monitors.
	MetricName pulumi.StringPtrInput `pulumi:"metricName"`
	// the namespace of the metric.
	MetricNamespace pulumi.StringPtrInput `pulumi:"metricNamespace"`
	// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// the location of the resource.
	ResourceLocation pulumi.StringPtrInput `pulumi:"resourceLocation"`
	// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	ResourceUri pulumi.StringPtrInput `pulumi:"resourceUri"`
}

func (RuleMetricDataSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleMetricDataSource)(nil)).Elem()
}

func (i RuleMetricDataSourceArgs) ToRuleMetricDataSourceOutput() RuleMetricDataSourceOutput {
	return i.ToRuleMetricDataSourceOutputWithContext(context.Background())
}

func (i RuleMetricDataSourceArgs) ToRuleMetricDataSourceOutputWithContext(ctx context.Context) RuleMetricDataSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleMetricDataSourceOutput)
}

// A rule metric data source. The discriminator value is always RuleMetricDataSource in this case.
type RuleMetricDataSourceOutput struct{ *pulumi.OutputState }

func (RuleMetricDataSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleMetricDataSource)(nil)).Elem()
}

func (o RuleMetricDataSourceOutput) ToRuleMetricDataSourceOutput() RuleMetricDataSourceOutput {
	return o
}

func (o RuleMetricDataSourceOutput) ToRuleMetricDataSourceOutputWithContext(ctx context.Context) RuleMetricDataSourceOutput {
	return o
}

// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
func (o RuleMetricDataSourceOutput) LegacyResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSource) *string { return v.LegacyResourceId }).(pulumi.StringPtrOutput)
}

// the name of the metric that defines what the rule monitors.
func (o RuleMetricDataSourceOutput) MetricName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSource) *string { return v.MetricName }).(pulumi.StringPtrOutput)
}

// the namespace of the metric.
func (o RuleMetricDataSourceOutput) MetricNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSource) *string { return v.MetricNamespace }).(pulumi.StringPtrOutput)
}

// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource'.
func (o RuleMetricDataSourceOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleMetricDataSource) string { return v.OdataType }).(pulumi.StringOutput)
}

// the location of the resource.
func (o RuleMetricDataSourceOutput) ResourceLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSource) *string { return v.ResourceLocation }).(pulumi.StringPtrOutput)
}

// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
func (o RuleMetricDataSourceOutput) ResourceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSource) *string { return v.ResourceUri }).(pulumi.StringPtrOutput)
}

// A rule metric data source. The discriminator value is always RuleMetricDataSource in this case.
type RuleMetricDataSourceResponse struct {
	// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	LegacyResourceId *string `pulumi:"legacyResourceId"`
	// the name of the metric that defines what the rule monitors.
	MetricName *string `pulumi:"metricName"`
	// the namespace of the metric.
	MetricNamespace *string `pulumi:"metricNamespace"`
	// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource'.
	OdataType string `pulumi:"odataType"`
	// the location of the resource.
	ResourceLocation *string `pulumi:"resourceLocation"`
	// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	ResourceUri *string `pulumi:"resourceUri"`
}

// RuleMetricDataSourceResponseInput is an input type that accepts RuleMetricDataSourceResponseArgs and RuleMetricDataSourceResponseOutput values.
// You can construct a concrete instance of `RuleMetricDataSourceResponseInput` via:
//
//          RuleMetricDataSourceResponseArgs{...}
type RuleMetricDataSourceResponseInput interface {
	pulumi.Input

	ToRuleMetricDataSourceResponseOutput() RuleMetricDataSourceResponseOutput
	ToRuleMetricDataSourceResponseOutputWithContext(context.Context) RuleMetricDataSourceResponseOutput
}

// A rule metric data source. The discriminator value is always RuleMetricDataSource in this case.
type RuleMetricDataSourceResponseArgs struct {
	// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	LegacyResourceId pulumi.StringPtrInput `pulumi:"legacyResourceId"`
	// the name of the metric that defines what the rule monitors.
	MetricName pulumi.StringPtrInput `pulumi:"metricName"`
	// the namespace of the metric.
	MetricNamespace pulumi.StringPtrInput `pulumi:"metricNamespace"`
	// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// the location of the resource.
	ResourceLocation pulumi.StringPtrInput `pulumi:"resourceLocation"`
	// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
	ResourceUri pulumi.StringPtrInput `pulumi:"resourceUri"`
}

func (RuleMetricDataSourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleMetricDataSourceResponse)(nil)).Elem()
}

func (i RuleMetricDataSourceResponseArgs) ToRuleMetricDataSourceResponseOutput() RuleMetricDataSourceResponseOutput {
	return i.ToRuleMetricDataSourceResponseOutputWithContext(context.Background())
}

func (i RuleMetricDataSourceResponseArgs) ToRuleMetricDataSourceResponseOutputWithContext(ctx context.Context) RuleMetricDataSourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleMetricDataSourceResponseOutput)
}

// A rule metric data source. The discriminator value is always RuleMetricDataSource in this case.
type RuleMetricDataSourceResponseOutput struct{ *pulumi.OutputState }

func (RuleMetricDataSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleMetricDataSourceResponse)(nil)).Elem()
}

func (o RuleMetricDataSourceResponseOutput) ToRuleMetricDataSourceResponseOutput() RuleMetricDataSourceResponseOutput {
	return o
}

func (o RuleMetricDataSourceResponseOutput) ToRuleMetricDataSourceResponseOutputWithContext(ctx context.Context) RuleMetricDataSourceResponseOutput {
	return o
}

// the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
func (o RuleMetricDataSourceResponseOutput) LegacyResourceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSourceResponse) *string { return v.LegacyResourceId }).(pulumi.StringPtrOutput)
}

// the name of the metric that defines what the rule monitors.
func (o RuleMetricDataSourceResponseOutput) MetricName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSourceResponse) *string { return v.MetricName }).(pulumi.StringPtrOutput)
}

// the namespace of the metric.
func (o RuleMetricDataSourceResponseOutput) MetricNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSourceResponse) *string { return v.MetricNamespace }).(pulumi.StringPtrOutput)
}

// specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource
// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource'.
func (o RuleMetricDataSourceResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleMetricDataSourceResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// the location of the resource.
func (o RuleMetricDataSourceResponseOutput) ResourceLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSourceResponse) *string { return v.ResourceLocation }).(pulumi.StringPtrOutput)
}

// the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule.
func (o RuleMetricDataSourceResponseOutput) ResourceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleMetricDataSourceResponse) *string { return v.ResourceUri }).(pulumi.StringPtrOutput)
}

// Specifies the action to post to service when the rule condition is evaluated. The discriminator is always RuleWebhookAction in this case.
type RuleWebhookAction struct {
	// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleWebhookAction'.
	OdataType string `pulumi:"odataType"`
	// the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
	Properties map[string]string `pulumi:"properties"`
	// the service uri to Post the notification when the alert activates or resolves.
	ServiceUri *string `pulumi:"serviceUri"`
}

// RuleWebhookActionInput is an input type that accepts RuleWebhookActionArgs and RuleWebhookActionOutput values.
// You can construct a concrete instance of `RuleWebhookActionInput` via:
//
//          RuleWebhookActionArgs{...}
type RuleWebhookActionInput interface {
	pulumi.Input

	ToRuleWebhookActionOutput() RuleWebhookActionOutput
	ToRuleWebhookActionOutputWithContext(context.Context) RuleWebhookActionOutput
}

// Specifies the action to post to service when the rule condition is evaluated. The discriminator is always RuleWebhookAction in this case.
type RuleWebhookActionArgs struct {
	// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleWebhookAction'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// the service uri to Post the notification when the alert activates or resolves.
	ServiceUri pulumi.StringPtrInput `pulumi:"serviceUri"`
}

func (RuleWebhookActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleWebhookAction)(nil)).Elem()
}

func (i RuleWebhookActionArgs) ToRuleWebhookActionOutput() RuleWebhookActionOutput {
	return i.ToRuleWebhookActionOutputWithContext(context.Background())
}

func (i RuleWebhookActionArgs) ToRuleWebhookActionOutputWithContext(ctx context.Context) RuleWebhookActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleWebhookActionOutput)
}

// Specifies the action to post to service when the rule condition is evaluated. The discriminator is always RuleWebhookAction in this case.
type RuleWebhookActionOutput struct{ *pulumi.OutputState }

func (RuleWebhookActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleWebhookAction)(nil)).Elem()
}

func (o RuleWebhookActionOutput) ToRuleWebhookActionOutput() RuleWebhookActionOutput {
	return o
}

func (o RuleWebhookActionOutput) ToRuleWebhookActionOutputWithContext(ctx context.Context) RuleWebhookActionOutput {
	return o
}

// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleWebhookAction'.
func (o RuleWebhookActionOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleWebhookAction) string { return v.OdataType }).(pulumi.StringOutput)
}

// the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
func (o RuleWebhookActionOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleWebhookAction) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// the service uri to Post the notification when the alert activates or resolves.
func (o RuleWebhookActionOutput) ServiceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleWebhookAction) *string { return v.ServiceUri }).(pulumi.StringPtrOutput)
}

// Specifies the action to post to service when the rule condition is evaluated. The discriminator is always RuleWebhookAction in this case.
type RuleWebhookActionResponse struct {
	// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleWebhookAction'.
	OdataType string `pulumi:"odataType"`
	// the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
	Properties map[string]string `pulumi:"properties"`
	// the service uri to Post the notification when the alert activates or resolves.
	ServiceUri *string `pulumi:"serviceUri"`
}

// RuleWebhookActionResponseInput is an input type that accepts RuleWebhookActionResponseArgs and RuleWebhookActionResponseOutput values.
// You can construct a concrete instance of `RuleWebhookActionResponseInput` via:
//
//          RuleWebhookActionResponseArgs{...}
type RuleWebhookActionResponseInput interface {
	pulumi.Input

	ToRuleWebhookActionResponseOutput() RuleWebhookActionResponseOutput
	ToRuleWebhookActionResponseOutputWithContext(context.Context) RuleWebhookActionResponseOutput
}

// Specifies the action to post to service when the rule condition is evaluated. The discriminator is always RuleWebhookAction in this case.
type RuleWebhookActionResponseArgs struct {
	// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleWebhookAction'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// the service uri to Post the notification when the alert activates or resolves.
	ServiceUri pulumi.StringPtrInput `pulumi:"serviceUri"`
}

func (RuleWebhookActionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleWebhookActionResponse)(nil)).Elem()
}

func (i RuleWebhookActionResponseArgs) ToRuleWebhookActionResponseOutput() RuleWebhookActionResponseOutput {
	return i.ToRuleWebhookActionResponseOutputWithContext(context.Background())
}

func (i RuleWebhookActionResponseArgs) ToRuleWebhookActionResponseOutputWithContext(ctx context.Context) RuleWebhookActionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleWebhookActionResponseOutput)
}

// Specifies the action to post to service when the rule condition is evaluated. The discriminator is always RuleWebhookAction in this case.
type RuleWebhookActionResponseOutput struct{ *pulumi.OutputState }

func (RuleWebhookActionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleWebhookActionResponse)(nil)).Elem()
}

func (o RuleWebhookActionResponseOutput) ToRuleWebhookActionResponseOutput() RuleWebhookActionResponseOutput {
	return o
}

func (o RuleWebhookActionResponseOutput) ToRuleWebhookActionResponseOutputWithContext(ctx context.Context) RuleWebhookActionResponseOutput {
	return o
}

// specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction.
// Expected value is 'Microsoft.Azure.Management.Insights.Models.RuleWebhookAction'.
func (o RuleWebhookActionResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleWebhookActionResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload.
func (o RuleWebhookActionResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleWebhookActionResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// the service uri to Post the notification when the alert activates or resolves.
func (o RuleWebhookActionResponseOutput) ServiceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleWebhookActionResponse) *string { return v.ServiceUri }).(pulumi.StringPtrOutput)
}

// The parameters for the scaling action.
type ScaleAction struct {
	// the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
	Cooldown string `pulumi:"cooldown"`
	// the scale direction. Whether the scaling action increases or decreases the number of instances.
	Direction ScaleDirection `pulumi:"direction"`
	// the type of action that should occur when the scale rule fires.
	Type ScaleType `pulumi:"type"`
	// the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.
	Value *string `pulumi:"value"`
}

// ScaleActionInput is an input type that accepts ScaleActionArgs and ScaleActionOutput values.
// You can construct a concrete instance of `ScaleActionInput` via:
//
//          ScaleActionArgs{...}
type ScaleActionInput interface {
	pulumi.Input

	ToScaleActionOutput() ScaleActionOutput
	ToScaleActionOutputWithContext(context.Context) ScaleActionOutput
}

// The parameters for the scaling action.
type ScaleActionArgs struct {
	// the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
	Cooldown pulumi.StringInput `pulumi:"cooldown"`
	// the scale direction. Whether the scaling action increases or decreases the number of instances.
	Direction ScaleDirectionInput `pulumi:"direction"`
	// the type of action that should occur when the scale rule fires.
	Type ScaleTypeInput `pulumi:"type"`
	// the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ScaleActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleAction)(nil)).Elem()
}

func (i ScaleActionArgs) ToScaleActionOutput() ScaleActionOutput {
	return i.ToScaleActionOutputWithContext(context.Background())
}

func (i ScaleActionArgs) ToScaleActionOutputWithContext(ctx context.Context) ScaleActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleActionOutput)
}

// The parameters for the scaling action.
type ScaleActionOutput struct{ *pulumi.OutputState }

func (ScaleActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleAction)(nil)).Elem()
}

func (o ScaleActionOutput) ToScaleActionOutput() ScaleActionOutput {
	return o
}

func (o ScaleActionOutput) ToScaleActionOutputWithContext(ctx context.Context) ScaleActionOutput {
	return o
}

// the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
func (o ScaleActionOutput) Cooldown() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleAction) string { return v.Cooldown }).(pulumi.StringOutput)
}

// the scale direction. Whether the scaling action increases or decreases the number of instances.
func (o ScaleActionOutput) Direction() ScaleDirectionOutput {
	return o.ApplyT(func(v ScaleAction) ScaleDirection { return v.Direction }).(ScaleDirectionOutput)
}

// the type of action that should occur when the scale rule fires.
func (o ScaleActionOutput) Type() ScaleTypeOutput {
	return o.ApplyT(func(v ScaleAction) ScaleType { return v.Type }).(ScaleTypeOutput)
}

// the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.
func (o ScaleActionOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ScaleAction) *string { return v.Value }).(pulumi.StringPtrOutput)
}

// The parameters for the scaling action.
type ScaleActionResponse struct {
	// the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
	Cooldown string `pulumi:"cooldown"`
	// the scale direction. Whether the scaling action increases or decreases the number of instances.
	Direction string `pulumi:"direction"`
	// the type of action that should occur when the scale rule fires.
	Type string `pulumi:"type"`
	// the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.
	Value *string `pulumi:"value"`
}

// ScaleActionResponseInput is an input type that accepts ScaleActionResponseArgs and ScaleActionResponseOutput values.
// You can construct a concrete instance of `ScaleActionResponseInput` via:
//
//          ScaleActionResponseArgs{...}
type ScaleActionResponseInput interface {
	pulumi.Input

	ToScaleActionResponseOutput() ScaleActionResponseOutput
	ToScaleActionResponseOutputWithContext(context.Context) ScaleActionResponseOutput
}

// The parameters for the scaling action.
type ScaleActionResponseArgs struct {
	// the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
	Cooldown pulumi.StringInput `pulumi:"cooldown"`
	// the scale direction. Whether the scaling action increases or decreases the number of instances.
	Direction pulumi.StringInput `pulumi:"direction"`
	// the type of action that should occur when the scale rule fires.
	Type pulumi.StringInput `pulumi:"type"`
	// the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ScaleActionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleActionResponse)(nil)).Elem()
}

func (i ScaleActionResponseArgs) ToScaleActionResponseOutput() ScaleActionResponseOutput {
	return i.ToScaleActionResponseOutputWithContext(context.Background())
}

func (i ScaleActionResponseArgs) ToScaleActionResponseOutputWithContext(ctx context.Context) ScaleActionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleActionResponseOutput)
}

// The parameters for the scaling action.
type ScaleActionResponseOutput struct{ *pulumi.OutputState }

func (ScaleActionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleActionResponse)(nil)).Elem()
}

func (o ScaleActionResponseOutput) ToScaleActionResponseOutput() ScaleActionResponseOutput {
	return o
}

func (o ScaleActionResponseOutput) ToScaleActionResponseOutputWithContext(ctx context.Context) ScaleActionResponseOutput {
	return o
}

// the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.
func (o ScaleActionResponseOutput) Cooldown() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleActionResponse) string { return v.Cooldown }).(pulumi.StringOutput)
}

// the scale direction. Whether the scaling action increases or decreases the number of instances.
func (o ScaleActionResponseOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleActionResponse) string { return v.Direction }).(pulumi.StringOutput)
}

// the type of action that should occur when the scale rule fires.
func (o ScaleActionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleActionResponse) string { return v.Type }).(pulumi.StringOutput)
}

// the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.
func (o ScaleActionResponseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ScaleActionResponse) *string { return v.Value }).(pulumi.StringPtrOutput)
}

// The number of instances that can be used during this profile.
type ScaleCapacity struct {
	// the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default.
	Default string `pulumi:"default"`
	// the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are available in the subscription.
	Maximum string `pulumi:"maximum"`
	// the minimum number of instances for the resource.
	Minimum string `pulumi:"minimum"`
}

// ScaleCapacityInput is an input type that accepts ScaleCapacityArgs and ScaleCapacityOutput values.
// You can construct a concrete instance of `ScaleCapacityInput` via:
//
//          ScaleCapacityArgs{...}
type ScaleCapacityInput interface {
	pulumi.Input

	ToScaleCapacityOutput() ScaleCapacityOutput
	ToScaleCapacityOutputWithContext(context.Context) ScaleCapacityOutput
}

// The number of instances that can be used during this profile.
type ScaleCapacityArgs struct {
	// the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default.
	Default pulumi.StringInput `pulumi:"default"`
	// the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are available in the subscription.
	Maximum pulumi.StringInput `pulumi:"maximum"`
	// the minimum number of instances for the resource.
	Minimum pulumi.StringInput `pulumi:"minimum"`
}

func (ScaleCapacityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleCapacity)(nil)).Elem()
}

func (i ScaleCapacityArgs) ToScaleCapacityOutput() ScaleCapacityOutput {
	return i.ToScaleCapacityOutputWithContext(context.Background())
}

func (i ScaleCapacityArgs) ToScaleCapacityOutputWithContext(ctx context.Context) ScaleCapacityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleCapacityOutput)
}

// The number of instances that can be used during this profile.
type ScaleCapacityOutput struct{ *pulumi.OutputState }

func (ScaleCapacityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleCapacity)(nil)).Elem()
}

func (o ScaleCapacityOutput) ToScaleCapacityOutput() ScaleCapacityOutput {
	return o
}

func (o ScaleCapacityOutput) ToScaleCapacityOutputWithContext(ctx context.Context) ScaleCapacityOutput {
	return o
}

// the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default.
func (o ScaleCapacityOutput) Default() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleCapacity) string { return v.Default }).(pulumi.StringOutput)
}

// the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are available in the subscription.
func (o ScaleCapacityOutput) Maximum() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleCapacity) string { return v.Maximum }).(pulumi.StringOutput)
}

// the minimum number of instances for the resource.
func (o ScaleCapacityOutput) Minimum() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleCapacity) string { return v.Minimum }).(pulumi.StringOutput)
}

// The number of instances that can be used during this profile.
type ScaleCapacityResponse struct {
	// the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default.
	Default string `pulumi:"default"`
	// the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are available in the subscription.
	Maximum string `pulumi:"maximum"`
	// the minimum number of instances for the resource.
	Minimum string `pulumi:"minimum"`
}

// ScaleCapacityResponseInput is an input type that accepts ScaleCapacityResponseArgs and ScaleCapacityResponseOutput values.
// You can construct a concrete instance of `ScaleCapacityResponseInput` via:
//
//          ScaleCapacityResponseArgs{...}
type ScaleCapacityResponseInput interface {
	pulumi.Input

	ToScaleCapacityResponseOutput() ScaleCapacityResponseOutput
	ToScaleCapacityResponseOutputWithContext(context.Context) ScaleCapacityResponseOutput
}

// The number of instances that can be used during this profile.
type ScaleCapacityResponseArgs struct {
	// the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default.
	Default pulumi.StringInput `pulumi:"default"`
	// the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are available in the subscription.
	Maximum pulumi.StringInput `pulumi:"maximum"`
	// the minimum number of instances for the resource.
	Minimum pulumi.StringInput `pulumi:"minimum"`
}

func (ScaleCapacityResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleCapacityResponse)(nil)).Elem()
}

func (i ScaleCapacityResponseArgs) ToScaleCapacityResponseOutput() ScaleCapacityResponseOutput {
	return i.ToScaleCapacityResponseOutputWithContext(context.Background())
}

func (i ScaleCapacityResponseArgs) ToScaleCapacityResponseOutputWithContext(ctx context.Context) ScaleCapacityResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleCapacityResponseOutput)
}

// The number of instances that can be used during this profile.
type ScaleCapacityResponseOutput struct{ *pulumi.OutputState }

func (ScaleCapacityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleCapacityResponse)(nil)).Elem()
}

func (o ScaleCapacityResponseOutput) ToScaleCapacityResponseOutput() ScaleCapacityResponseOutput {
	return o
}

func (o ScaleCapacityResponseOutput) ToScaleCapacityResponseOutputWithContext(ctx context.Context) ScaleCapacityResponseOutput {
	return o
}

// the number of instances that will be set if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default.
func (o ScaleCapacityResponseOutput) Default() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleCapacityResponse) string { return v.Default }).(pulumi.StringOutput)
}

// the maximum number of instances for the resource. The actual maximum number of instances is limited by the cores that are available in the subscription.
func (o ScaleCapacityResponseOutput) Maximum() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleCapacityResponse) string { return v.Maximum }).(pulumi.StringOutput)
}

// the minimum number of instances for the resource.
func (o ScaleCapacityResponseOutput) Minimum() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleCapacityResponse) string { return v.Minimum }).(pulumi.StringOutput)
}

// A rule that provide the triggers and parameters for the scaling action.
type ScaleRule struct {
	// the trigger that results in a scaling action.
	MetricTrigger MetricTrigger `pulumi:"metricTrigger"`
	// the parameters for the scaling action.
	ScaleAction ScaleAction `pulumi:"scaleAction"`
}

// ScaleRuleInput is an input type that accepts ScaleRuleArgs and ScaleRuleOutput values.
// You can construct a concrete instance of `ScaleRuleInput` via:
//
//          ScaleRuleArgs{...}
type ScaleRuleInput interface {
	pulumi.Input

	ToScaleRuleOutput() ScaleRuleOutput
	ToScaleRuleOutputWithContext(context.Context) ScaleRuleOutput
}

// A rule that provide the triggers and parameters for the scaling action.
type ScaleRuleArgs struct {
	// the trigger that results in a scaling action.
	MetricTrigger MetricTriggerInput `pulumi:"metricTrigger"`
	// the parameters for the scaling action.
	ScaleAction ScaleActionInput `pulumi:"scaleAction"`
}

func (ScaleRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleRule)(nil)).Elem()
}

func (i ScaleRuleArgs) ToScaleRuleOutput() ScaleRuleOutput {
	return i.ToScaleRuleOutputWithContext(context.Background())
}

func (i ScaleRuleArgs) ToScaleRuleOutputWithContext(ctx context.Context) ScaleRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleRuleOutput)
}

// ScaleRuleArrayInput is an input type that accepts ScaleRuleArray and ScaleRuleArrayOutput values.
// You can construct a concrete instance of `ScaleRuleArrayInput` via:
//
//          ScaleRuleArray{ ScaleRuleArgs{...} }
type ScaleRuleArrayInput interface {
	pulumi.Input

	ToScaleRuleArrayOutput() ScaleRuleArrayOutput
	ToScaleRuleArrayOutputWithContext(context.Context) ScaleRuleArrayOutput
}

type ScaleRuleArray []ScaleRuleInput

func (ScaleRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScaleRule)(nil)).Elem()
}

func (i ScaleRuleArray) ToScaleRuleArrayOutput() ScaleRuleArrayOutput {
	return i.ToScaleRuleArrayOutputWithContext(context.Background())
}

func (i ScaleRuleArray) ToScaleRuleArrayOutputWithContext(ctx context.Context) ScaleRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleRuleArrayOutput)
}

// A rule that provide the triggers and parameters for the scaling action.
type ScaleRuleOutput struct{ *pulumi.OutputState }

func (ScaleRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleRule)(nil)).Elem()
}

func (o ScaleRuleOutput) ToScaleRuleOutput() ScaleRuleOutput {
	return o
}

func (o ScaleRuleOutput) ToScaleRuleOutputWithContext(ctx context.Context) ScaleRuleOutput {
	return o
}

// the trigger that results in a scaling action.
func (o ScaleRuleOutput) MetricTrigger() MetricTriggerOutput {
	return o.ApplyT(func(v ScaleRule) MetricTrigger { return v.MetricTrigger }).(MetricTriggerOutput)
}

// the parameters for the scaling action.
func (o ScaleRuleOutput) ScaleAction() ScaleActionOutput {
	return o.ApplyT(func(v ScaleRule) ScaleAction { return v.ScaleAction }).(ScaleActionOutput)
}

type ScaleRuleArrayOutput struct{ *pulumi.OutputState }

func (ScaleRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScaleRule)(nil)).Elem()
}

func (o ScaleRuleArrayOutput) ToScaleRuleArrayOutput() ScaleRuleArrayOutput {
	return o
}

func (o ScaleRuleArrayOutput) ToScaleRuleArrayOutputWithContext(ctx context.Context) ScaleRuleArrayOutput {
	return o
}

func (o ScaleRuleArrayOutput) Index(i pulumi.IntInput) ScaleRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ScaleRule {
		return vs[0].([]ScaleRule)[vs[1].(int)]
	}).(ScaleRuleOutput)
}

// Specifies an auto scale rule metric dimension.
type ScaleRuleMetricDimension struct {
	// Name of the dimension.
	DimensionName string `pulumi:"dimensionName"`
	// the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
	Operator string `pulumi:"operator"`
	// list of dimension values. For example: ["App1","App2"].
	Values []string `pulumi:"values"`
}

// ScaleRuleMetricDimensionInput is an input type that accepts ScaleRuleMetricDimensionArgs and ScaleRuleMetricDimensionOutput values.
// You can construct a concrete instance of `ScaleRuleMetricDimensionInput` via:
//
//          ScaleRuleMetricDimensionArgs{...}
type ScaleRuleMetricDimensionInput interface {
	pulumi.Input

	ToScaleRuleMetricDimensionOutput() ScaleRuleMetricDimensionOutput
	ToScaleRuleMetricDimensionOutputWithContext(context.Context) ScaleRuleMetricDimensionOutput
}

// Specifies an auto scale rule metric dimension.
type ScaleRuleMetricDimensionArgs struct {
	// Name of the dimension.
	DimensionName pulumi.StringInput `pulumi:"dimensionName"`
	// the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
	Operator pulumi.StringInput `pulumi:"operator"`
	// list of dimension values. For example: ["App1","App2"].
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ScaleRuleMetricDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleRuleMetricDimension)(nil)).Elem()
}

func (i ScaleRuleMetricDimensionArgs) ToScaleRuleMetricDimensionOutput() ScaleRuleMetricDimensionOutput {
	return i.ToScaleRuleMetricDimensionOutputWithContext(context.Background())
}

func (i ScaleRuleMetricDimensionArgs) ToScaleRuleMetricDimensionOutputWithContext(ctx context.Context) ScaleRuleMetricDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleRuleMetricDimensionOutput)
}

// ScaleRuleMetricDimensionArrayInput is an input type that accepts ScaleRuleMetricDimensionArray and ScaleRuleMetricDimensionArrayOutput values.
// You can construct a concrete instance of `ScaleRuleMetricDimensionArrayInput` via:
//
//          ScaleRuleMetricDimensionArray{ ScaleRuleMetricDimensionArgs{...} }
type ScaleRuleMetricDimensionArrayInput interface {
	pulumi.Input

	ToScaleRuleMetricDimensionArrayOutput() ScaleRuleMetricDimensionArrayOutput
	ToScaleRuleMetricDimensionArrayOutputWithContext(context.Context) ScaleRuleMetricDimensionArrayOutput
}

type ScaleRuleMetricDimensionArray []ScaleRuleMetricDimensionInput

func (ScaleRuleMetricDimensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScaleRuleMetricDimension)(nil)).Elem()
}

func (i ScaleRuleMetricDimensionArray) ToScaleRuleMetricDimensionArrayOutput() ScaleRuleMetricDimensionArrayOutput {
	return i.ToScaleRuleMetricDimensionArrayOutputWithContext(context.Background())
}

func (i ScaleRuleMetricDimensionArray) ToScaleRuleMetricDimensionArrayOutputWithContext(ctx context.Context) ScaleRuleMetricDimensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleRuleMetricDimensionArrayOutput)
}

// Specifies an auto scale rule metric dimension.
type ScaleRuleMetricDimensionOutput struct{ *pulumi.OutputState }

func (ScaleRuleMetricDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleRuleMetricDimension)(nil)).Elem()
}

func (o ScaleRuleMetricDimensionOutput) ToScaleRuleMetricDimensionOutput() ScaleRuleMetricDimensionOutput {
	return o
}

func (o ScaleRuleMetricDimensionOutput) ToScaleRuleMetricDimensionOutputWithContext(ctx context.Context) ScaleRuleMetricDimensionOutput {
	return o
}

// Name of the dimension.
func (o ScaleRuleMetricDimensionOutput) DimensionName() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleRuleMetricDimension) string { return v.DimensionName }).(pulumi.StringOutput)
}

// the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
func (o ScaleRuleMetricDimensionOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleRuleMetricDimension) string { return v.Operator }).(pulumi.StringOutput)
}

// list of dimension values. For example: ["App1","App2"].
func (o ScaleRuleMetricDimensionOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ScaleRuleMetricDimension) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type ScaleRuleMetricDimensionArrayOutput struct{ *pulumi.OutputState }

func (ScaleRuleMetricDimensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScaleRuleMetricDimension)(nil)).Elem()
}

func (o ScaleRuleMetricDimensionArrayOutput) ToScaleRuleMetricDimensionArrayOutput() ScaleRuleMetricDimensionArrayOutput {
	return o
}

func (o ScaleRuleMetricDimensionArrayOutput) ToScaleRuleMetricDimensionArrayOutputWithContext(ctx context.Context) ScaleRuleMetricDimensionArrayOutput {
	return o
}

func (o ScaleRuleMetricDimensionArrayOutput) Index(i pulumi.IntInput) ScaleRuleMetricDimensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ScaleRuleMetricDimension {
		return vs[0].([]ScaleRuleMetricDimension)[vs[1].(int)]
	}).(ScaleRuleMetricDimensionOutput)
}

// Specifies an auto scale rule metric dimension.
type ScaleRuleMetricDimensionResponse struct {
	// Name of the dimension.
	DimensionName string `pulumi:"dimensionName"`
	// the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
	Operator string `pulumi:"operator"`
	// list of dimension values. For example: ["App1","App2"].
	Values []string `pulumi:"values"`
}

// ScaleRuleMetricDimensionResponseInput is an input type that accepts ScaleRuleMetricDimensionResponseArgs and ScaleRuleMetricDimensionResponseOutput values.
// You can construct a concrete instance of `ScaleRuleMetricDimensionResponseInput` via:
//
//          ScaleRuleMetricDimensionResponseArgs{...}
type ScaleRuleMetricDimensionResponseInput interface {
	pulumi.Input

	ToScaleRuleMetricDimensionResponseOutput() ScaleRuleMetricDimensionResponseOutput
	ToScaleRuleMetricDimensionResponseOutputWithContext(context.Context) ScaleRuleMetricDimensionResponseOutput
}

// Specifies an auto scale rule metric dimension.
type ScaleRuleMetricDimensionResponseArgs struct {
	// Name of the dimension.
	DimensionName pulumi.StringInput `pulumi:"dimensionName"`
	// the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
	Operator pulumi.StringInput `pulumi:"operator"`
	// list of dimension values. For example: ["App1","App2"].
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ScaleRuleMetricDimensionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleRuleMetricDimensionResponse)(nil)).Elem()
}

func (i ScaleRuleMetricDimensionResponseArgs) ToScaleRuleMetricDimensionResponseOutput() ScaleRuleMetricDimensionResponseOutput {
	return i.ToScaleRuleMetricDimensionResponseOutputWithContext(context.Background())
}

func (i ScaleRuleMetricDimensionResponseArgs) ToScaleRuleMetricDimensionResponseOutputWithContext(ctx context.Context) ScaleRuleMetricDimensionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleRuleMetricDimensionResponseOutput)
}

// ScaleRuleMetricDimensionResponseArrayInput is an input type that accepts ScaleRuleMetricDimensionResponseArray and ScaleRuleMetricDimensionResponseArrayOutput values.
// You can construct a concrete instance of `ScaleRuleMetricDimensionResponseArrayInput` via:
//
//          ScaleRuleMetricDimensionResponseArray{ ScaleRuleMetricDimensionResponseArgs{...} }
type ScaleRuleMetricDimensionResponseArrayInput interface {
	pulumi.Input

	ToScaleRuleMetricDimensionResponseArrayOutput() ScaleRuleMetricDimensionResponseArrayOutput
	ToScaleRuleMetricDimensionResponseArrayOutputWithContext(context.Context) ScaleRuleMetricDimensionResponseArrayOutput
}

type ScaleRuleMetricDimensionResponseArray []ScaleRuleMetricDimensionResponseInput

func (ScaleRuleMetricDimensionResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScaleRuleMetricDimensionResponse)(nil)).Elem()
}

func (i ScaleRuleMetricDimensionResponseArray) ToScaleRuleMetricDimensionResponseArrayOutput() ScaleRuleMetricDimensionResponseArrayOutput {
	return i.ToScaleRuleMetricDimensionResponseArrayOutputWithContext(context.Background())
}

func (i ScaleRuleMetricDimensionResponseArray) ToScaleRuleMetricDimensionResponseArrayOutputWithContext(ctx context.Context) ScaleRuleMetricDimensionResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleRuleMetricDimensionResponseArrayOutput)
}

// Specifies an auto scale rule metric dimension.
type ScaleRuleMetricDimensionResponseOutput struct{ *pulumi.OutputState }

func (ScaleRuleMetricDimensionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleRuleMetricDimensionResponse)(nil)).Elem()
}

func (o ScaleRuleMetricDimensionResponseOutput) ToScaleRuleMetricDimensionResponseOutput() ScaleRuleMetricDimensionResponseOutput {
	return o
}

func (o ScaleRuleMetricDimensionResponseOutput) ToScaleRuleMetricDimensionResponseOutputWithContext(ctx context.Context) ScaleRuleMetricDimensionResponseOutput {
	return o
}

// Name of the dimension.
func (o ScaleRuleMetricDimensionResponseOutput) DimensionName() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleRuleMetricDimensionResponse) string { return v.DimensionName }).(pulumi.StringOutput)
}

// the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the values. 'NotEquals' being not equal to all of the values
func (o ScaleRuleMetricDimensionResponseOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ScaleRuleMetricDimensionResponse) string { return v.Operator }).(pulumi.StringOutput)
}

// list of dimension values. For example: ["App1","App2"].
func (o ScaleRuleMetricDimensionResponseOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ScaleRuleMetricDimensionResponse) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type ScaleRuleMetricDimensionResponseArrayOutput struct{ *pulumi.OutputState }

func (ScaleRuleMetricDimensionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScaleRuleMetricDimensionResponse)(nil)).Elem()
}

func (o ScaleRuleMetricDimensionResponseArrayOutput) ToScaleRuleMetricDimensionResponseArrayOutput() ScaleRuleMetricDimensionResponseArrayOutput {
	return o
}

func (o ScaleRuleMetricDimensionResponseArrayOutput) ToScaleRuleMetricDimensionResponseArrayOutputWithContext(ctx context.Context) ScaleRuleMetricDimensionResponseArrayOutput {
	return o
}

func (o ScaleRuleMetricDimensionResponseArrayOutput) Index(i pulumi.IntInput) ScaleRuleMetricDimensionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ScaleRuleMetricDimensionResponse {
		return vs[0].([]ScaleRuleMetricDimensionResponse)[vs[1].(int)]
	}).(ScaleRuleMetricDimensionResponseOutput)
}

// A rule that provide the triggers and parameters for the scaling action.
type ScaleRuleResponse struct {
	// the trigger that results in a scaling action.
	MetricTrigger MetricTriggerResponse `pulumi:"metricTrigger"`
	// the parameters for the scaling action.
	ScaleAction ScaleActionResponse `pulumi:"scaleAction"`
}

// ScaleRuleResponseInput is an input type that accepts ScaleRuleResponseArgs and ScaleRuleResponseOutput values.
// You can construct a concrete instance of `ScaleRuleResponseInput` via:
//
//          ScaleRuleResponseArgs{...}
type ScaleRuleResponseInput interface {
	pulumi.Input

	ToScaleRuleResponseOutput() ScaleRuleResponseOutput
	ToScaleRuleResponseOutputWithContext(context.Context) ScaleRuleResponseOutput
}

// A rule that provide the triggers and parameters for the scaling action.
type ScaleRuleResponseArgs struct {
	// the trigger that results in a scaling action.
	MetricTrigger MetricTriggerResponseInput `pulumi:"metricTrigger"`
	// the parameters for the scaling action.
	ScaleAction ScaleActionResponseInput `pulumi:"scaleAction"`
}

func (ScaleRuleResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleRuleResponse)(nil)).Elem()
}

func (i ScaleRuleResponseArgs) ToScaleRuleResponseOutput() ScaleRuleResponseOutput {
	return i.ToScaleRuleResponseOutputWithContext(context.Background())
}

func (i ScaleRuleResponseArgs) ToScaleRuleResponseOutputWithContext(ctx context.Context) ScaleRuleResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleRuleResponseOutput)
}

// ScaleRuleResponseArrayInput is an input type that accepts ScaleRuleResponseArray and ScaleRuleResponseArrayOutput values.
// You can construct a concrete instance of `ScaleRuleResponseArrayInput` via:
//
//          ScaleRuleResponseArray{ ScaleRuleResponseArgs{...} }
type ScaleRuleResponseArrayInput interface {
	pulumi.Input

	ToScaleRuleResponseArrayOutput() ScaleRuleResponseArrayOutput
	ToScaleRuleResponseArrayOutputWithContext(context.Context) ScaleRuleResponseArrayOutput
}

type ScaleRuleResponseArray []ScaleRuleResponseInput

func (ScaleRuleResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScaleRuleResponse)(nil)).Elem()
}

func (i ScaleRuleResponseArray) ToScaleRuleResponseArrayOutput() ScaleRuleResponseArrayOutput {
	return i.ToScaleRuleResponseArrayOutputWithContext(context.Background())
}

func (i ScaleRuleResponseArray) ToScaleRuleResponseArrayOutputWithContext(ctx context.Context) ScaleRuleResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScaleRuleResponseArrayOutput)
}

// A rule that provide the triggers and parameters for the scaling action.
type ScaleRuleResponseOutput struct{ *pulumi.OutputState }

func (ScaleRuleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScaleRuleResponse)(nil)).Elem()
}

func (o ScaleRuleResponseOutput) ToScaleRuleResponseOutput() ScaleRuleResponseOutput {
	return o
}

func (o ScaleRuleResponseOutput) ToScaleRuleResponseOutputWithContext(ctx context.Context) ScaleRuleResponseOutput {
	return o
}

// the trigger that results in a scaling action.
func (o ScaleRuleResponseOutput) MetricTrigger() MetricTriggerResponseOutput {
	return o.ApplyT(func(v ScaleRuleResponse) MetricTriggerResponse { return v.MetricTrigger }).(MetricTriggerResponseOutput)
}

// the parameters for the scaling action.
func (o ScaleRuleResponseOutput) ScaleAction() ScaleActionResponseOutput {
	return o.ApplyT(func(v ScaleRuleResponse) ScaleActionResponse { return v.ScaleAction }).(ScaleActionResponseOutput)
}

type ScaleRuleResponseArrayOutput struct{ *pulumi.OutputState }

func (ScaleRuleResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScaleRuleResponse)(nil)).Elem()
}

func (o ScaleRuleResponseArrayOutput) ToScaleRuleResponseArrayOutput() ScaleRuleResponseArrayOutput {
	return o
}

func (o ScaleRuleResponseArrayOutput) ToScaleRuleResponseArrayOutputWithContext(ctx context.Context) ScaleRuleResponseArrayOutput {
	return o
}

func (o ScaleRuleResponseArrayOutput) Index(i pulumi.IntInput) ScaleRuleResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ScaleRuleResponse {
		return vs[0].([]ScaleRuleResponse)[vs[1].(int)]
	}).(ScaleRuleResponseOutput)
}

// A rule condition based on a metric crossing a threshold.
type ThresholdRuleCondition struct {
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource interface{} `pulumi:"dataSource"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition'.
	OdataType string `pulumi:"odataType"`
	// the operator used to compare the data and the threshold.
	Operator ConditionOperator `pulumi:"operator"`
	// the threshold value that activates the alert.
	Threshold float64 `pulumi:"threshold"`
	// the time aggregation operator. How the data that are collected should be combined over time. The default value is the PrimaryAggregationType of the Metric.
	TimeAggregation *TimeAggregationOperator `pulumi:"timeAggregation"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize *string `pulumi:"windowSize"`
}

// ThresholdRuleConditionInput is an input type that accepts ThresholdRuleConditionArgs and ThresholdRuleConditionOutput values.
// You can construct a concrete instance of `ThresholdRuleConditionInput` via:
//
//          ThresholdRuleConditionArgs{...}
type ThresholdRuleConditionInput interface {
	pulumi.Input

	ToThresholdRuleConditionOutput() ThresholdRuleConditionOutput
	ToThresholdRuleConditionOutputWithContext(context.Context) ThresholdRuleConditionOutput
}

// A rule condition based on a metric crossing a threshold.
type ThresholdRuleConditionArgs struct {
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource pulumi.Input `pulumi:"dataSource"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// the operator used to compare the data and the threshold.
	Operator ConditionOperatorInput `pulumi:"operator"`
	// the threshold value that activates the alert.
	Threshold pulumi.Float64Input `pulumi:"threshold"`
	// the time aggregation operator. How the data that are collected should be combined over time. The default value is the PrimaryAggregationType of the Metric.
	TimeAggregation TimeAggregationOperatorPtrInput `pulumi:"timeAggregation"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize pulumi.StringPtrInput `pulumi:"windowSize"`
}

func (ThresholdRuleConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ThresholdRuleCondition)(nil)).Elem()
}

func (i ThresholdRuleConditionArgs) ToThresholdRuleConditionOutput() ThresholdRuleConditionOutput {
	return i.ToThresholdRuleConditionOutputWithContext(context.Background())
}

func (i ThresholdRuleConditionArgs) ToThresholdRuleConditionOutputWithContext(ctx context.Context) ThresholdRuleConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ThresholdRuleConditionOutput)
}

// A rule condition based on a metric crossing a threshold.
type ThresholdRuleConditionOutput struct{ *pulumi.OutputState }

func (ThresholdRuleConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ThresholdRuleCondition)(nil)).Elem()
}

func (o ThresholdRuleConditionOutput) ToThresholdRuleConditionOutput() ThresholdRuleConditionOutput {
	return o
}

func (o ThresholdRuleConditionOutput) ToThresholdRuleConditionOutputWithContext(ctx context.Context) ThresholdRuleConditionOutput {
	return o
}

// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
func (o ThresholdRuleConditionOutput) DataSource() pulumi.AnyOutput {
	return o.ApplyT(func(v ThresholdRuleCondition) interface{} { return v.DataSource }).(pulumi.AnyOutput)
}

// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
// Expected value is 'Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition'.
func (o ThresholdRuleConditionOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdRuleCondition) string { return v.OdataType }).(pulumi.StringOutput)
}

// the operator used to compare the data and the threshold.
func (o ThresholdRuleConditionOutput) Operator() ConditionOperatorOutput {
	return o.ApplyT(func(v ThresholdRuleCondition) ConditionOperator { return v.Operator }).(ConditionOperatorOutput)
}

// the threshold value that activates the alert.
func (o ThresholdRuleConditionOutput) Threshold() pulumi.Float64Output {
	return o.ApplyT(func(v ThresholdRuleCondition) float64 { return v.Threshold }).(pulumi.Float64Output)
}

// the time aggregation operator. How the data that are collected should be combined over time. The default value is the PrimaryAggregationType of the Metric.
func (o ThresholdRuleConditionOutput) TimeAggregation() TimeAggregationOperatorPtrOutput {
	return o.ApplyT(func(v ThresholdRuleCondition) *TimeAggregationOperator { return v.TimeAggregation }).(TimeAggregationOperatorPtrOutput)
}

// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
func (o ThresholdRuleConditionOutput) WindowSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ThresholdRuleCondition) *string { return v.WindowSize }).(pulumi.StringPtrOutput)
}

// A rule condition based on a metric crossing a threshold.
type ThresholdRuleConditionResponse struct {
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource interface{} `pulumi:"dataSource"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition'.
	OdataType string `pulumi:"odataType"`
	// the operator used to compare the data and the threshold.
	Operator string `pulumi:"operator"`
	// the threshold value that activates the alert.
	Threshold float64 `pulumi:"threshold"`
	// the time aggregation operator. How the data that are collected should be combined over time. The default value is the PrimaryAggregationType of the Metric.
	TimeAggregation *string `pulumi:"timeAggregation"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize *string `pulumi:"windowSize"`
}

// ThresholdRuleConditionResponseInput is an input type that accepts ThresholdRuleConditionResponseArgs and ThresholdRuleConditionResponseOutput values.
// You can construct a concrete instance of `ThresholdRuleConditionResponseInput` via:
//
//          ThresholdRuleConditionResponseArgs{...}
type ThresholdRuleConditionResponseInput interface {
	pulumi.Input

	ToThresholdRuleConditionResponseOutput() ThresholdRuleConditionResponseOutput
	ToThresholdRuleConditionResponseOutputWithContext(context.Context) ThresholdRuleConditionResponseOutput
}

// A rule condition based on a metric crossing a threshold.
type ThresholdRuleConditionResponseArgs struct {
	// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
	DataSource pulumi.Input `pulumi:"dataSource"`
	// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
	// Expected value is 'Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition'.
	OdataType pulumi.StringInput `pulumi:"odataType"`
	// the operator used to compare the data and the threshold.
	Operator pulumi.StringInput `pulumi:"operator"`
	// the threshold value that activates the alert.
	Threshold pulumi.Float64Input `pulumi:"threshold"`
	// the time aggregation operator. How the data that are collected should be combined over time. The default value is the PrimaryAggregationType of the Metric.
	TimeAggregation pulumi.StringPtrInput `pulumi:"timeAggregation"`
	// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
	WindowSize pulumi.StringPtrInput `pulumi:"windowSize"`
}

func (ThresholdRuleConditionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ThresholdRuleConditionResponse)(nil)).Elem()
}

func (i ThresholdRuleConditionResponseArgs) ToThresholdRuleConditionResponseOutput() ThresholdRuleConditionResponseOutput {
	return i.ToThresholdRuleConditionResponseOutputWithContext(context.Background())
}

func (i ThresholdRuleConditionResponseArgs) ToThresholdRuleConditionResponseOutputWithContext(ctx context.Context) ThresholdRuleConditionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ThresholdRuleConditionResponseOutput)
}

// A rule condition based on a metric crossing a threshold.
type ThresholdRuleConditionResponseOutput struct{ *pulumi.OutputState }

func (ThresholdRuleConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ThresholdRuleConditionResponse)(nil)).Elem()
}

func (o ThresholdRuleConditionResponseOutput) ToThresholdRuleConditionResponseOutput() ThresholdRuleConditionResponseOutput {
	return o
}

func (o ThresholdRuleConditionResponseOutput) ToThresholdRuleConditionResponseOutputWithContext(ctx context.Context) ThresholdRuleConditionResponseOutput {
	return o
}

// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
func (o ThresholdRuleConditionResponseOutput) DataSource() pulumi.AnyOutput {
	return o.ApplyT(func(v ThresholdRuleConditionResponse) interface{} { return v.DataSource }).(pulumi.AnyOutput)
}

// specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric).
// Expected value is 'Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition'.
func (o ThresholdRuleConditionResponseOutput) OdataType() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdRuleConditionResponse) string { return v.OdataType }).(pulumi.StringOutput)
}

// the operator used to compare the data and the threshold.
func (o ThresholdRuleConditionResponseOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdRuleConditionResponse) string { return v.Operator }).(pulumi.StringOutput)
}

// the threshold value that activates the alert.
func (o ThresholdRuleConditionResponseOutput) Threshold() pulumi.Float64Output {
	return o.ApplyT(func(v ThresholdRuleConditionResponse) float64 { return v.Threshold }).(pulumi.Float64Output)
}

// the time aggregation operator. How the data that are collected should be combined over time. The default value is the PrimaryAggregationType of the Metric.
func (o ThresholdRuleConditionResponseOutput) TimeAggregation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ThresholdRuleConditionResponse) *string { return v.TimeAggregation }).(pulumi.StringPtrOutput)
}

// the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day.
func (o ThresholdRuleConditionResponseOutput) WindowSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ThresholdRuleConditionResponse) *string { return v.WindowSize }).(pulumi.StringPtrOutput)
}

// A specific date-time for the profile.
type TimeWindow struct {
	// the end time for the profile in ISO 8601 format.
	End string `pulumi:"end"`
	// the start time for the profile in ISO 8601 format.
	Start string `pulumi:"start"`
	// the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone *string `pulumi:"timeZone"`
}

// TimeWindowInput is an input type that accepts TimeWindowArgs and TimeWindowOutput values.
// You can construct a concrete instance of `TimeWindowInput` via:
//
//          TimeWindowArgs{...}
type TimeWindowInput interface {
	pulumi.Input

	ToTimeWindowOutput() TimeWindowOutput
	ToTimeWindowOutputWithContext(context.Context) TimeWindowOutput
}

// A specific date-time for the profile.
type TimeWindowArgs struct {
	// the end time for the profile in ISO 8601 format.
	End pulumi.StringInput `pulumi:"end"`
	// the start time for the profile in ISO 8601 format.
	Start pulumi.StringInput `pulumi:"start"`
	// the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone pulumi.StringPtrInput `pulumi:"timeZone"`
}

func (TimeWindowArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeWindow)(nil)).Elem()
}

func (i TimeWindowArgs) ToTimeWindowOutput() TimeWindowOutput {
	return i.ToTimeWindowOutputWithContext(context.Background())
}

func (i TimeWindowArgs) ToTimeWindowOutputWithContext(ctx context.Context) TimeWindowOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeWindowOutput)
}

func (i TimeWindowArgs) ToTimeWindowPtrOutput() TimeWindowPtrOutput {
	return i.ToTimeWindowPtrOutputWithContext(context.Background())
}

func (i TimeWindowArgs) ToTimeWindowPtrOutputWithContext(ctx context.Context) TimeWindowPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeWindowOutput).ToTimeWindowPtrOutputWithContext(ctx)
}

// TimeWindowPtrInput is an input type that accepts TimeWindowArgs, TimeWindowPtr and TimeWindowPtrOutput values.
// You can construct a concrete instance of `TimeWindowPtrInput` via:
//
//          TimeWindowArgs{...}
//
//  or:
//
//          nil
type TimeWindowPtrInput interface {
	pulumi.Input

	ToTimeWindowPtrOutput() TimeWindowPtrOutput
	ToTimeWindowPtrOutputWithContext(context.Context) TimeWindowPtrOutput
}

type timeWindowPtrType TimeWindowArgs

func TimeWindowPtr(v *TimeWindowArgs) TimeWindowPtrInput {
	return (*timeWindowPtrType)(v)
}

func (*timeWindowPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeWindow)(nil)).Elem()
}

func (i *timeWindowPtrType) ToTimeWindowPtrOutput() TimeWindowPtrOutput {
	return i.ToTimeWindowPtrOutputWithContext(context.Background())
}

func (i *timeWindowPtrType) ToTimeWindowPtrOutputWithContext(ctx context.Context) TimeWindowPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeWindowPtrOutput)
}

// A specific date-time for the profile.
type TimeWindowOutput struct{ *pulumi.OutputState }

func (TimeWindowOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeWindow)(nil)).Elem()
}

func (o TimeWindowOutput) ToTimeWindowOutput() TimeWindowOutput {
	return o
}

func (o TimeWindowOutput) ToTimeWindowOutputWithContext(ctx context.Context) TimeWindowOutput {
	return o
}

func (o TimeWindowOutput) ToTimeWindowPtrOutput() TimeWindowPtrOutput {
	return o.ToTimeWindowPtrOutputWithContext(context.Background())
}

func (o TimeWindowOutput) ToTimeWindowPtrOutputWithContext(ctx context.Context) TimeWindowPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeWindow) *TimeWindow {
		return &v
	}).(TimeWindowPtrOutput)
}

// the end time for the profile in ISO 8601 format.
func (o TimeWindowOutput) End() pulumi.StringOutput {
	return o.ApplyT(func(v TimeWindow) string { return v.End }).(pulumi.StringOutput)
}

// the start time for the profile in ISO 8601 format.
func (o TimeWindowOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v TimeWindow) string { return v.Start }).(pulumi.StringOutput)
}

// the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
func (o TimeWindowOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeWindow) *string { return v.TimeZone }).(pulumi.StringPtrOutput)
}

type TimeWindowPtrOutput struct{ *pulumi.OutputState }

func (TimeWindowPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeWindow)(nil)).Elem()
}

func (o TimeWindowPtrOutput) ToTimeWindowPtrOutput() TimeWindowPtrOutput {
	return o
}

func (o TimeWindowPtrOutput) ToTimeWindowPtrOutputWithContext(ctx context.Context) TimeWindowPtrOutput {
	return o
}

func (o TimeWindowPtrOutput) Elem() TimeWindowOutput {
	return o.ApplyT(func(v *TimeWindow) TimeWindow {
		if v != nil {
			return *v
		}
		var ret TimeWindow
		return ret
	}).(TimeWindowOutput)
}

// the end time for the profile in ISO 8601 format.
func (o TimeWindowPtrOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeWindow) *string {
		if v == nil {
			return nil
		}
		return &v.End
	}).(pulumi.StringPtrOutput)
}

// the start time for the profile in ISO 8601 format.
func (o TimeWindowPtrOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeWindow) *string {
		if v == nil {
			return nil
		}
		return &v.Start
	}).(pulumi.StringPtrOutput)
}

// the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
func (o TimeWindowPtrOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeWindow) *string {
		if v == nil {
			return nil
		}
		return v.TimeZone
	}).(pulumi.StringPtrOutput)
}

// A specific date-time for the profile.
type TimeWindowResponse struct {
	// the end time for the profile in ISO 8601 format.
	End string `pulumi:"end"`
	// the start time for the profile in ISO 8601 format.
	Start string `pulumi:"start"`
	// the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone *string `pulumi:"timeZone"`
}

// TimeWindowResponseInput is an input type that accepts TimeWindowResponseArgs and TimeWindowResponseOutput values.
// You can construct a concrete instance of `TimeWindowResponseInput` via:
//
//          TimeWindowResponseArgs{...}
type TimeWindowResponseInput interface {
	pulumi.Input

	ToTimeWindowResponseOutput() TimeWindowResponseOutput
	ToTimeWindowResponseOutputWithContext(context.Context) TimeWindowResponseOutput
}

// A specific date-time for the profile.
type TimeWindowResponseArgs struct {
	// the end time for the profile in ISO 8601 format.
	End pulumi.StringInput `pulumi:"end"`
	// the start time for the profile in ISO 8601 format.
	Start pulumi.StringInput `pulumi:"start"`
	// the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone pulumi.StringPtrInput `pulumi:"timeZone"`
}

func (TimeWindowResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeWindowResponse)(nil)).Elem()
}

func (i TimeWindowResponseArgs) ToTimeWindowResponseOutput() TimeWindowResponseOutput {
	return i.ToTimeWindowResponseOutputWithContext(context.Background())
}

func (i TimeWindowResponseArgs) ToTimeWindowResponseOutputWithContext(ctx context.Context) TimeWindowResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeWindowResponseOutput)
}

func (i TimeWindowResponseArgs) ToTimeWindowResponsePtrOutput() TimeWindowResponsePtrOutput {
	return i.ToTimeWindowResponsePtrOutputWithContext(context.Background())
}

func (i TimeWindowResponseArgs) ToTimeWindowResponsePtrOutputWithContext(ctx context.Context) TimeWindowResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeWindowResponseOutput).ToTimeWindowResponsePtrOutputWithContext(ctx)
}

// TimeWindowResponsePtrInput is an input type that accepts TimeWindowResponseArgs, TimeWindowResponsePtr and TimeWindowResponsePtrOutput values.
// You can construct a concrete instance of `TimeWindowResponsePtrInput` via:
//
//          TimeWindowResponseArgs{...}
//
//  or:
//
//          nil
type TimeWindowResponsePtrInput interface {
	pulumi.Input

	ToTimeWindowResponsePtrOutput() TimeWindowResponsePtrOutput
	ToTimeWindowResponsePtrOutputWithContext(context.Context) TimeWindowResponsePtrOutput
}

type timeWindowResponsePtrType TimeWindowResponseArgs

func TimeWindowResponsePtr(v *TimeWindowResponseArgs) TimeWindowResponsePtrInput {
	return (*timeWindowResponsePtrType)(v)
}

func (*timeWindowResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeWindowResponse)(nil)).Elem()
}

func (i *timeWindowResponsePtrType) ToTimeWindowResponsePtrOutput() TimeWindowResponsePtrOutput {
	return i.ToTimeWindowResponsePtrOutputWithContext(context.Background())
}

func (i *timeWindowResponsePtrType) ToTimeWindowResponsePtrOutputWithContext(ctx context.Context) TimeWindowResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeWindowResponsePtrOutput)
}

// A specific date-time for the profile.
type TimeWindowResponseOutput struct{ *pulumi.OutputState }

func (TimeWindowResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeWindowResponse)(nil)).Elem()
}

func (o TimeWindowResponseOutput) ToTimeWindowResponseOutput() TimeWindowResponseOutput {
	return o
}

func (o TimeWindowResponseOutput) ToTimeWindowResponseOutputWithContext(ctx context.Context) TimeWindowResponseOutput {
	return o
}

func (o TimeWindowResponseOutput) ToTimeWindowResponsePtrOutput() TimeWindowResponsePtrOutput {
	return o.ToTimeWindowResponsePtrOutputWithContext(context.Background())
}

func (o TimeWindowResponseOutput) ToTimeWindowResponsePtrOutputWithContext(ctx context.Context) TimeWindowResponsePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeWindowResponse) *TimeWindowResponse {
		return &v
	}).(TimeWindowResponsePtrOutput)
}

// the end time for the profile in ISO 8601 format.
func (o TimeWindowResponseOutput) End() pulumi.StringOutput {
	return o.ApplyT(func(v TimeWindowResponse) string { return v.End }).(pulumi.StringOutput)
}

// the start time for the profile in ISO 8601 format.
func (o TimeWindowResponseOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v TimeWindowResponse) string { return v.Start }).(pulumi.StringOutput)
}

// the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
func (o TimeWindowResponseOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeWindowResponse) *string { return v.TimeZone }).(pulumi.StringPtrOutput)
}

type TimeWindowResponsePtrOutput struct{ *pulumi.OutputState }

func (TimeWindowResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeWindowResponse)(nil)).Elem()
}

func (o TimeWindowResponsePtrOutput) ToTimeWindowResponsePtrOutput() TimeWindowResponsePtrOutput {
	return o
}

func (o TimeWindowResponsePtrOutput) ToTimeWindowResponsePtrOutputWithContext(ctx context.Context) TimeWindowResponsePtrOutput {
	return o
}

func (o TimeWindowResponsePtrOutput) Elem() TimeWindowResponseOutput {
	return o.ApplyT(func(v *TimeWindowResponse) TimeWindowResponse {
		if v != nil {
			return *v
		}
		var ret TimeWindowResponse
		return ret
	}).(TimeWindowResponseOutput)
}

// the end time for the profile in ISO 8601 format.
func (o TimeWindowResponsePtrOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeWindowResponse) *string {
		if v == nil {
			return nil
		}
		return &v.End
	}).(pulumi.StringPtrOutput)
}

// the start time for the profile in ISO 8601 format.
func (o TimeWindowResponsePtrOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeWindowResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Start
	}).(pulumi.StringPtrOutput)
}

// the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
func (o TimeWindowResponsePtrOutput) TimeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeWindowResponse) *string {
		if v == nil {
			return nil
		}
		return v.TimeZone
	}).(pulumi.StringPtrOutput)
}

// Webhook notification of an autoscale event.
type WebhookNotification struct {
	// a property bag of settings. This value can be empty.
	Properties map[string]string `pulumi:"properties"`
	// the service address to receive the notification.
	ServiceUri *string `pulumi:"serviceUri"`
}

// WebhookNotificationInput is an input type that accepts WebhookNotificationArgs and WebhookNotificationOutput values.
// You can construct a concrete instance of `WebhookNotificationInput` via:
//
//          WebhookNotificationArgs{...}
type WebhookNotificationInput interface {
	pulumi.Input

	ToWebhookNotificationOutput() WebhookNotificationOutput
	ToWebhookNotificationOutputWithContext(context.Context) WebhookNotificationOutput
}

// Webhook notification of an autoscale event.
type WebhookNotificationArgs struct {
	// a property bag of settings. This value can be empty.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// the service address to receive the notification.
	ServiceUri pulumi.StringPtrInput `pulumi:"serviceUri"`
}

func (WebhookNotificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebhookNotification)(nil)).Elem()
}

func (i WebhookNotificationArgs) ToWebhookNotificationOutput() WebhookNotificationOutput {
	return i.ToWebhookNotificationOutputWithContext(context.Background())
}

func (i WebhookNotificationArgs) ToWebhookNotificationOutputWithContext(ctx context.Context) WebhookNotificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebhookNotificationOutput)
}

// WebhookNotificationArrayInput is an input type that accepts WebhookNotificationArray and WebhookNotificationArrayOutput values.
// You can construct a concrete instance of `WebhookNotificationArrayInput` via:
//
//          WebhookNotificationArray{ WebhookNotificationArgs{...} }
type WebhookNotificationArrayInput interface {
	pulumi.Input

	ToWebhookNotificationArrayOutput() WebhookNotificationArrayOutput
	ToWebhookNotificationArrayOutputWithContext(context.Context) WebhookNotificationArrayOutput
}

type WebhookNotificationArray []WebhookNotificationInput

func (WebhookNotificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebhookNotification)(nil)).Elem()
}

func (i WebhookNotificationArray) ToWebhookNotificationArrayOutput() WebhookNotificationArrayOutput {
	return i.ToWebhookNotificationArrayOutputWithContext(context.Background())
}

func (i WebhookNotificationArray) ToWebhookNotificationArrayOutputWithContext(ctx context.Context) WebhookNotificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebhookNotificationArrayOutput)
}

// Webhook notification of an autoscale event.
type WebhookNotificationOutput struct{ *pulumi.OutputState }

func (WebhookNotificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebhookNotification)(nil)).Elem()
}

func (o WebhookNotificationOutput) ToWebhookNotificationOutput() WebhookNotificationOutput {
	return o
}

func (o WebhookNotificationOutput) ToWebhookNotificationOutputWithContext(ctx context.Context) WebhookNotificationOutput {
	return o
}

// a property bag of settings. This value can be empty.
func (o WebhookNotificationOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v WebhookNotification) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// the service address to receive the notification.
func (o WebhookNotificationOutput) ServiceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WebhookNotification) *string { return v.ServiceUri }).(pulumi.StringPtrOutput)
}

type WebhookNotificationArrayOutput struct{ *pulumi.OutputState }

func (WebhookNotificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebhookNotification)(nil)).Elem()
}

func (o WebhookNotificationArrayOutput) ToWebhookNotificationArrayOutput() WebhookNotificationArrayOutput {
	return o
}

func (o WebhookNotificationArrayOutput) ToWebhookNotificationArrayOutputWithContext(ctx context.Context) WebhookNotificationArrayOutput {
	return o
}

func (o WebhookNotificationArrayOutput) Index(i pulumi.IntInput) WebhookNotificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebhookNotification {
		return vs[0].([]WebhookNotification)[vs[1].(int)]
	}).(WebhookNotificationOutput)
}

// Webhook notification of an autoscale event.
type WebhookNotificationResponse struct {
	// a property bag of settings. This value can be empty.
	Properties map[string]string `pulumi:"properties"`
	// the service address to receive the notification.
	ServiceUri *string `pulumi:"serviceUri"`
}

// WebhookNotificationResponseInput is an input type that accepts WebhookNotificationResponseArgs and WebhookNotificationResponseOutput values.
// You can construct a concrete instance of `WebhookNotificationResponseInput` via:
//
//          WebhookNotificationResponseArgs{...}
type WebhookNotificationResponseInput interface {
	pulumi.Input

	ToWebhookNotificationResponseOutput() WebhookNotificationResponseOutput
	ToWebhookNotificationResponseOutputWithContext(context.Context) WebhookNotificationResponseOutput
}

// Webhook notification of an autoscale event.
type WebhookNotificationResponseArgs struct {
	// a property bag of settings. This value can be empty.
	Properties pulumi.StringMapInput `pulumi:"properties"`
	// the service address to receive the notification.
	ServiceUri pulumi.StringPtrInput `pulumi:"serviceUri"`
}

func (WebhookNotificationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebhookNotificationResponse)(nil)).Elem()
}

func (i WebhookNotificationResponseArgs) ToWebhookNotificationResponseOutput() WebhookNotificationResponseOutput {
	return i.ToWebhookNotificationResponseOutputWithContext(context.Background())
}

func (i WebhookNotificationResponseArgs) ToWebhookNotificationResponseOutputWithContext(ctx context.Context) WebhookNotificationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebhookNotificationResponseOutput)
}

// WebhookNotificationResponseArrayInput is an input type that accepts WebhookNotificationResponseArray and WebhookNotificationResponseArrayOutput values.
// You can construct a concrete instance of `WebhookNotificationResponseArrayInput` via:
//
//          WebhookNotificationResponseArray{ WebhookNotificationResponseArgs{...} }
type WebhookNotificationResponseArrayInput interface {
	pulumi.Input

	ToWebhookNotificationResponseArrayOutput() WebhookNotificationResponseArrayOutput
	ToWebhookNotificationResponseArrayOutputWithContext(context.Context) WebhookNotificationResponseArrayOutput
}

type WebhookNotificationResponseArray []WebhookNotificationResponseInput

func (WebhookNotificationResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebhookNotificationResponse)(nil)).Elem()
}

func (i WebhookNotificationResponseArray) ToWebhookNotificationResponseArrayOutput() WebhookNotificationResponseArrayOutput {
	return i.ToWebhookNotificationResponseArrayOutputWithContext(context.Background())
}

func (i WebhookNotificationResponseArray) ToWebhookNotificationResponseArrayOutputWithContext(ctx context.Context) WebhookNotificationResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebhookNotificationResponseArrayOutput)
}

// Webhook notification of an autoscale event.
type WebhookNotificationResponseOutput struct{ *pulumi.OutputState }

func (WebhookNotificationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebhookNotificationResponse)(nil)).Elem()
}

func (o WebhookNotificationResponseOutput) ToWebhookNotificationResponseOutput() WebhookNotificationResponseOutput {
	return o
}

func (o WebhookNotificationResponseOutput) ToWebhookNotificationResponseOutputWithContext(ctx context.Context) WebhookNotificationResponseOutput {
	return o
}

// a property bag of settings. This value can be empty.
func (o WebhookNotificationResponseOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v WebhookNotificationResponse) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

// the service address to receive the notification.
func (o WebhookNotificationResponseOutput) ServiceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WebhookNotificationResponse) *string { return v.ServiceUri }).(pulumi.StringPtrOutput)
}

type WebhookNotificationResponseArrayOutput struct{ *pulumi.OutputState }

func (WebhookNotificationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebhookNotificationResponse)(nil)).Elem()
}

func (o WebhookNotificationResponseArrayOutput) ToWebhookNotificationResponseArrayOutput() WebhookNotificationResponseArrayOutput {
	return o
}

func (o WebhookNotificationResponseArrayOutput) ToWebhookNotificationResponseArrayOutputWithContext(ctx context.Context) WebhookNotificationResponseArrayOutput {
	return o
}

func (o WebhookNotificationResponseArrayOutput) Index(i pulumi.IntInput) WebhookNotificationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebhookNotificationResponse {
		return vs[0].([]WebhookNotificationResponse)[vs[1].(int)]
	}).(WebhookNotificationResponseOutput)
}

func init() {
	pulumi.RegisterOutputType(AutoscaleNotificationOutput{})
	pulumi.RegisterOutputType(AutoscaleNotificationArrayOutput{})
	pulumi.RegisterOutputType(AutoscaleNotificationResponseOutput{})
	pulumi.RegisterOutputType(AutoscaleNotificationResponseArrayOutput{})
	pulumi.RegisterOutputType(AutoscaleProfileOutput{})
	pulumi.RegisterOutputType(AutoscaleProfileArrayOutput{})
	pulumi.RegisterOutputType(AutoscaleProfileResponseOutput{})
	pulumi.RegisterOutputType(AutoscaleProfileResponseArrayOutput{})
	pulumi.RegisterOutputType(EmailNotificationOutput{})
	pulumi.RegisterOutputType(EmailNotificationPtrOutput{})
	pulumi.RegisterOutputType(EmailNotificationResponseOutput{})
	pulumi.RegisterOutputType(EmailNotificationResponsePtrOutput{})
	pulumi.RegisterOutputType(LocationThresholdRuleConditionOutput{})
	pulumi.RegisterOutputType(LocationThresholdRuleConditionResponseOutput{})
	pulumi.RegisterOutputType(ManagementEventAggregationConditionOutput{})
	pulumi.RegisterOutputType(ManagementEventAggregationConditionPtrOutput{})
	pulumi.RegisterOutputType(ManagementEventAggregationConditionResponseOutput{})
	pulumi.RegisterOutputType(ManagementEventAggregationConditionResponsePtrOutput{})
	pulumi.RegisterOutputType(ManagementEventRuleConditionOutput{})
	pulumi.RegisterOutputType(ManagementEventRuleConditionResponseOutput{})
	pulumi.RegisterOutputType(MetricTriggerOutput{})
	pulumi.RegisterOutputType(MetricTriggerResponseOutput{})
	pulumi.RegisterOutputType(RecurrenceOutput{})
	pulumi.RegisterOutputType(RecurrencePtrOutput{})
	pulumi.RegisterOutputType(RecurrenceResponseOutput{})
	pulumi.RegisterOutputType(RecurrenceResponsePtrOutput{})
	pulumi.RegisterOutputType(RecurrentScheduleOutput{})
	pulumi.RegisterOutputType(RecurrentSchedulePtrOutput{})
	pulumi.RegisterOutputType(RecurrentScheduleResponseOutput{})
	pulumi.RegisterOutputType(RecurrentScheduleResponsePtrOutput{})
	pulumi.RegisterOutputType(RuleEmailActionOutput{})
	pulumi.RegisterOutputType(RuleEmailActionResponseOutput{})
	pulumi.RegisterOutputType(RuleManagementEventClaimsDataSourceOutput{})
	pulumi.RegisterOutputType(RuleManagementEventClaimsDataSourcePtrOutput{})
	pulumi.RegisterOutputType(RuleManagementEventClaimsDataSourceResponseOutput{})
	pulumi.RegisterOutputType(RuleManagementEventClaimsDataSourceResponsePtrOutput{})
	pulumi.RegisterOutputType(RuleManagementEventDataSourceOutput{})
	pulumi.RegisterOutputType(RuleManagementEventDataSourceResponseOutput{})
	pulumi.RegisterOutputType(RuleMetricDataSourceOutput{})
	pulumi.RegisterOutputType(RuleMetricDataSourceResponseOutput{})
	pulumi.RegisterOutputType(RuleWebhookActionOutput{})
	pulumi.RegisterOutputType(RuleWebhookActionResponseOutput{})
	pulumi.RegisterOutputType(ScaleActionOutput{})
	pulumi.RegisterOutputType(ScaleActionResponseOutput{})
	pulumi.RegisterOutputType(ScaleCapacityOutput{})
	pulumi.RegisterOutputType(ScaleCapacityResponseOutput{})
	pulumi.RegisterOutputType(ScaleRuleOutput{})
	pulumi.RegisterOutputType(ScaleRuleArrayOutput{})
	pulumi.RegisterOutputType(ScaleRuleMetricDimensionOutput{})
	pulumi.RegisterOutputType(ScaleRuleMetricDimensionArrayOutput{})
	pulumi.RegisterOutputType(ScaleRuleMetricDimensionResponseOutput{})
	pulumi.RegisterOutputType(ScaleRuleMetricDimensionResponseArrayOutput{})
	pulumi.RegisterOutputType(ScaleRuleResponseOutput{})
	pulumi.RegisterOutputType(ScaleRuleResponseArrayOutput{})
	pulumi.RegisterOutputType(ThresholdRuleConditionOutput{})
	pulumi.RegisterOutputType(ThresholdRuleConditionResponseOutput{})
	pulumi.RegisterOutputType(TimeWindowOutput{})
	pulumi.RegisterOutputType(TimeWindowPtrOutput{})
	pulumi.RegisterOutputType(TimeWindowResponseOutput{})
	pulumi.RegisterOutputType(TimeWindowResponsePtrOutput{})
	pulumi.RegisterOutputType(WebhookNotificationOutput{})
	pulumi.RegisterOutputType(WebhookNotificationArrayOutput{})
	pulumi.RegisterOutputType(WebhookNotificationResponseOutput{})
	pulumi.RegisterOutputType(WebhookNotificationResponseArrayOutput{})
}
